{"traceEvents":[{"ph":"M","pid":131246,"tid":131246,"name":"process_name","args":{"name":"MainProcess"}},{"ph":"M","pid":131246,"tid":131246,"name":"thread_name","args":{"name":"MainThread"}},{"pid":131246,"tid":131246,"ts":1234080173930.547,"ph":"X","cat":"fee","dur":0.76,"name":"_io.TextIOWrapper.fileno"},{"pid":131246,"tid":131246,"ts":1234080173931.507,"ph":"X","cat":"fee","dur":1.67,"name":"posix.get_terminal_size"},{"pid":131246,"tid":131246,"ts":1234080173918.527,"ph":"X","cat":"fee","dur":15.98,"name":"get_terminal_size (/home/ma-user/anaconda3/envs/py311/lib/python3.11/shutil.py:1386)"},{"pid":131246,"tid":131246,"ts":1234080173937.077,"ph":"X","cat":"fee","dur":0.68,"name":"ProcessManager (/home/lc/omni_infer/tools/scripts/start_api_servers.py:53)"},{"pid":131246,"tid":131246,"ts":1234080173935.967,"ph":"X","cat":"fee","dur":12.07,"name":"builtins.__build_class__"},{"pid":131246,"tid":131246,"ts":1234080173964.687,"ph":"X","cat":"fee","dur":0.3,"name":"dict.setdefault"},{"pid":131246,"tid":131246,"ts":1234080173964.277,"ph":"X","cat":"fee","dur":1.11,"name":"_ActionsContainer.register (/home/ma-user/anaconda3/envs/py311/lib/python3.11/argparse.py:1383)"},{"pid":131246,"tid":131246,"ts":1234080173966.047,"ph":"X","cat":"fee","dur":0.09,"name":"dict.setdefault"},{"pid":131246,"tid":131246,"ts":1234080173965.827,"ph":"X","cat":"fee","dur":0.54,"name":"_ActionsContainer.register (/home/ma-user/anaconda3/envs/py311/lib/python3.11/argparse.py:1383)"},{"pid":131246,"tid":131246,"ts":1234080173966.887,"ph":"X","cat":"fee","dur":0.06,"name":"dict.setdefault"},{"pid":131246,"tid":131246,"ts":1234080173966.707,"ph":"X","cat":"fee","dur":0.4,"name":"_ActionsContainer.register (/home/ma-user/anaconda3/envs/py311/lib/python3.11/argparse.py:1383)"},{"pid":131246,"tid":131246,"ts":1234080173967.587,"ph":"X","cat":"fee","dur":0.06,"name":"dict.setdefault"},{"pid":131246,"tid":131246,"ts":1234080173967.437,"ph":"X","cat":"fee","dur":0.35,"name":"_ActionsContainer.register (/home/ma-user/anaconda3/envs/py311/lib/python3.11/argparse.py:1383)"},{"pid":131246,"tid":131246,"ts":1234080173968.257,"ph":"X","cat":"fee","dur":0.05,"name":"dict.setdefault"},{"pid":131246,"tid":131246,"ts":1234080173968.107,"ph":"X","cat":"fee","dur":0.35,"name":"_ActionsContainer.register (/home/ma-user/anaconda3/envs/py311/lib/python3.11/argparse.py:1383)"},{"pid":131246,"tid":131246,"ts":1234080173968.957,"ph":"X","cat":"fee","dur":0.06,"name":"dict.setdefault"},{"pid":131246,"tid":131246,"ts":1234080173968.807,"ph":"X","cat":"fee","dur":0.55,"name":"_ActionsContainer.register (/home/ma-user/anaconda3/envs/py311/lib/python3.11/argparse.py:1383)"},{"pid":131246,"tid":131246,"ts":1234080173969.867,"ph":"X","cat":"fee","dur":0.06,"name":"dict.setdefault"},{"pid":131246,"tid":131246,"ts":1234080173969.727,"ph":"X","cat":"fee","dur":0.36,"name":"_ActionsContainer.register (/home/ma-user/anaconda3/envs/py311/lib/python3.11/argparse.py:1383)"},{"pid":131246,"tid":131246,"ts":1234080173970.487,"ph":"X","cat":"fee","dur":0.06,"name":"dict.setdefault"},{"pid":131246,"tid":131246,"ts":1234080173970.347,"ph":"X","cat":"fee","dur":0.39,"name":"_ActionsContainer.register (/home/ma-user/anaconda3/envs/py311/lib/python3.11/argparse.py:1383)"},{"pid":131246,"tid":131246,"ts":1234080173971.197,"ph":"X","cat":"fee","dur":0.06,"name":"dict.setdefault"},{"pid":131246,"tid":131246,"ts":1234080173971.047,"ph":"X","cat":"fee","dur":0.38,"name":"_ActionsContainer.register (/home/ma-user/anaconda3/envs/py311/lib/python3.11/argparse.py:1383)"},{"pid":131246,"tid":131246,"ts":1234080173971.907,"ph":"X","cat":"fee","dur":0.06,"name":"dict.setdefault"},{"pid":131246,"tid":131246,"ts":1234080173971.767,"ph":"X","cat":"fee","dur":0.35,"name":"_ActionsContainer.register (/home/ma-user/anaconda3/envs/py311/lib/python3.11/argparse.py:1383)"},{"pid":131246,"tid":131246,"ts":1234080173972.527,"ph":"X","cat":"fee","dur":0.06,"name":"dict.setdefault"},{"pid":131246,"tid":131246,"ts":1234080173972.387,"ph":"X","cat":"fee","dur":0.56,"name":"_ActionsContainer.register (/home/ma-user/anaconda3/envs/py311/lib/python3.11/argparse.py:1383)"},{"pid":131246,"tid":131246,"ts":1234080173973.437,"ph":"X","cat":"fee","dur":0.06,"name":"dict.setdefault"},{"pid":131246,"tid":131246,"ts":1234080173973.267,"ph":"X","cat":"fee","dur":0.38,"name":"_ActionsContainer.register (/home/ma-user/anaconda3/envs/py311/lib/python3.11/argparse.py:1383)"},{"pid":131246,"tid":131246,"ts":1234080173976.837,"ph":"X","cat":"fee","dur":0.55,"name":"builtins.getattr"},{"pid":131246,"tid":131246,"ts":1234080173975.137,"ph":"X","cat":"fee","dur":2.35,"name":"_ActionsContainer._get_handler (/home/ma-user/anaconda3/envs/py311/lib/python3.11/argparse.py:1591)"},{"pid":131246,"tid":131246,"ts":1234080173979.297,"ph":"X","cat":"fee","dur":0.42,"name":"builtins.isinstance"},{"pid":131246,"tid":131246,"ts":1234080173979.037,"ph":"X","cat":"fee","dur":1.461,"name":"_compile (/home/ma-user/anaconda3/envs/py311/lib/python3.11/re/__init__.py:272)"},{"pid":131246,"tid":131246,"ts":1234080173978.797,"ph":"X","cat":"fee","dur":1.871,"name":"compile (/home/ma-user/anaconda3/envs/py311/lib/python3.11/re/__init__.py:225)"},{"pid":131246,"tid":131246,"ts":1234080173960.367,"ph":"X","cat":"fee","dur":20.601,"name":"_ActionsContainer.__init__ (/home/ma-user/anaconda3/envs/py311/lib/python3.11/argparse.py:1330)"},{"pid":131246,"tid":131246,"ts":1234080173989.988,"ph":"X","cat":"fee","dur":0.11,"name":"dict.get"},{"pid":131246,"tid":131246,"ts":1234080174010.268,"ph":"X","cat":"fee","dur":1.25,"name":"str.split"},{"pid":131246,"tid":131246,"ts":1234080174012.068,"ph":"X","cat":"fee","dur":0.1,"name":"list.append"},{"pid":131246,"tid":131246,"ts":1234080174025.208,"ph":"X","cat":"fee","dur":0.36,"name":"str.lower"},{"pid":131246,"tid":131246,"ts":1234080174026.098,"ph":"X","cat":"fee","dur":0.36,"name":"str.split"},{"pid":131246,"tid":131246,"ts":1234080174027.268,"ph":"X","cat":"fee","dur":0.92,"name":"str.replace"},{"pid":131246,"tid":131246,"ts":1234080174028.408,"ph":"X","cat":"fee","dur":0.12,"name":"str.replace"},{"pid":131246,"tid":131246,"ts":1234080174029.328,"ph":"X","cat":"fee","dur":0.34,"name":"dict.get"},{"pid":131246,"tid":131246,"ts":1234080174030.058,"ph":"X","cat":"fee","dur":0.24,"name":"dict.get"},{"pid":131246,"tid":131246,"ts":1234080174033.868,"ph":"X","cat":"fee","dur":0.43,"name":"str.index"},{"pid":131246,"tid":131246,"ts":1234080174037.238,"ph":"X","cat":"fee","dur":0.16,"name":"builtins.isinstance"},{"pid":131246,"tid":131246,"ts":1234080174037.848,"ph":"X","cat":"fee","dur":0.41,"name":"str.isalnum"},{"pid":131246,"tid":131246,"ts":1234080174040.048,"ph":"X","cat":"fee","dur":0.3,"name":"str.isascii"},{"pid":131246,"tid":131246,"ts":1234080174040.558,"ph":"X","cat":"fee","dur":0.12,"name":"list.append"},{"pid":131246,"tid":131246,"ts":1234080174040.948,"ph":"X","cat":"fee","dur":0.07,"name":"str.isalnum"},{"pid":131246,"tid":131246,"ts":1234080174041.188,"ph":"X","cat":"fee","dur":0.06,"name":"str.isascii"},{"pid":131246,"tid":131246,"ts":1234080174041.408,"ph":"X","cat":"fee","dur":0.07,"name":"list.append"},{"pid":131246,"tid":131246,"ts":1234080174041.678,"ph":"X","cat":"fee","dur":0.08,"name":"str.isalnum"},{"pid":131246,"tid":131246,"ts":1234080174041.918,"ph":"X","cat":"fee","dur":0.06,"name":"str.isascii"},{"pid":131246,"tid":131246,"ts":1234080174042.128,"ph":"X","cat":"fee","dur":0.07,"name":"list.append"},{"pid":131246,"tid":131246,"ts":1234080174042.358,"ph":"X","cat":"fee","dur":0.22,"name":"str.isalnum"},{"pid":131246,"tid":131246,"ts":1234080174042.898,"ph":"X","cat":"fee","dur":0.14,"name":"str.isalnum"},{"pid":131246,"tid":131246,"ts":1234080174043.278,"ph":"X","cat":"fee","dur":0.06,"name":"list.append"},{"pid":131246,"tid":131246,"ts":1234080174043.488,"ph":"X","cat":"fee","dur":0.07,"name":"str.isascii"},{"pid":131246,"tid":131246,"ts":1234080174043.718,"ph":"X","cat":"fee","dur":0.12,"name":"list.append"},{"pid":131246,"tid":131246,"ts":1234080174044.168,"ph":"X","cat":"fee","dur":0.42,"name":"str.join"},{"pid":131246,"tid":131246,"ts":1234080174036.978,"ph":"X","cat":"fee","dur":7.73,"name":"normalize_encoding (/home/ma-user/anaconda3/envs/py311/lib/python3.11/encodings/__init__.py:43)"},{"pid":131246,"tid":131246,"ts":1234080174045.388,"ph":"X","cat":"fee","dur":0.11,"name":"str.lower"},{"pid":131246,"tid":131246,"ts":1234080174045.648,"ph":"X","cat":"fee","dur":0.43,"name":"dict.get"},{"pid":131246,"tid":131246,"ts":1234080174046.308,"ph":"X","cat":"fee","dur":0.09,"name":"str.lower"},{"pid":131246,"tid":131246,"ts":1234080174033.238,"ph":"X","cat":"fee","dur":14.29,"name":"_replace_encoding (/home/ma-user/anaconda3/envs/py311/lib/python3.11/locale.py:362)"},{"pid":131246,"tid":131246,"ts":1234080174024.798,"ph":"X","cat":"fee","dur":22.91,"name":"normalize (/home/ma-user/anaconda3/envs/py311/lib/python3.11/locale.py:396)"},{"pid":131246,"tid":131246,"ts":1234080174048.138,"ph":"X","cat":"fee","dur":0.32,"name":"str.find"},{"pid":131246,"tid":131246,"ts":1234080174048.758,"ph":"X","cat":"fee","dur":0.19,"name":"str.find"},{"pid":131246,"tid":131246,"ts":1234080174049.558,"ph":"X","cat":"fee","dur":0.15,"name":"str.find"},{"pid":131246,"tid":131246,"ts":1234080174051.198,"ph":"X","cat":"fee","dur":0.09,"name":"list.append"},{"pid":131246,"tid":131246,"ts":1234080174051.878,"ph":"X","cat":"fee","dur":0.06,"name":"list.append"},{"pid":131246,"tid":131246,"ts":1234080174052.348,"ph":"X","cat":"fee","dur":0.07,"name":"list.append"},{"pid":131246,"tid":131246,"ts":1234080174052.878,"ph":"X","cat":"fee","dur":0.05,"name":"list.append"},{"pid":131246,"tid":131246,"ts":1234080174053.408,"ph":"X","cat":"fee","dur":0.15,"name":"list.reverse"},{"pid":131246,"tid":131246,"ts":1234080174016.628,"ph":"X","cat":"fee","dur":37.05,"name":"_expand_lang (/home/ma-user/anaconda3/envs/py311/lib/python3.11/gettext.py:216)"},{"pid":131246,"tid":131246,"ts":1234080174054.108,"ph":"X","cat":"fee","dur":0.07,"name":"list.append"},{"pid":131246,"tid":131246,"ts":1234080174054.408,"ph":"X","cat":"fee","dur":0.05,"name":"list.append"},{"pid":131246,"tid":131246,"ts":1234080174054.658,"ph":"X","cat":"fee","dur":0.04,"name":"list.append"},{"pid":131246,"tid":131246,"ts":1234080174054.898,"ph":"X","cat":"fee","dur":0.05,"name":"list.append"},{"pid":131246,"tid":131246,"ts":1234080174056.128,"ph":"X","cat":"fee","dur":0.09,"name":"str.lower"},{"pid":131246,"tid":131246,"ts":1234080174056.748,"ph":"X","cat":"fee","dur":0.26,"name":"dict.get"},{"pid":131246,"tid":131246,"ts":1234080174055.988,"ph":"X","cat":"fee","dur":1.17,"name":"normalize (/home/ma-user/anaconda3/envs/py311/lib/python3.11/locale.py:396)"},{"pid":131246,"tid":131246,"ts":1234080174057.458,"ph":"X","cat":"fee","dur":0.2,"name":"str.find"},{"pid":131246,"tid":131246,"ts":1234080174057.888,"ph":"X","cat":"fee","dur":0.16,"name":"str.find"},{"pid":131246,"tid":131246,"ts":1234080174058.268,"ph":"X","cat":"fee","dur":0.15,"name":"str.find"},{"pid":131246,"tid":131246,"ts":1234080174059.158,"ph":"X","cat":"fee","dur":0.08,"name":"list.append"},{"pid":131246,"tid":131246,"ts":1234080174059.418,"ph":"X","cat":"fee","dur":0.08,"name":"list.reverse"},{"pid":131246,"tid":131246,"ts":1234080174055.438,"ph":"X","cat":"fee","dur":4.17,"name":"_expand_lang (/home/ma-user/anaconda3/envs/py311/lib/python3.11/gettext.py:216)"},{"pid":131246,"tid":131246,"ts":1234080174059.928,"ph":"X","cat":"fee","dur":0.1,"name":"list.append"},{"pid":131246,"tid":131246,"ts":1234080173997.808,"ph":"X","cat":"fee","dur":109.881,"name":"find (/home/ma-user/anaconda3/envs/py311/lib/python3.11/gettext.py:467)"},{"pid":131246,"tid":131246,"ts":1234080173993.738,"ph":"X","cat":"fee","dur":117.901,"name":"translation (/home/ma-user/anaconda3/envs/py311/lib/python3.11/gettext.py:507)"},{"pid":131246,"tid":131246,"ts":1234080173989.198,"ph":"X","cat":"fee","dur":123.251,"name":"dgettext (/home/ma-user/anaconda3/envs/py311/lib/python3.11/gettext.py:566)"},{"pid":131246,"tid":131246,"ts":1234080173987.778,"ph":"X","cat":"fee","dur":126.111,"name":"gettext (/home/ma-user/anaconda3/envs/py311/lib/python3.11/gettext.py:604)"},{"pid":131246,"tid":131246,"ts":1234080174118.959,"ph":"X","cat":"fee","dur":0.17,"name":"dict.setdefault"},{"pid":131246,"tid":131246,"ts":1234080174119.369,"ph":"X","cat":"fee","dur":0.19,"name":"dict.setdefault"},{"pid":131246,"tid":131246,"ts":1234080174119.749,"ph":"X","cat":"fee","dur":0.08,"name":"dict.setdefault"},{"pid":131246,"tid":131246,"ts":1234080174122.989,"ph":"X","cat":"fee","dur":0.14,"name":"dict.setdefault"},{"pid":131246,"tid":131246,"ts":1234080174122.739,"ph":"X","cat":"fee","dur":0.72,"name":"_ActionsContainer.register (/home/ma-user/anaconda3/envs/py311/lib/python3.11/argparse.py:1383)"},{"pid":131246,"tid":131246,"ts":1234080174124.039,"ph":"X","cat":"fee","dur":0.08,"name":"dict.setdefault"},{"pid":131246,"tid":131246,"ts":1234080174123.839,"ph":"X","cat":"fee","dur":0.54,"name":"_ActionsContainer.register (/home/ma-user/anaconda3/envs/py311/lib/python3.11/argparse.py:1383)"},{"pid":131246,"tid":131246,"ts":1234080174124.839,"ph":"X","cat":"fee","dur":0.06,"name":"dict.setdefault"},{"pid":131246,"tid":131246,"ts":1234080174124.669,"ph":"X","cat":"fee","dur":0.4,"name":"_ActionsContainer.register (/home/ma-user/anaconda3/envs/py311/lib/python3.11/argparse.py:1383)"},{"pid":131246,"tid":131246,"ts":1234080174125.509,"ph":"X","cat":"fee","dur":0.06,"name":"dict.setdefault"},{"pid":131246,"tid":131246,"ts":1234080174125.359,"ph":"X","cat":"fee","dur":0.37,"name":"_ActionsContainer.register (/home/ma-user/anaconda3/envs/py311/lib/python3.11/argparse.py:1383)"},{"pid":131246,"tid":131246,"ts":1234080174126.129,"ph":"X","cat":"fee","dur":0.06,"name":"dict.setdefault"},{"pid":131246,"tid":131246,"ts":1234080174125.989,"ph":"X","cat":"fee","dur":0.35,"name":"_ActionsContainer.register (/home/ma-user/anaconda3/envs/py311/lib/python3.11/argparse.py:1383)"},{"pid":131246,"tid":131246,"ts":1234080174126.779,"ph":"X","cat":"fee","dur":0.07,"name":"dict.setdefault"},{"pid":131246,"tid":131246,"ts":1234080174126.639,"ph":"X","cat":"fee","dur":0.52,"name":"_ActionsContainer.register (/home/ma-user/anaconda3/envs/py311/lib/python3.11/argparse.py:1383)"},{"pid":131246,"tid":131246,"ts":1234080174127.589,"ph":"X","cat":"fee","dur":0.05,"name":"dict.setdefault"},{"pid":131246,"tid":131246,"ts":1234080174127.439,"ph":"X","cat":"fee","dur":0.35,"name":"_ActionsContainer.register (/home/ma-user/anaconda3/envs/py311/lib/python3.11/argparse.py:1383)"},{"pid":131246,"tid":131246,"ts":1234080174128.179,"ph":"X","cat":"fee","dur":0.06,"name":"dict.setdefault"},{"pid":131246,"tid":131246,"ts":1234080174128.029,"ph":"X","cat":"fee","dur":0.37,"name":"_ActionsContainer.register (/home/ma-user/anaconda3/envs/py311/lib/python3.11/argparse.py:1383)"},{"pid":131246,"tid":131246,"ts":1234080174128.809,"ph":"X","cat":"fee","dur":0.05,"name":"dict.setdefault"},{"pid":131246,"tid":131246,"ts":1234080174128.659,"ph":"X","cat":"fee","dur":0.36,"name":"_ActionsContainer.register (/home/ma-user/anaconda3/envs/py311/lib/python3.11/argparse.py:1383)"},{"pid":131246,"tid":131246,"ts":1234080174129.459,"ph":"X","cat":"fee","dur":0.06,"name":"dict.setdefault"},{"pid":131246,"tid":131246,"ts":1234080174129.299,"ph":"X","cat":"fee","dur":0.36,"name":"_ActionsContainer.register (/home/ma-user/anaconda3/envs/py311/lib/python3.11/argparse.py:1383)"},{"pid":131246,"tid":131246,"ts":1234080174130.039,"ph":"X","cat":"fee","dur":0.05,"name":"dict.setdefault"},{"pid":131246,"tid":131246,"ts":1234080174129.899,"ph":"X","cat":"fee","dur":0.51,"name":"_ActionsContainer.register (/home/ma-user/anaconda3/envs/py311/lib/python3.11/argparse.py:1383)"},{"pid":131246,"tid":131246,"ts":1234080174130.789,"ph":"X","cat":"fee","dur":0.05,"name":"dict.setdefault"},{"pid":131246,"tid":131246,"ts":1234080174130.639,"ph":"X","cat":"fee","dur":0.35,"name":"_ActionsContainer.register (/home/ma-user/anaconda3/envs/py311/lib/python3.11/argparse.py:1383)"},{"pid":131246,"tid":131246,"ts":1234080174131.949,"ph":"X","cat":"fee","dur":0.31,"name":"builtins.getattr"},{"pid":131246,"tid":131246,"ts":1234080174131.319,"ph":"X","cat":"fee","dur":1.04,"name":"_ActionsContainer._get_handler (/home/ma-user/anaconda3/envs/py311/lib/python3.11/argparse.py:1591)"},{"pid":131246,"tid":131246,"ts":1234080174133.749,"ph":"X","cat":"fee","dur":0.36,"name":"builtins.isinstance"},{"pid":131246,"tid":131246,"ts":1234080174133.519,"ph":"X","cat":"fee","dur":1.26,"name":"_compile (/home/ma-user/anaconda3/envs/py311/lib/python3.11/re/__init__.py:272)"},{"pid":131246,"tid":131246,"ts":1234080174133.239,"ph":"X","cat":"fee","dur":1.68,"name":"compile (/home/ma-user/anaconda3/envs/py311/lib/python3.11/re/__init__.py:225)"},{"pid":131246,"tid":131246,"ts":1234080174121.349,"ph":"X","cat":"fee","dur":14.05,"name":"_ActionsContainer.__init__ (/home/ma-user/anaconda3/envs/py311/lib/python3.11/argparse.py:1330)"},{"pid":131246,"tid":131246,"ts":1234080174118.379,"ph":"X","cat":"fee","dur":18.61,"name":"_ArgumentGroup.__init__ (/home/ma-user/anaconda3/envs/py311/lib/python3.11/argparse.py:1640)"},{"pid":131246,"tid":131246,"ts":1234080174137.509,"ph":"X","cat":"fee","dur":0.1,"name":"list.append"},{"pid":131246,"tid":131246,"ts":1234080174114.939,"ph":"X","cat":"fee","dur":22.8,"name":"_ActionsContainer.add_argument_group (/home/ma-user/anaconda3/envs/py311/lib/python3.11/argparse.py:1463)"},{"pid":131246,"tid":131246,"ts":1234080174138.739,"ph":"X","cat":"fee","dur":0.11,"name":"dict.get"},{"pid":131246,"tid":131246,"ts":1234080174149.279,"ph":"X","cat":"fee","dur":0.21,"name":"str.split"},{"pid":131246,"tid":131246,"ts":1234080174149.879,"ph":"X","cat":"fee","dur":0.08,"name":"list.append"},{"pid":131246,"tid":131246,"ts":1234080174151.119,"ph":"X","cat":"fee","dur":0.2,"name":"str.lower"},{"pid":131246,"tid":131246,"ts":1234080174151.729,"ph":"X","cat":"fee","dur":0.21,"name":"str.split"},{"pid":131246,"tid":131246,"ts":1234080174152.639,"ph":"X","cat":"fee","dur":0.32,"name":"str.replace"},{"pid":131246,"tid":131246,"ts":1234080174153.139,"ph":"X","cat":"fee","dur":0.08,"name":"str.replace"},{"pid":131246,"tid":131246,"ts":1234080174153.719,"ph":"X","cat":"fee","dur":0.13,"name":"dict.get"},{"pid":131246,"tid":131246,"ts":1234080174154.189,"ph":"X","cat":"fee","dur":0.2,"name":"dict.get"},{"pid":131246,"tid":131246,"ts":1234080174155.049,"ph":"X","cat":"fee","dur":0.3,"name":"str.index"},{"pid":131246,"tid":131246,"ts":1234080174157.419,"ph":"X","cat":"fee","dur":0.19,"name":"builtins.isinstance"},{"pid":131246,"tid":131246,"ts":1234080174157.909,"ph":"X","cat":"fee","dur":0.1,"name":"str.isalnum"},{"pid":131246,"tid":131246,"ts":1234080174158.189,"ph":"X","cat":"fee","dur":0.07,"name":"str.isascii"},{"pid":131246,"tid":131246,"ts":1234080174158.429,"ph":"X","cat":"fee","dur":0.1,"name":"list.append"},{"pid":131246,"tid":131246,"ts":1234080174158.729,"ph":"X","cat":"fee","dur":0.07,"name":"str.isalnum"},{"pid":131246,"tid":131246,"ts":1234080174158.949,"ph":"X","cat":"fee","dur":0.05,"name":"str.isascii"},{"pid":131246,"tid":131246,"ts":1234080174159.159,"ph":"X","cat":"fee","dur":0.07,"name":"list.append"},{"pid":131246,"tid":131246,"ts":1234080174159.409,"ph":"X","cat":"fee","dur":0.07,"name":"str.isalnum"},{"pid":131246,"tid":131246,"ts":1234080174159.629,"ph":"X","cat":"fee","dur":0.06,"name":"str.isascii"},{"pid":131246,"tid":131246,"ts":1234080174159.839,"ph":"X","cat":"fee","dur":0.06,"name":"list.append"},{"pid":131246,"tid":131246,"ts":1234080174160.049,"ph":"X","cat":"fee","dur":0.14,"name":"str.isalnum"},{"pid":131246,"tid":131246,"ts":1234080174160.479,"ph":"X","cat":"fee","dur":0.09,"name":"str.isalnum"},{"pid":131246,"tid":131246,"ts":1234080174160.769,"ph":"X","cat":"fee","dur":0.06,"name":"list.append"},{"pid":131246,"tid":131246,"ts":1234080174160.989,"ph":"X","cat":"fee","dur":0.07,"name":"str.isascii"},{"pid":131246,"tid":131246,"ts":1234080174161.199,"ph":"X","cat":"fee","dur":0.1,"name":"list.append"},{"pid":131246,"tid":131246,"ts":1234080174161.539,"ph":"X","cat":"fee","dur":0.22,"name":"str.join"},{"pid":131246,"tid":131246,"ts":1234080174157.149,"ph":"X","cat":"fee","dur":4.74,"name":"normalize_encoding (/home/ma-user/anaconda3/envs/py311/lib/python3.11/encodings/__init__.py:43)"},{"pid":131246,"tid":131246,"ts":1234080174162.379,"ph":"X","cat":"fee","dur":0.11,"name":"str.lower"},{"pid":131246,"tid":131246,"ts":1234080174162.649,"ph":"X","cat":"fee","dur":0.2,"name":"dict.get"},{"pid":131246,"tid":131246,"ts":1234080174163.039,"ph":"X","cat":"fee","dur":0.08,"name":"str.lower"},{"pid":131246,"tid":131246,"ts":1234080174154.789,"ph":"X","cat":"fee","dur":9.03,"name":"_replace_encoding (/home/ma-user/anaconda3/envs/py311/lib/python3.11/locale.py:362)"},{"pid":131246,"tid":131246,"ts":1234080174150.929,"ph":"X","cat":"fee","dur":13.07,"name":"normalize (/home/ma-user/anaconda3/envs/py311/lib/python3.11/locale.py:396)"},{"pid":131246,"tid":131246,"ts":1234080174164.289,"ph":"X","cat":"fee","dur":0.24,"name":"str.find"},{"pid":131246,"tid":131246,"ts":1234080174164.749,"ph":"X","cat":"fee","dur":0.15,"name":"str.find"},{"pid":131246,"tid":131246,"ts":1234080174165.479,"ph":"X","cat":"fee","dur":0.16,"name":"str.find"},{"pid":131246,"tid":131246,"ts":1234080174166.759,"ph":"X","cat":"fee","dur":0.08,"name":"list.append"},{"pid":131246,"tid":131246,"ts":1234080174167.359,"ph":"X","cat":"fee","dur":0.04,"name":"list.append"},{"pid":131246,"tid":131246,"ts":1234080174167.779,"ph":"X","cat":"fee","dur":0.04,"name":"list.append"},{"pid":131246,"tid":131246,"ts":1234080174168.219,"ph":"X","cat":"fee","dur":0.05,"name":"list.append"},{"pid":131246,"tid":131246,"ts":1234080174168.419,"ph":"X","cat":"fee","dur":0.08,"name":"list.reverse"},{"pid":131246,"tid":131246,"ts":1234080174150.369,"ph":"X","cat":"fee","dur":18.28,"name":"_expand_lang (/home/ma-user/anaconda3/envs/py311/lib/python3.11/gettext.py:216)"},{"pid":131246,"tid":131246,"ts":1234080174168.999,"ph":"X","cat":"fee","dur":0.07,"name":"list.append"},{"pid":131246,"tid":131246,"ts":1234080174169.299,"ph":"X","cat":"fee","dur":0.05,"name":"list.append"},{"pid":131246,"tid":131246,"ts":1234080174169.559,"ph":"X","cat":"fee","dur":0.06,"name":"list.append"},{"pid":131246,"tid":131246,"ts":1234080174169.819,"ph":"X","cat":"fee","dur":0.04,"name":"list.append"},{"pid":131246,"tid":131246,"ts":1234080174171.019,"ph":"X","cat":"fee","dur":0.09,"name":"str.lower"},{"pid":131246,"tid":131246,"ts":1234080174171.599,"ph":"X","cat":"fee","dur":0.16,"name":"dict.get"},{"pid":131246,"tid":131246,"ts":1234080174170.879,"ph":"X","cat":"fee","dur":1.03,"name":"normalize (/home/ma-user/anaconda3/envs/py311/lib/python3.11/locale.py:396)"},{"pid":131246,"tid":131246,"ts":1234080174172.189,"ph":"X","cat":"fee","dur":0.18,"name":"str.find"},{"pid":131246,"tid":131246,"ts":1234080174172.559,"ph":"X","cat":"fee","dur":0.15,"name":"str.find"},{"pid":131246,"tid":131246,"ts":1234080174172.889,"ph":"X","cat":"fee","dur":0.16,"name":"str.find"},{"pid":131246,"tid":131246,"ts":1234080174173.759,"ph":"X","cat":"fee","dur":0.07,"name":"list.append"},{"pid":131246,"tid":131246,"ts":1234080174173.989,"ph":"X","cat":"fee","dur":0.07,"name":"list.reverse"},{"pid":131246,"tid":131246,"ts":1234080174170.369,"ph":"X","cat":"fee","dur":3.82,"name":"_expand_lang (/home/ma-user/anaconda3/envs/py311/lib/python3.11/gettext.py:216)"},{"pid":131246,"tid":131246,"ts":1234080174174.519,"ph":"X","cat":"fee","dur":0.1,"name":"list.append"},{"pid":131246,"tid":131246,"ts":1234080174139.519,"ph":"X","cat":"fee","dur":65.631,"name":"find (/home/ma-user/anaconda3/envs/py311/lib/python3.11/gettext.py:467)"},{"pid":131246,"tid":131246,"ts":1234080174139.079,"ph":"X","cat":"fee","dur":69.021,"name":"translation (/home/ma-user/anaconda3/envs/py311/lib/python3.11/gettext.py:507)"},{"pid":131246,"tid":131246,"ts":1234080174138.469,"ph":"X","cat":"fee","dur":71.411,"name":"dgettext (/home/ma-user/anaconda3/envs/py311/lib/python3.11/gettext.py:566)"},{"pid":131246,"tid":131246,"ts":1234080174138.219,"ph":"X","cat":"fee","dur":71.801,"name":"gettext (/home/ma-user/anaconda3/envs/py311/lib/python3.11/gettext.py:604)"},{"pid":131246,"tid":131246,"ts":1234080174211.77,"ph":"X","cat":"fee","dur":0.16,"name":"dict.setdefault"},{"pid":131246,"tid":131246,"ts":1234080174212.12,"ph":"X","cat":"fee","dur":0.11,"name":"dict.setdefault"},{"pid":131246,"tid":131246,"ts":1234080174212.35,"ph":"X","cat":"fee","dur":0.07,"name":"dict.setdefault"},{"pid":131246,"tid":131246,"ts":1234080174214.81,"ph":"X","cat":"fee","dur":0.14,"name":"dict.setdefault"},{"pid":131246,"tid":131246,"ts":1234080174214.6,"ph":"X","cat":"fee","dur":0.64,"name":"_ActionsContainer.register (/home/ma-user/anaconda3/envs/py311/lib/python3.11/argparse.py:1383)"},{"pid":131246,"tid":131246,"ts":1234080174215.74,"ph":"X","cat":"fee","dur":0.09,"name":"dict.setdefault"},{"pid":131246,"tid":131246,"ts":1234080174215.54,"ph":"X","cat":"fee","dur":0.5,"name":"_ActionsContainer.register (/home/ma-user/anaconda3/envs/py311/lib/python3.11/argparse.py:1383)"},{"pid":131246,"tid":131246,"ts":1234080174216.47,"ph":"X","cat":"fee","dur":0.06,"name":"dict.setdefault"},{"pid":131246,"tid":131246,"ts":1234080174216.3,"ph":"X","cat":"fee","dur":0.39,"name":"_ActionsContainer.register (/home/ma-user/anaconda3/envs/py311/lib/python3.11/argparse.py:1383)"},{"pid":131246,"tid":131246,"ts":1234080174217.13,"ph":"X","cat":"fee","dur":0.06,"name":"dict.setdefault"},{"pid":131246,"tid":131246,"ts":1234080174216.97,"ph":"X","cat":"fee","dur":0.37,"name":"_ActionsContainer.register (/home/ma-user/anaconda3/envs/py311/lib/python3.11/argparse.py:1383)"},{"pid":131246,"tid":131246,"ts":1234080174217.72,"ph":"X","cat":"fee","dur":0.06,"name":"dict.setdefault"},{"pid":131246,"tid":131246,"ts":1234080174217.58,"ph":"X","cat":"fee","dur":0.35,"name":"_ActionsContainer.register (/home/ma-user/anaconda3/envs/py311/lib/python3.11/argparse.py:1383)"},{"pid":131246,"tid":131246,"ts":1234080174218.33,"ph":"X","cat":"fee","dur":0.05,"name":"dict.setdefault"},{"pid":131246,"tid":131246,"ts":1234080174218.18,"ph":"X","cat":"fee","dur":0.48,"name":"_ActionsContainer.register (/home/ma-user/anaconda3/envs/py311/lib/python3.11/argparse.py:1383)"},{"pid":131246,"tid":131246,"ts":1234080174219.1,"ph":"X","cat":"fee","dur":0.06,"name":"dict.setdefault"},{"pid":131246,"tid":131246,"ts":1234080174218.95,"ph":"X","cat":"fee","dur":0.35,"name":"_ActionsContainer.register (/home/ma-user/anaconda3/envs/py311/lib/python3.11/argparse.py:1383)"},{"pid":131246,"tid":131246,"ts":1234080174219.69,"ph":"X","cat":"fee","dur":0.06,"name":"dict.setdefault"},{"pid":131246,"tid":131246,"ts":1234080174219.54,"ph":"X","cat":"fee","dur":0.37,"name":"_ActionsContainer.register (/home/ma-user/anaconda3/envs/py311/lib/python3.11/argparse.py:1383)"},{"pid":131246,"tid":131246,"ts":1234080174220.29,"ph":"X","cat":"fee","dur":0.06,"name":"dict.setdefault"},{"pid":131246,"tid":131246,"ts":1234080174220.14,"ph":"X","cat":"fee","dur":0.37,"name":"_ActionsContainer.register (/home/ma-user/anaconda3/envs/py311/lib/python3.11/argparse.py:1383)"},{"pid":131246,"tid":131246,"ts":1234080174220.92,"ph":"X","cat":"fee","dur":0.06,"name":"dict.setdefault"},{"pid":131246,"tid":131246,"ts":1234080174220.77,"ph":"X","cat":"fee","dur":0.35,"name":"_ActionsContainer.register (/home/ma-user/anaconda3/envs/py311/lib/python3.11/argparse.py:1383)"},{"pid":131246,"tid":131246,"ts":1234080174221.52,"ph":"X","cat":"fee","dur":0.05,"name":"dict.setdefault"},{"pid":131246,"tid":131246,"ts":1234080174221.35,"ph":"X","cat":"fee","dur":0.52,"name":"_ActionsContainer.register (/home/ma-user/anaconda3/envs/py311/lib/python3.11/argparse.py:1383)"},{"pid":131246,"tid":131246,"ts":1234080174222.26,"ph":"X","cat":"fee","dur":0.05,"name":"dict.setdefault"},{"pid":131246,"tid":131246,"ts":1234080174222.11,"ph":"X","cat":"fee","dur":0.35,"name":"_ActionsContainer.register (/home/ma-user/anaconda3/envs/py311/lib/python3.11/argparse.py:1383)"},{"pid":131246,"tid":131246,"ts":1234080174223.24,"ph":"X","cat":"fee","dur":0.34,"name":"builtins.getattr"},{"pid":131246,"tid":131246,"ts":1234080174222.69,"ph":"X","cat":"fee","dur":0.98,"name":"_ActionsContainer._get_handler (/home/ma-user/anaconda3/envs/py311/lib/python3.11/argparse.py:1591)"},{"pid":131246,"tid":131246,"ts":1234080174224.83,"ph":"X","cat":"fee","dur":0.3,"name":"builtins.isinstance"},{"pid":131246,"tid":131246,"ts":1234080174224.64,"ph":"X","cat":"fee","dur":0.99,"name":"_compile (/home/ma-user/anaconda3/envs/py311/lib/python3.11/re/__init__.py:272)"},{"pid":131246,"tid":131246,"ts":1234080174224.41,"ph":"X","cat":"fee","dur":1.37,"name":"compile (/home/ma-user/anaconda3/envs/py311/lib/python3.11/re/__init__.py:225)"},{"pid":131246,"tid":131246,"ts":1234080174213.58,"ph":"X","cat":"fee","dur":12.43,"name":"_ActionsContainer.__init__ (/home/ma-user/anaconda3/envs/py311/lib/python3.11/argparse.py:1330)"},{"pid":131246,"tid":131246,"ts":1234080174211.39,"ph":"X","cat":"fee","dur":15.83,"name":"_ArgumentGroup.__init__ (/home/ma-user/anaconda3/envs/py311/lib/python3.11/argparse.py:1640)"},{"pid":131246,"tid":131246,"ts":1234080174227.65,"ph":"X","cat":"fee","dur":0.06,"name":"list.append"},{"pid":131246,"tid":131246,"ts":1234080174210.44,"ph":"X","cat":"fee","dur":17.39,"name":"_ActionsContainer.add_argument_group (/home/ma-user/anaconda3/envs/py311/lib/python3.11/argparse.py:1463)"},{"pid":131246,"tid":131246,"ts":1234080174228.7,"ph":"X","cat":"fee","dur":0.11,"name":"dict.setdefault"},{"pid":131246,"tid":131246,"ts":1234080174228.54,"ph":"X","cat":"fee","dur":0.5,"name":"_ActionsContainer.register (/home/ma-user/anaconda3/envs/py311/lib/python3.11/argparse.py:1383)"},{"pid":131246,"tid":131246,"ts":1234080174231.14,"ph":"X","cat":"fee","dur":0.1,"name":"dict.get"},{"pid":131246,"tid":131246,"ts":1234080174242.16,"ph":"X","cat":"fee","dur":0.19,"name":"str.split"},{"pid":131246,"tid":131246,"ts":1234080174242.69,"ph":"X","cat":"fee","dur":0.07,"name":"list.append"},{"pid":131246,"tid":131246,"ts":1234080174243.76,"ph":"X","cat":"fee","dur":0.12,"name":"str.lower"},{"pid":131246,"tid":131246,"ts":1234080174244.21,"ph":"X","cat":"fee","dur":0.19,"name":"str.split"},{"pid":131246,"tid":131246,"ts":1234080174245.03,"ph":"X","cat":"fee","dur":0.28,"name":"str.replace"},{"pid":131246,"tid":131246,"ts":1234080174246.57,"ph":"X","cat":"fee","dur":0.12,"name":"str.replace"},{"pid":131246,"tid":131246,"ts":1234080174247.14,"ph":"X","cat":"fee","dur":0.12,"name":"dict.get"},{"pid":131246,"tid":131246,"ts":1234080174247.57,"ph":"X","cat":"fee","dur":0.18,"name":"dict.get"},{"pid":131246,"tid":131246,"ts":1234080174248.98,"ph":"X","cat":"fee","dur":0.27,"name":"str.index"},{"pid":131246,"tid":131246,"ts":1234080174249.95,"ph":"X","cat":"fee","dur":0.15,"name":"builtins.isinstance"},{"pid":131246,"tid":131246,"ts":1234080174250.38,"ph":"X","cat":"fee","dur":0.09,"name":"str.isalnum"},{"pid":131246,"tid":131246,"ts":1234080174250.66,"ph":"X","cat":"fee","dur":0.06,"name":"str.isascii"},{"pid":131246,"tid":131246,"ts":1234080174250.88,"ph":"X","cat":"fee","dur":0.09,"name":"list.append"},{"pid":131246,"tid":131246,"ts":1234080174251.16,"ph":"X","cat":"fee","dur":0.07,"name":"str.isalnum"},{"pid":131246,"tid":131246,"ts":1234080174251.39,"ph":"X","cat":"fee","dur":0.05,"name":"str.isascii"},{"pid":131246,"tid":131246,"ts":1234080174251.6,"ph":"X","cat":"fee","dur":0.06,"name":"list.append"},{"pid":131246,"tid":131246,"ts":1234080174251.81,"ph":"X","cat":"fee","dur":0.11,"name":"str.isalnum"},{"pid":131246,"tid":131246,"ts":1234080174252.07,"ph":"X","cat":"fee","dur":0.05,"name":"str.isascii"},{"pid":131246,"tid":131246,"ts":1234080174252.27,"ph":"X","cat":"fee","dur":0.06,"name":"list.append"},{"pid":131246,"tid":131246,"ts":1234080174252.49,"ph":"X","cat":"fee","dur":0.13,"name":"str.isalnum"},{"pid":131246,"tid":131246,"ts":1234080174252.88,"ph":"X","cat":"fee","dur":0.08,"name":"str.isalnum"},{"pid":131246,"tid":131246,"ts":1234080174253.16,"ph":"X","cat":"fee","dur":0.06,"name":"list.append"},{"pid":131246,"tid":131246,"ts":1234080174253.38,"ph":"X","cat":"fee","dur":0.06,"name":"str.isascii"},{"pid":131246,"tid":131246,"ts":1234080174253.58,"ph":"X","cat":"fee","dur":0.1,"name":"list.append"},{"pid":131246,"tid":131246,"ts":1234080174253.9,"ph":"X","cat":"fee","dur":0.22,"name":"str.join"},{"pid":131246,"tid":131246,"ts":1234080174249.76,"ph":"X","cat":"fee","dur":4.49,"name":"normalize_encoding (/home/ma-user/anaconda3/envs/py311/lib/python3.11/encodings/__init__.py:43)"},{"pid":131246,"tid":131246,"ts":1234080174254.71,"ph":"X","cat":"fee","dur":0.11,"name":"str.lower"},{"pid":131246,"tid":131246,"ts":1234080174254.95,"ph":"X","cat":"fee","dur":0.17,"name":"dict.get"},{"pid":131246,"tid":131246,"ts":1234080174255.29,"ph":"X","cat":"fee","dur":0.09,"name":"str.lower"},{"pid":131246,"tid":131246,"ts":1234080174248.1,"ph":"X","cat":"fee","dur":7.79,"name":"_replace_encoding (/home/ma-user/anaconda3/envs/py311/lib/python3.11/locale.py:362)"},{"pid":131246,"tid":131246,"ts":1234080174243.6,"ph":"X","cat":"fee","dur":12.44,"name":"normalize (/home/ma-user/anaconda3/envs/py311/lib/python3.11/locale.py:396)"},{"pid":131246,"tid":131246,"ts":1234080174256.35,"ph":"X","cat":"fee","dur":0.22,"name":"str.find"},{"pid":131246,"tid":131246,"ts":1234080174256.79,"ph":"X","cat":"fee","dur":0.16,"name":"str.find"},{"pid":131246,"tid":131246,"ts":1234080174257.5,"ph":"X","cat":"fee","dur":0.15,"name":"str.find"},{"pid":131246,"tid":131246,"ts":1234080174258.73,"ph":"X","cat":"fee","dur":0.09,"name":"list.append"},{"pid":131246,"tid":131246,"ts":1234080174259.26,"ph":"X","cat":"fee","dur":0.05,"name":"list.append"},{"pid":131246,"tid":131246,"ts":1234080174259.65,"ph":"X","cat":"fee","dur":0.05,"name":"list.append"},{"pid":131246,"tid":131246,"ts":1234080174260.1,"ph":"X","cat":"fee","dur":0.05,"name":"list.append"},{"pid":131246,"tid":131246,"ts":1234080174260.3,"ph":"X","cat":"fee","dur":0.09,"name":"list.reverse"},{"pid":131246,"tid":131246,"ts":1234080174243.1,"ph":"X","cat":"fee","dur":17.44,"name":"_expand_lang (/home/ma-user/anaconda3/envs/py311/lib/python3.11/gettext.py:216)"},{"pid":131246,"tid":131246,"ts":1234080174260.88,"ph":"X","cat":"fee","dur":0.07,"name":"list.append"},{"pid":131246,"tid":131246,"ts":1234080174261.16,"ph":"X","cat":"fee","dur":0.04,"name":"list.append"},{"pid":131246,"tid":131246,"ts":1234080174261.4,"ph":"X","cat":"fee","dur":0.05,"name":"list.append"},{"pid":131246,"tid":131246,"ts":1234080174261.65,"ph":"X","cat":"fee","dur":0.05,"name":"list.append"},{"pid":131246,"tid":131246,"ts":1234080174262.68,"ph":"X","cat":"fee","dur":0.09,"name":"str.lower"},{"pid":131246,"tid":131246,"ts":1234080174263.2,"ph":"X","cat":"fee","dur":0.13,"name":"dict.get"},{"pid":131246,"tid":131246,"ts":1234080174262.55,"ph":"X","cat":"fee","dur":0.91,"name":"normalize (/home/ma-user/anaconda3/envs/py311/lib/python3.11/locale.py:396)"},{"pid":131246,"tid":131246,"ts":1234080174263.68,"ph":"X","cat":"fee","dur":0.18,"name":"str.find"},{"pid":131246,"tid":131246,"ts":1234080174264.04,"ph":"X","cat":"fee","dur":0.16,"name":"str.find"},{"pid":131246,"tid":131246,"ts":1234080174264.39,"ph":"X","cat":"fee","dur":0.15,"name":"str.find"},{"pid":131246,"tid":131246,"ts":1234080174265.2,"ph":"X","cat":"fee","dur":0.08,"name":"list.append"},{"pid":131246,"tid":131246,"ts":1234080174265.44,"ph":"X","cat":"fee","dur":0.07,"name":"list.reverse"},{"pid":131246,"tid":131246,"ts":1234080174262.07,"ph":"X","cat":"fee","dur":4.45,"name":"_expand_lang (/home/ma-user/anaconda3/envs/py311/lib/python3.11/gettext.py:216)"},{"pid":131246,"tid":131246,"ts":1234080174266.88,"ph":"X","cat":"fee","dur":0.11,"name":"list.append"},{"pid":131246,"tid":131246,"ts":1234080174232.99,"ph":"X","cat":"fee","dur":63.621,"name":"find (/home/ma-user/anaconda3/envs/py311/lib/python3.11/gettext.py:467)"},{"pid":131246,"tid":131246,"ts":1234080174231.46,"ph":"X","cat":"fee","dur":67.671,"name":"translation (/home/ma-user/anaconda3/envs/py311/lib/python3.11/gettext.py:507)"},{"pid":131246,"tid":131246,"ts":1234080174230.67,"ph":"X","cat":"fee","dur":69.071,"name":"dgettext (/home/ma-user/anaconda3/envs/py311/lib/python3.11/gettext.py:566)"},{"pid":131246,"tid":131246,"ts":1234080174230.29,"ph":"X","cat":"fee","dur":69.611,"name":"gettext (/home/ma-user/anaconda3/envs/py311/lib/python3.11/gettext.py:604)"},{"pid":131246,"tid":131246,"ts":1234080174305.941,"ph":"X","cat":"fee","dur":0.16,"name":"builtins.len"},{"pid":131246,"tid":131246,"ts":1234080174311.111,"ph":"X","cat":"fee","dur":0.09,"name":"list.append"},{"pid":131246,"tid":131246,"ts":1234080174311.421,"ph":"X","cat":"fee","dur":0.07,"name":"builtins.len"},{"pid":131246,"tid":131246,"ts":1234080174312.021,"ph":"X","cat":"fee","dur":0.05,"name":"list.append"},{"pid":131246,"tid":131246,"ts":1234080174312.221,"ph":"X","cat":"fee","dur":0.05,"name":"builtins.len"},{"pid":131246,"tid":131246,"ts":1234080174312.501,"ph":"X","cat":"fee","dur":0.07,"name":"list.append"},{"pid":131246,"tid":131246,"ts":1234080174312.811,"ph":"X","cat":"fee","dur":0.26,"name":"dict.pop"},{"pid":131246,"tid":131246,"ts":1234080174313.581,"ph":"X","cat":"fee","dur":0.33,"name":"str.lstrip"},{"pid":131246,"tid":131246,"ts":1234080174314.131,"ph":"X","cat":"fee","dur":0.14,"name":"str.replace"},{"pid":131246,"tid":131246,"ts":1234080174310.471,"ph":"X","cat":"fee","dur":4.32,"name":"_ActionsContainer._get_optional_kwargs (/home/ma-user/anaconda3/envs/py311/lib/python3.11/argparse.py:1553)"},{"pid":131246,"tid":131246,"ts":1234080174316.381,"ph":"X","cat":"fee","dur":0.13,"name":"dict.pop"},{"pid":131246,"tid":131246,"ts":1234080174317.491,"ph":"X","cat":"fee","dur":0.11,"name":"dict.get"},{"pid":131246,"tid":131246,"ts":1234080174317.201,"ph":"X","cat":"fee","dur":0.52,"name":"_ActionsContainer._registry_get (/home/ma-user/anaconda3/envs/py311/lib/python3.11/argparse.py:1387)"},{"pid":131246,"tid":131246,"ts":1234080174316.201,"ph":"X","cat":"fee","dur":1.66,"name":"_ActionsContainer._pop_action_class (/home/ma-user/anaconda3/envs/py311/lib/python3.11/argparse.py:1587)"},{"pid":131246,"tid":131246,"ts":1234080174318.181,"ph":"X","cat":"fee","dur":0.1,"name":"builtins.callable"},{"pid":131246,"tid":131246,"ts":1234080174322.381,"ph":"X","cat":"fee","dur":1.37,"name":"Action.__init__ (/home/ma-user/anaconda3/envs/py311/lib/python3.11/argparse.py:834)"},{"pid":131246,"tid":131246,"ts":1234080174320.421,"ph":"X","cat":"fee","dur":3.5,"name":"_HelpAction.__init__ (/home/ma-user/anaconda3/envs/py311/lib/python3.11/argparse.py:1099)"},{"pid":131246,"tid":131246,"ts":1234080174324.731,"ph":"X","cat":"fee","dur":0.12,"name":"dict.get"},{"pid":131246,"tid":131246,"ts":1234080174324.481,"ph":"X","cat":"fee","dur":0.49,"name":"_ActionsContainer._registry_get (/home/ma-user/anaconda3/envs/py311/lib/python3.11/argparse.py:1387)"},{"pid":131246,"tid":131246,"ts":1234080174325.151,"ph":"X","cat":"fee","dur":0.08,"name":"builtins.callable"},{"pid":131246,"tid":131246,"ts":1234080174325.521,"ph":"X","cat":"fee","dur":0.32,"name":"builtins.hasattr"},{"pid":131246,"tid":131246,"ts":1234080174336.431,"ph":"X","cat":"fee","dur":0.45,"name":"_io.TextIOWrapper.fileno"},{"pid":131246,"tid":131246,"ts":1234080174337.021,"ph":"X","cat":"fee","dur":1.14,"name":"posix.get_terminal_size"},{"pid":131246,"tid":131246,"ts":1234080174330.661,"ph":"X","cat":"fee","dur":8.65,"name":"get_terminal_size (/home/ma-user/anaconda3/envs/py311/lib/python3.11/shutil.py:1386)"},{"pid":131246,"tid":131246,"ts":1234080174340.451,"ph":"X","cat":"fee","dur":0.43,"name":"builtins.max"},{"pid":131246,"tid":131246,"ts":1234080174340.991,"ph":"X","cat":"fee","dur":0.22,"name":"builtins.min"},{"pid":131246,"tid":131246,"ts":1234080174343.131,"ph":"X","cat":"fee","dur":0.68,"name":"HelpFormatter._Section.__init__ (/home/ma-user/anaconda3/envs/py311/lib/python3.11/argparse.py:206)"},{"pid":131246,"tid":131246,"ts":1234080174344.951,"ph":"X","cat":"fee","dur":0.11,"name":"builtins.isinstance"},{"pid":131246,"tid":131246,"ts":1234080174346.361,"ph":"X","cat":"fee","dur":0.17,"name":"Enum.value (/home/ma-user/anaconda3/envs/py311/lib/python3.11/enum.py:1226)"},{"pid":131246,"tid":131246,"ts":1234080174345.821,"ph":"X","cat":"fee","dur":0.84,"name":"property.__get__ (/home/ma-user/anaconda3/envs/py311/lib/python3.11/enum.py:188)"},{"pid":131246,"tid":131246,"ts":1234080174344.761,"ph":"X","cat":"fee","dur":2.58,"name":"_compile (/home/ma-user/anaconda3/envs/py311/lib/python3.11/re/__init__.py:272)"},{"pid":131246,"tid":131246,"ts":1234080174344.501,"ph":"X","cat":"fee","dur":2.98,"name":"compile (/home/ma-user/anaconda3/envs/py311/lib/python3.11/re/__init__.py:225)"},{"pid":131246,"tid":131246,"ts":1234080174348.301,"ph":"X","cat":"fee","dur":0.32,"name":"builtins.isinstance"},{"pid":131246,"tid":131246,"ts":1234080174348.171,"ph":"X","cat":"fee","dur":0.98,"name":"_compile (/home/ma-user/anaconda3/envs/py311/lib/python3.11/re/__init__.py:272)"},{"pid":131246,"tid":131246,"ts":1234080174347.931,"ph":"X","cat":"fee","dur":1.35,"name":"compile (/home/ma-user/anaconda3/envs/py311/lib/python3.11/re/__init__.py:225)"},{"pid":131246,"tid":131246,"ts":1234080174329.681,"ph":"X","cat":"fee","dur":19.8,"name":"HelpFormatter.__init__ (/home/ma-user/anaconda3/envs/py311/lib/python3.11/argparse.py:164)"},{"pid":131246,"tid":131246,"ts":1234080174326.401,"ph":"X","cat":"fee","dur":23.39,"name":"ArgumentParser._get_formatter (/home/ma-user/anaconda3/envs/py311/lib/python3.11/argparse.py:2576)"},{"pid":131246,"tid":131246,"ts":1234080174355.911,"ph":"X","cat":"fee","dur":0.64,"name":"HelpFormatter._metavar_formatter (/home/ma-user/anaconda3/envs/py311/lib/python3.11/argparse.py:578)"},{"pid":131246,"tid":131246,"ts":1234080174358.681,"ph":"X","cat":"fee","dur":0.15,"name":"HelpFormatter._format_args.<locals>.<listcomp> (/home/ma-user/anaconda3/envs/py311/lib/python3.11/argparse.py:616)"},{"pid":131246,"tid":131246,"ts":1234080174359.161,"ph":"X","cat":"fee","dur":0.12,"name":"str.join"},{"pid":131246,"tid":131246,"ts":1234080174361.811,"ph":"X","cat":"fee","dur":0.47,"name":"builtins.isinstance"},{"pid":131246,"tid":131246,"ts":1234080174361.481,"ph":"X","cat":"fee","dur":1.21,"name":"HelpFormatter._metavar_formatter.<locals>.format (/home/ma-user/anaconda3/envs/py311/lib/python3.11/argparse.py:587)"},{"pid":131246,"tid":131246,"ts":1234080174354.241,"ph":"X","cat":"fee","dur":8.75,"name":"HelpFormatter._format_args (/home/ma-user/anaconda3/envs/py311/lib/python3.11/argparse.py:594)"},{"pid":131246,"tid":131246,"ts":1234080174369.741,"ph":"X","cat":"fee","dur":0.73,"name":"_ActionsContainer._check_conflict (/home/ma-user/anaconda3/envs/py311/lib/python3.11/argparse.py:1600)"},{"pid":131246,"tid":131246,"ts":1234080174370.821,"ph":"X","cat":"fee","dur":0.09,"name":"list.append"},{"pid":131246,"tid":131246,"ts":1234080174372.051,"ph":"X","cat":"fee","dur":2.17,"name":"re.Pattern.match"},{"pid":131246,"tid":131246,"ts":1234080174374.601,"ph":"X","cat":"fee","dur":0.37,"name":"re.Pattern.match"},{"pid":131246,"tid":131246,"ts":1234080174367.871,"ph":"X","cat":"fee","dur":7.3,"name":"_ActionsContainer._add_action (/home/ma-user/anaconda3/envs/py311/lib/python3.11/argparse.py:1473)"},{"pid":131246,"tid":131246,"ts":1234080174375.421,"ph":"X","cat":"fee","dur":0.06,"name":"list.append"},{"pid":131246,"tid":131246,"ts":1234080174365.541,"ph":"X","cat":"fee","dur":10.07,"name":"_ArgumentGroup._add_action (/home/ma-user/anaconda3/envs/py311/lib/python3.11/argparse.py:1662)"},{"pid":131246,"tid":131246,"ts":1234080174364.581,"ph":"X","cat":"fee","dur":11.2,"name":"ArgumentParser._add_action (/home/ma-user/anaconda3/envs/py311/lib/python3.11/argparse.py:1841)"},{"pid":131246,"tid":131246,"ts":1234080174305.491,"ph":"X","cat":"fee","dur":70.41,"name":"_ActionsContainer.add_argument (/home/ma-user/anaconda3/envs/py311/lib/python3.11/argparse.py:1412)"},{"pid":131246,"tid":131246,"ts":1234080173955.117,"ph":"X","cat":"fee","dur":421.164,"name":"ArgumentParser.__init__ (/home/ma-user/anaconda3/envs/py311/lib/python3.11/argparse.py:1730)"},{"pid":131246,"tid":131246,"ts":1234080174377.991,"ph":"X","cat":"fee","dur":0.13,"name":"builtins.len"},{"pid":131246,"tid":131246,"ts":1234080174379.791,"ph":"X","cat":"fee","dur":0.08,"name":"list.append"},{"pid":131246,"tid":131246,"ts":1234080174380.041,"ph":"X","cat":"fee","dur":0.12,"name":"builtins.len"},{"pid":131246,"tid":131246,"ts":1234080174380.451,"ph":"X","cat":"fee","dur":0.06,"name":"list.append"},{"pid":131246,"tid":131246,"ts":1234080174380.741,"ph":"X","cat":"fee","dur":0.11,"name":"dict.pop"},{"pid":131246,"tid":131246,"ts":1234080174381.261,"ph":"X","cat":"fee","dur":0.21,"name":"str.lstrip"},{"pid":131246,"tid":131246,"ts":1234080174381.711,"ph":"X","cat":"fee","dur":0.3,"name":"str.replace"},{"pid":131246,"tid":131246,"ts":1234080174379.361,"ph":"X","cat":"fee","dur":3.1,"name":"_ActionsContainer._get_optional_kwargs (/home/ma-user/anaconda3/envs/py311/lib/python3.11/argparse.py:1553)"},{"pid":131246,"tid":131246,"ts":1234080174383.411,"ph":"X","cat":"fee","dur":0.08,"name":"dict.pop"},{"pid":131246,"tid":131246,"ts":1234080174383.971,"ph":"X","cat":"fee","dur":0.1,"name":"dict.get"},{"pid":131246,"tid":131246,"ts":1234080174383.771,"ph":"X","cat":"fee","dur":0.42,"name":"_ActionsContainer._registry_get (/home/ma-user/anaconda3/envs/py311/lib/python3.11/argparse.py:1387)"},{"pid":131246,"tid":131246,"ts":1234080174383.211,"ph":"X","cat":"fee","dur":1.14,"name":"_ActionsContainer._pop_action_class (/home/ma-user/anaconda3/envs/py311/lib/python3.11/argparse.py:1587)"},{"pid":131246,"tid":131246,"ts":1234080174384.551,"ph":"X","cat":"fee","dur":0.08,"name":"builtins.callable"},{"pid":131246,"tid":131246,"ts":1234080174388.421,"ph":"X","cat":"fee","dur":0.97,"name":"Action.__init__ (/home/ma-user/anaconda3/envs/py311/lib/python3.11/argparse.py:834)"},{"pid":131246,"tid":131246,"ts":1234080174387.381,"ph":"X","cat":"fee","dur":2.18,"name":"_StoreAction.__init__ (/home/ma-user/anaconda3/envs/py311/lib/python3.11/argparse.py:919)"},{"pid":131246,"tid":131246,"ts":1234080174390.291,"ph":"X","cat":"fee","dur":0.1,"name":"dict.get"},{"pid":131246,"tid":131246,"ts":1234080174390.061,"ph":"X","cat":"fee","dur":0.44,"name":"_ActionsContainer._registry_get (/home/ma-user/anaconda3/envs/py311/lib/python3.11/argparse.py:1387)"},{"pid":131246,"tid":131246,"ts":1234080174390.651,"ph":"X","cat":"fee","dur":0.05,"name":"builtins.callable"},{"pid":131246,"tid":131246,"ts":1234080174390.941,"ph":"X","cat":"fee","dur":0.22,"name":"builtins.hasattr"},{"pid":131246,"tid":131246,"ts":1234080174398.002,"ph":"X","cat":"fee","dur":0.35,"name":"_io.TextIOWrapper.fileno"},{"pid":131246,"tid":131246,"ts":1234080174398.462,"ph":"X","cat":"fee","dur":0.78,"name":"posix.get_terminal_size"},{"pid":131246,"tid":131246,"ts":1234080174392.911,"ph":"X","cat":"fee","dur":7.281,"name":"get_terminal_size (/home/ma-user/anaconda3/envs/py311/lib/python3.11/shutil.py:1386)"},{"pid":131246,"tid":131246,"ts":1234080174401.072,"ph":"X","cat":"fee","dur":0.4,"name":"builtins.max"},{"pid":131246,"tid":131246,"ts":1234080174401.552,"ph":"X","cat":"fee","dur":0.19,"name":"builtins.min"},{"pid":131246,"tid":131246,"ts":1234080174402.512,"ph":"X","cat":"fee","dur":0.42,"name":"HelpFormatter._Section.__init__ (/home/ma-user/anaconda3/envs/py311/lib/python3.11/argparse.py:206)"},{"pid":131246,"tid":131246,"ts":1234080174403.852,"ph":"X","cat":"fee","dur":0.09,"name":"builtins.isinstance"},{"pid":131246,"tid":131246,"ts":1234080174404.512,"ph":"X","cat":"fee","dur":0.15,"name":"Enum.value (/home/ma-user/anaconda3/envs/py311/lib/python3.11/enum.py:1226)"},{"pid":131246,"tid":131246,"ts":1234080174404.222,"ph":"X","cat":"fee","dur":0.58,"name":"property.__get__ (/home/ma-user/anaconda3/envs/py311/lib/python3.11/enum.py:188)"},{"pid":131246,"tid":131246,"ts":1234080174403.692,"ph":"X","cat":"fee","dur":1.69,"name":"_compile (/home/ma-user/anaconda3/envs/py311/lib/python3.11/re/__init__.py:272)"},{"pid":131246,"tid":131246,"ts":1234080174403.472,"ph":"X","cat":"fee","dur":2.02,"name":"compile (/home/ma-user/anaconda3/envs/py311/lib/python3.11/re/__init__.py:225)"},{"pid":131246,"tid":131246,"ts":1234080174406.162,"ph":"X","cat":"fee","dur":0.26,"name":"builtins.isinstance"},{"pid":131246,"tid":131246,"ts":1234080174406.022,"ph":"X","cat":"fee","dur":0.72,"name":"_compile (/home/ma-user/anaconda3/envs/py311/lib/python3.11/re/__init__.py:272)"},{"pid":131246,"tid":131246,"ts":1234080174405.812,"ph":"X","cat":"fee","dur":1.04,"name":"compile (/home/ma-user/anaconda3/envs/py311/lib/python3.11/re/__init__.py:225)"},{"pid":131246,"tid":131246,"ts":1234080174392.291,"ph":"X","cat":"fee","dur":14.751,"name":"HelpFormatter.__init__ (/home/ma-user/anaconda3/envs/py311/lib/python3.11/argparse.py:164)"},{"pid":131246,"tid":131246,"ts":1234080174391.401,"ph":"X","cat":"fee","dur":17.851,"name":"ArgumentParser._get_formatter (/home/ma-user/anaconda3/envs/py311/lib/python3.11/argparse.py:2576)"},{"pid":131246,"tid":131246,"ts":1234080174409.892,"ph":"X","cat":"fee","dur":0.5,"name":"HelpFormatter._metavar_formatter (/home/ma-user/anaconda3/envs/py311/lib/python3.11/argparse.py:578)"},{"pid":131246,"tid":131246,"ts":1234080174411.112,"ph":"X","cat":"fee","dur":0.16,"name":"builtins.isinstance"},{"pid":131246,"tid":131246,"ts":1234080174410.872,"ph":"X","cat":"fee","dur":0.68,"name":"HelpFormatter._metavar_formatter.<locals>.format (/home/ma-user/anaconda3/envs/py311/lib/python3.11/argparse.py:587)"},{"pid":131246,"tid":131246,"ts":1234080174409.572,"ph":"X","cat":"fee","dur":2.7,"name":"HelpFormatter._format_args (/home/ma-user/anaconda3/envs/py311/lib/python3.11/argparse.py:594)"},{"pid":131246,"tid":131246,"ts":1234080174413.872,"ph":"X","cat":"fee","dur":0.46,"name":"_ActionsContainer._check_conflict (/home/ma-user/anaconda3/envs/py311/lib/python3.11/argparse.py:1600)"},{"pid":131246,"tid":131246,"ts":1234080174414.622,"ph":"X","cat":"fee","dur":0.08,"name":"list.append"},{"pid":131246,"tid":131246,"ts":1234080174415.452,"ph":"X","cat":"fee","dur":0.55,"name":"re.Pattern.match"},{"pid":131246,"tid":131246,"ts":1234080174413.662,"ph":"X","cat":"fee","dur":2.53,"name":"_ActionsContainer._add_action (/home/ma-user/anaconda3/envs/py311/lib/python3.11/argparse.py:1473)"},{"pid":131246,"tid":131246,"ts":1234080174416.432,"ph":"X","cat":"fee","dur":0.06,"name":"list.append"},{"pid":131246,"tid":131246,"ts":1234080174413.122,"ph":"X","cat":"fee","dur":3.49,"name":"_ArgumentGroup._add_action (/home/ma-user/anaconda3/envs/py311/lib/python3.11/argparse.py:1662)"},{"pid":131246,"tid":131246,"ts":1234080174412.792,"ph":"X","cat":"fee","dur":3.93,"name":"ArgumentParser._add_action (/home/ma-user/anaconda3/envs/py311/lib/python3.11/argparse.py:1841)"},{"pid":131246,"tid":131246,"ts":1234080174377.691,"ph":"X","cat":"fee","dur":39.151,"name":"_ActionsContainer.add_argument (/home/ma-user/anaconda3/envs/py311/lib/python3.11/argparse.py:1412)"},{"pid":131246,"tid":131246,"ts":1234080174417.882,"ph":"X","cat":"fee","dur":0.12,"name":"builtins.len"},{"pid":131246,"tid":131246,"ts":1234080174419.342,"ph":"X","cat":"fee","dur":0.06,"name":"list.append"},{"pid":131246,"tid":131246,"ts":1234080174419.552,"ph":"X","cat":"fee","dur":0.09,"name":"builtins.len"},{"pid":131246,"tid":131246,"ts":1234080174419.912,"ph":"X","cat":"fee","dur":0.06,"name":"list.append"},{"pid":131246,"tid":131246,"ts":1234080174420.182,"ph":"X","cat":"fee","dur":0.11,"name":"dict.pop"},{"pid":131246,"tid":131246,"ts":1234080174420.562,"ph":"X","cat":"fee","dur":0.2,"name":"str.lstrip"},{"pid":131246,"tid":131246,"ts":1234080174420.962,"ph":"X","cat":"fee","dur":1.23,"name":"str.replace"},{"pid":131246,"tid":131246,"ts":1234080174418.952,"ph":"X","cat":"fee","dur":3.67,"name":"_ActionsContainer._get_optional_kwargs (/home/ma-user/anaconda3/envs/py311/lib/python3.11/argparse.py:1553)"},{"pid":131246,"tid":131246,"ts":1234080174423.532,"ph":"X","cat":"fee","dur":0.08,"name":"dict.pop"},{"pid":131246,"tid":131246,"ts":1234080174424.122,"ph":"X","cat":"fee","dur":0.1,"name":"dict.get"},{"pid":131246,"tid":131246,"ts":1234080174423.902,"ph":"X","cat":"fee","dur":0.43,"name":"_ActionsContainer._registry_get (/home/ma-user/anaconda3/envs/py311/lib/python3.11/argparse.py:1387)"},{"pid":131246,"tid":131246,"ts":1234080174423.352,"ph":"X","cat":"fee","dur":1.13,"name":"_ActionsContainer._pop_action_class (/home/ma-user/anaconda3/envs/py311/lib/python3.11/argparse.py:1587)"},{"pid":131246,"tid":131246,"ts":1234080174424.622,"ph":"X","cat":"fee","dur":0.07,"name":"builtins.callable"},{"pid":131246,"tid":131246,"ts":1234080174426.172,"ph":"X","cat":"fee","dur":0.44,"name":"Action.__init__ (/home/ma-user/anaconda3/envs/py311/lib/python3.11/argparse.py:834)"},{"pid":131246,"tid":131246,"ts":1234080174425.452,"ph":"X","cat":"fee","dur":1.3,"name":"_StoreAction.__init__ (/home/ma-user/anaconda3/envs/py311/lib/python3.11/argparse.py:919)"},{"pid":131246,"tid":131246,"ts":1234080174427.422,"ph":"X","cat":"fee","dur":0.09,"name":"dict.get"},{"pid":131246,"tid":131246,"ts":1234080174427.222,"ph":"X","cat":"fee","dur":0.4,"name":"_ActionsContainer._registry_get (/home/ma-user/anaconda3/envs/py311/lib/python3.11/argparse.py:1387)"},{"pid":131246,"tid":131246,"ts":1234080174427.772,"ph":"X","cat":"fee","dur":0.05,"name":"builtins.callable"},{"pid":131246,"tid":131246,"ts":1234080174428.052,"ph":"X","cat":"fee","dur":0.16,"name":"builtins.hasattr"},{"pid":131246,"tid":131246,"ts":1234080174434.522,"ph":"X","cat":"fee","dur":0.22,"name":"_io.TextIOWrapper.fileno"},{"pid":131246,"tid":131246,"ts":1234080174434.842,"ph":"X","cat":"fee","dur":0.68,"name":"posix.get_terminal_size"},{"pid":131246,"tid":131246,"ts":1234080174429.722,"ph":"X","cat":"fee","dur":6.66,"name":"get_terminal_size (/home/ma-user/anaconda3/envs/py311/lib/python3.11/shutil.py:1386)"},{"pid":131246,"tid":131246,"ts":1234080174437.152,"ph":"X","cat":"fee","dur":0.34,"name":"builtins.max"},{"pid":131246,"tid":131246,"ts":1234080174437.582,"ph":"X","cat":"fee","dur":0.21,"name":"builtins.min"},{"pid":131246,"tid":131246,"ts":1234080174438.422,"ph":"X","cat":"fee","dur":0.35,"name":"HelpFormatter._Section.__init__ (/home/ma-user/anaconda3/envs/py311/lib/python3.11/argparse.py:206)"},{"pid":131246,"tid":131246,"ts":1234080174439.632,"ph":"X","cat":"fee","dur":0.08,"name":"builtins.isinstance"},{"pid":131246,"tid":131246,"ts":1234080174440.242,"ph":"X","cat":"fee","dur":0.13,"name":"Enum.value (/home/ma-user/anaconda3/envs/py311/lib/python3.11/enum.py:1226)"},{"pid":131246,"tid":131246,"ts":1234080174439.992,"ph":"X","cat":"fee","dur":0.5,"name":"property.__get__ (/home/ma-user/anaconda3/envs/py311/lib/python3.11/enum.py:188)"},{"pid":131246,"tid":131246,"ts":1234080174439.472,"ph":"X","cat":"fee","dur":1.47,"name":"_compile (/home/ma-user/anaconda3/envs/py311/lib/python3.11/re/__init__.py:272)"},{"pid":131246,"tid":131246,"ts":1234080174439.292,"ph":"X","cat":"fee","dur":1.78,"name":"compile (/home/ma-user/anaconda3/envs/py311/lib/python3.11/re/__init__.py:225)"},{"pid":131246,"tid":131246,"ts":1234080174441.732,"ph":"X","cat":"fee","dur":0.26,"name":"builtins.isinstance"},{"pid":131246,"tid":131246,"ts":1234080174441.602,"ph":"X","cat":"fee","dur":0.74,"name":"_compile (/home/ma-user/anaconda3/envs/py311/lib/python3.11/re/__init__.py:272)"},{"pid":131246,"tid":131246,"ts":1234080174441.402,"ph":"X","cat":"fee","dur":1.05,"name":"compile (/home/ma-user/anaconda3/envs/py311/lib/python3.11/re/__init__.py:225)"},{"pid":131246,"tid":131246,"ts":1234080174429.172,"ph":"X","cat":"fee","dur":14.54,"name":"HelpFormatter.__init__ (/home/ma-user/anaconda3/envs/py311/lib/python3.11/argparse.py:164)"},{"pid":131246,"tid":131246,"ts":1234080174428.432,"ph":"X","cat":"fee","dur":15.6,"name":"ArgumentParser._get_formatter (/home/ma-user/anaconda3/envs/py311/lib/python3.11/argparse.py:2576)"},{"pid":131246,"tid":131246,"ts":1234080174444.602,"ph":"X","cat":"fee","dur":0.41,"name":"HelpFormatter._metavar_formatter (/home/ma-user/anaconda3/envs/py311/lib/python3.11/argparse.py:578)"},{"pid":131246,"tid":131246,"ts":1234080174445.612,"ph":"X","cat":"fee","dur":0.11,"name":"builtins.isinstance"},{"pid":131246,"tid":131246,"ts":1234080174445.422,"ph":"X","cat":"fee","dur":0.55,"name":"HelpFormatter._metavar_formatter.<locals>.format (/home/ma-user/anaconda3/envs/py311/lib/python3.11/argparse.py:587)"},{"pid":131246,"tid":131246,"ts":1234080174444.302,"ph":"X","cat":"fee","dur":2.18,"name":"HelpFormatter._format_args (/home/ma-user/anaconda3/envs/py311/lib/python3.11/argparse.py:594)"},{"pid":131246,"tid":131246,"ts":1234080174447.912,"ph":"X","cat":"fee","dur":0.42,"name":"_ActionsContainer._check_conflict (/home/ma-user/anaconda3/envs/py311/lib/python3.11/argparse.py:1600)"},{"pid":131246,"tid":131246,"ts":1234080174448.612,"ph":"X","cat":"fee","dur":0.08,"name":"list.append"},{"pid":131246,"tid":131246,"ts":1234080174449.302,"ph":"X","cat":"fee","dur":0.47,"name":"re.Pattern.match"},{"pid":131246,"tid":131246,"ts":1234080174447.722,"ph":"X","cat":"fee","dur":2.22,"name":"_ActionsContainer._add_action (/home/ma-user/anaconda3/envs/py311/lib/python3.11/argparse.py:1473)"},{"pid":131246,"tid":131246,"ts":1234080174450.172,"ph":"X","cat":"fee","dur":0.06,"name":"list.append"},{"pid":131246,"tid":131246,"ts":1234080174447.252,"ph":"X","cat":"fee","dur":3.09,"name":"_ArgumentGroup._add_action (/home/ma-user/anaconda3/envs/py311/lib/python3.11/argparse.py:1662)"},{"pid":131246,"tid":131246,"ts":1234080174446.932,"ph":"X","cat":"fee","dur":3.52,"name":"ArgumentParser._add_action (/home/ma-user/anaconda3/envs/py311/lib/python3.11/argparse.py:1841)"},{"pid":131246,"tid":131246,"ts":1234080174417.682,"ph":"X","cat":"fee","dur":32.89,"name":"_ActionsContainer.add_argument (/home/ma-user/anaconda3/envs/py311/lib/python3.11/argparse.py:1412)"},{"pid":131246,"tid":131246,"ts":1234080174451.542,"ph":"X","cat":"fee","dur":0.11,"name":"builtins.len"},{"pid":131246,"tid":131246,"ts":1234080174452.952,"ph":"X","cat":"fee","dur":0.07,"name":"list.append"},{"pid":131246,"tid":131246,"ts":1234080174453.182,"ph":"X","cat":"fee","dur":0.08,"name":"builtins.len"},{"pid":131246,"tid":131246,"ts":1234080174453.502,"ph":"X","cat":"fee","dur":0.06,"name":"list.append"},{"pid":131246,"tid":131246,"ts":1234080174453.762,"ph":"X","cat":"fee","dur":0.09,"name":"dict.pop"},{"pid":131246,"tid":131246,"ts":1234080174454.102,"ph":"X","cat":"fee","dur":0.19,"name":"str.lstrip"},{"pid":131246,"tid":131246,"ts":1234080174454.472,"ph":"X","cat":"fee","dur":0.17,"name":"str.replace"},{"pid":131246,"tid":131246,"ts":1234080174452.582,"ph":"X","cat":"fee","dur":2.44,"name":"_ActionsContainer._get_optional_kwargs (/home/ma-user/anaconda3/envs/py311/lib/python3.11/argparse.py:1553)"},{"pid":131246,"tid":131246,"ts":1234080174455.802,"ph":"X","cat":"fee","dur":0.08,"name":"dict.pop"},{"pid":131246,"tid":131246,"ts":1234080174456.342,"ph":"X","cat":"fee","dur":0.12,"name":"dict.get"},{"pid":131246,"tid":131246,"ts":1234080174456.142,"ph":"X","cat":"fee","dur":0.44,"name":"_ActionsContainer._registry_get (/home/ma-user/anaconda3/envs/py311/lib/python3.11/argparse.py:1387)"},{"pid":131246,"tid":131246,"ts":1234080174455.642,"ph":"X","cat":"fee","dur":1.08,"name":"_ActionsContainer._pop_action_class (/home/ma-user/anaconda3/envs/py311/lib/python3.11/argparse.py:1587)"},{"pid":131246,"tid":131246,"ts":1234080174456.872,"ph":"X","cat":"fee","dur":0.08,"name":"builtins.callable"},{"pid":131246,"tid":131246,"ts":1234080174458.232,"ph":"X","cat":"fee","dur":0.43,"name":"Action.__init__ (/home/ma-user/anaconda3/envs/py311/lib/python3.11/argparse.py:834)"},{"pid":131246,"tid":131246,"ts":1234080174457.572,"ph":"X","cat":"fee","dur":1.22,"name":"_StoreAction.__init__ (/home/ma-user/anaconda3/envs/py311/lib/python3.11/argparse.py:919)"},{"pid":131246,"tid":131246,"ts":1234080174459.382,"ph":"X","cat":"fee","dur":0.08,"name":"dict.get"},{"pid":131246,"tid":131246,"ts":1234080174459.192,"ph":"X","cat":"fee","dur":0.38,"name":"_ActionsContainer._registry_get (/home/ma-user/anaconda3/envs/py311/lib/python3.11/argparse.py:1387)"},{"pid":131246,"tid":131246,"ts":1234080174459.712,"ph":"X","cat":"fee","dur":0.06,"name":"builtins.callable"},{"pid":131246,"tid":131246,"ts":1234080174459.992,"ph":"X","cat":"fee","dur":0.16,"name":"builtins.hasattr"},{"pid":131246,"tid":131246,"ts":1234080174467.272,"ph":"X","cat":"fee","dur":0.18,"name":"_io.TextIOWrapper.fileno"},{"pid":131246,"tid":131246,"ts":1234080174467.552,"ph":"X","cat":"fee","dur":0.62,"name":"posix.get_terminal_size"},{"pid":131246,"tid":131246,"ts":1234080174462.632,"ph":"X","cat":"fee","dur":6.29,"name":"get_terminal_size (/home/ma-user/anaconda3/envs/py311/lib/python3.11/shutil.py:1386)"},{"pid":131246,"tid":131246,"ts":1234080174469.552,"ph":"X","cat":"fee","dur":0.32,"name":"builtins.max"},{"pid":131246,"tid":131246,"ts":1234080174469.962,"ph":"X","cat":"fee","dur":0.21,"name":"builtins.min"},{"pid":131246,"tid":131246,"ts":1234080174470.832,"ph":"X","cat":"fee","dur":0.34,"name":"HelpFormatter._Section.__init__ (/home/ma-user/anaconda3/envs/py311/lib/python3.11/argparse.py:206)"},{"pid":131246,"tid":131246,"ts":1234080174472.032,"ph":"X","cat":"fee","dur":0.08,"name":"builtins.isinstance"},{"pid":131246,"tid":131246,"ts":1234080174472.632,"ph":"X","cat":"fee","dur":0.12,"name":"Enum.value (/home/ma-user/anaconda3/envs/py311/lib/python3.11/enum.py:1226)"},{"pid":131246,"tid":131246,"ts":1234080174472.392,"ph":"X","cat":"fee","dur":0.5,"name":"property.__get__ (/home/ma-user/anaconda3/envs/py311/lib/python3.11/enum.py:188)"},{"pid":131246,"tid":131246,"ts":1234080174471.882,"ph":"X","cat":"fee","dur":1.42,"name":"_compile (/home/ma-user/anaconda3/envs/py311/lib/python3.11/re/__init__.py:272)"},{"pid":131246,"tid":131246,"ts":1234080174471.682,"ph":"X","cat":"fee","dur":1.73,"name":"compile (/home/ma-user/anaconda3/envs/py311/lib/python3.11/re/__init__.py:225)"},{"pid":131246,"tid":131246,"ts":1234080174474.072,"ph":"X","cat":"fee","dur":0.27,"name":"builtins.isinstance"},{"pid":131246,"tid":131246,"ts":1234080174473.932,"ph":"X","cat":"fee","dur":0.71,"name":"_compile (/home/ma-user/anaconda3/envs/py311/lib/python3.11/re/__init__.py:272)"},{"pid":131246,"tid":131246,"ts":1234080174473.752,"ph":"X","cat":"fee","dur":0.99,"name":"compile (/home/ma-user/anaconda3/envs/py311/lib/python3.11/re/__init__.py:225)"},{"pid":131246,"tid":131246,"ts":1234080174462.052,"ph":"X","cat":"fee","dur":13.85,"name":"HelpFormatter.__init__ (/home/ma-user/anaconda3/envs/py311/lib/python3.11/argparse.py:164)"},{"pid":131246,"tid":131246,"ts":1234080174460.372,"ph":"X","cat":"fee","dur":15.83,"name":"ArgumentParser._get_formatter (/home/ma-user/anaconda3/envs/py311/lib/python3.11/argparse.py:2576)"},{"pid":131246,"tid":131246,"ts":1234080174476.742,"ph":"X","cat":"fee","dur":0.36,"name":"HelpFormatter._metavar_formatter (/home/ma-user/anaconda3/envs/py311/lib/python3.11/argparse.py:578)"},{"pid":131246,"tid":131246,"ts":1234080174477.642,"ph":"X","cat":"fee","dur":0.13,"name":"builtins.isinstance"},{"pid":131246,"tid":131246,"ts":1234080174477.472,"ph":"X","cat":"fee","dur":0.49,"name":"HelpFormatter._metavar_formatter.<locals>.format (/home/ma-user/anaconda3/envs/py311/lib/python3.11/argparse.py:587)"},{"pid":131246,"tid":131246,"ts":1234080174476.472,"ph":"X","cat":"fee","dur":1.97,"name":"HelpFormatter._format_args (/home/ma-user/anaconda3/envs/py311/lib/python3.11/argparse.py:594)"},{"pid":131246,"tid":131246,"ts":1234080174479.802,"ph":"X","cat":"fee","dur":0.42,"name":"_ActionsContainer._check_conflict (/home/ma-user/anaconda3/envs/py311/lib/python3.11/argparse.py:1600)"},{"pid":131246,"tid":131246,"ts":1234080174480.512,"ph":"X","cat":"fee","dur":0.07,"name":"list.append"},{"pid":131246,"tid":131246,"ts":1234080174481.242,"ph":"X","cat":"fee","dur":0.45,"name":"re.Pattern.match"},{"pid":131246,"tid":131246,"ts":1234080174479.612,"ph":"X","cat":"fee","dur":2.24,"name":"_ActionsContainer._add_action (/home/ma-user/anaconda3/envs/py311/lib/python3.11/argparse.py:1473)"},{"pid":131246,"tid":131246,"ts":1234080174482.072,"ph":"X","cat":"fee","dur":0.07,"name":"list.append"},{"pid":131246,"tid":131246,"ts":1234080174479.162,"ph":"X","cat":"fee","dur":3.08,"name":"_ArgumentGroup._add_action (/home/ma-user/anaconda3/envs/py311/lib/python3.11/argparse.py:1662)"},{"pid":131246,"tid":131246,"ts":1234080174478.862,"ph":"X","cat":"fee","dur":3.52,"name":"ArgumentParser._add_action (/home/ma-user/anaconda3/envs/py311/lib/python3.11/argparse.py:1841)"},{"pid":131246,"tid":131246,"ts":1234080174451.342,"ph":"X","cat":"fee","dur":31.15,"name":"_ActionsContainer.add_argument (/home/ma-user/anaconda3/envs/py311/lib/python3.11/argparse.py:1412)"},{"pid":131246,"tid":131246,"ts":1234080174483.542,"ph":"X","cat":"fee","dur":0.11,"name":"builtins.len"},{"pid":131246,"tid":131246,"ts":1234080174484.992,"ph":"X","cat":"fee","dur":0.05,"name":"list.append"},{"pid":131246,"tid":131246,"ts":1234080174485.222,"ph":"X","cat":"fee","dur":0.08,"name":"builtins.len"},{"pid":131246,"tid":131246,"ts":1234080174485.562,"ph":"X","cat":"fee","dur":0.06,"name":"list.append"},{"pid":131246,"tid":131246,"ts":1234080174485.832,"ph":"X","cat":"fee","dur":0.11,"name":"dict.pop"},{"pid":131246,"tid":131246,"ts":1234080174486.222,"ph":"X","cat":"fee","dur":0.18,"name":"str.lstrip"},{"pid":131246,"tid":131246,"ts":1234080174486.602,"ph":"X","cat":"fee","dur":0.17,"name":"str.replace"},{"pid":131246,"tid":131246,"ts":1234080174484.552,"ph":"X","cat":"fee","dur":2.65,"name":"_ActionsContainer._get_optional_kwargs (/home/ma-user/anaconda3/envs/py311/lib/python3.11/argparse.py:1553)"},{"pid":131246,"tid":131246,"ts":1234080174488.272,"ph":"X","cat":"fee","dur":0.07,"name":"dict.pop"},{"pid":131246,"tid":131246,"ts":1234080174488.782,"ph":"X","cat":"fee","dur":0.1,"name":"dict.get"},{"pid":131246,"tid":131246,"ts":1234080174488.592,"ph":"X","cat":"fee","dur":0.4,"name":"_ActionsContainer._registry_get (/home/ma-user/anaconda3/envs/py311/lib/python3.11/argparse.py:1387)"},{"pid":131246,"tid":131246,"ts":1234080174488.122,"ph":"X","cat":"fee","dur":1.0,"name":"_ActionsContainer._pop_action_class (/home/ma-user/anaconda3/envs/py311/lib/python3.11/argparse.py:1587)"},{"pid":131246,"tid":131246,"ts":1234080174489.282,"ph":"X","cat":"fee","dur":0.07,"name":"builtins.callable"},{"pid":131246,"tid":131246,"ts":1234080174490.732,"ph":"X","cat":"fee","dur":0.41,"name":"Action.__init__ (/home/ma-user/anaconda3/envs/py311/lib/python3.11/argparse.py:834)"},{"pid":131246,"tid":131246,"ts":1234080174490.092,"ph":"X","cat":"fee","dur":1.18,"name":"_StoreAction.__init__ (/home/ma-user/anaconda3/envs/py311/lib/python3.11/argparse.py:919)"},{"pid":131246,"tid":131246,"ts":1234080174491.852,"ph":"X","cat":"fee","dur":0.09,"name":"dict.get"},{"pid":131246,"tid":131246,"ts":1234080174491.672,"ph":"X","cat":"fee","dur":0.37,"name":"_ActionsContainer._registry_get (/home/ma-user/anaconda3/envs/py311/lib/python3.11/argparse.py:1387)"},{"pid":131246,"tid":131246,"ts":1234080174492.192,"ph":"X","cat":"fee","dur":0.05,"name":"builtins.callable"},{"pid":131246,"tid":131246,"ts":1234080174492.472,"ph":"X","cat":"fee","dur":0.17,"name":"builtins.hasattr"},{"pid":131246,"tid":131246,"ts":1234080174498.682,"ph":"X","cat":"fee","dur":0.17,"name":"_io.TextIOWrapper.fileno"},{"pid":131246,"tid":131246,"ts":1234080174498.962,"ph":"X","cat":"fee","dur":0.59,"name":"posix.get_terminal_size"},{"pid":131246,"tid":131246,"ts":1234080174493.922,"ph":"X","cat":"fee","dur":6.38,"name":"get_terminal_size (/home/ma-user/anaconda3/envs/py311/lib/python3.11/shutil.py:1386)"},{"pid":131246,"tid":131246,"ts":1234080174500.892,"ph":"X","cat":"fee","dur":0.33,"name":"builtins.max"},{"pid":131246,"tid":131246,"ts":1234080174501.302,"ph":"X","cat":"fee","dur":0.21,"name":"builtins.min"},{"pid":131246,"tid":131246,"ts":1234080174502.203,"ph":"X","cat":"fee","dur":0.33,"name":"HelpFormatter._Section.__init__ (/home/ma-user/anaconda3/envs/py311/lib/python3.11/argparse.py:206)"},{"pid":131246,"tid":131246,"ts":1234080174503.373,"ph":"X","cat":"fee","dur":0.09,"name":"builtins.isinstance"},{"pid":131246,"tid":131246,"ts":1234080174503.993,"ph":"X","cat":"fee","dur":0.12,"name":"Enum.value (/home/ma-user/anaconda3/envs/py311/lib/python3.11/enum.py:1226)"},{"pid":131246,"tid":131246,"ts":1234080174503.723,"ph":"X","cat":"fee","dur":0.53,"name":"property.__get__ (/home/ma-user/anaconda3/envs/py311/lib/python3.11/enum.py:188)"},{"pid":131246,"tid":131246,"ts":1234080174503.233,"ph":"X","cat":"fee","dur":1.44,"name":"_compile (/home/ma-user/anaconda3/envs/py311/lib/python3.11/re/__init__.py:272)"},{"pid":131246,"tid":131246,"ts":1234080174503.033,"ph":"X","cat":"fee","dur":1.75,"name":"compile (/home/ma-user/anaconda3/envs/py311/lib/python3.11/re/__init__.py:225)"},{"pid":131246,"tid":131246,"ts":1234080174505.453,"ph":"X","cat":"fee","dur":0.2,"name":"builtins.isinstance"},{"pid":131246,"tid":131246,"ts":1234080174505.323,"ph":"X","cat":"fee","dur":0.61,"name":"_compile (/home/ma-user/anaconda3/envs/py311/lib/python3.11/re/__init__.py:272)"},{"pid":131246,"tid":131246,"ts":1234080174505.143,"ph":"X","cat":"fee","dur":1.95,"name":"compile (/home/ma-user/anaconda3/envs/py311/lib/python3.11/re/__init__.py:225)"},{"pid":131246,"tid":131246,"ts":1234080174493.422,"ph":"X","cat":"fee","dur":13.841,"name":"HelpFormatter.__init__ (/home/ma-user/anaconda3/envs/py311/lib/python3.11/argparse.py:164)"},{"pid":131246,"tid":131246,"ts":1234080174492.842,"ph":"X","cat":"fee","dur":14.691,"name":"ArgumentParser._get_formatter (/home/ma-user/anaconda3/envs/py311/lib/python3.11/argparse.py:2576)"},{"pid":131246,"tid":131246,"ts":1234080174508.103,"ph":"X","cat":"fee","dur":0.37,"name":"HelpFormatter._metavar_formatter (/home/ma-user/anaconda3/envs/py311/lib/python3.11/argparse.py:578)"},{"pid":131246,"tid":131246,"ts":1234080174509.003,"ph":"X","cat":"fee","dur":0.11,"name":"builtins.isinstance"},{"pid":131246,"tid":131246,"ts":1234080174508.813,"ph":"X","cat":"fee","dur":0.49,"name":"HelpFormatter._metavar_formatter.<locals>.format (/home/ma-user/anaconda3/envs/py311/lib/python3.11/argparse.py:587)"},{"pid":131246,"tid":131246,"ts":1234080174507.853,"ph":"X","cat":"fee","dur":1.91,"name":"HelpFormatter._format_args (/home/ma-user/anaconda3/envs/py311/lib/python3.11/argparse.py:594)"},{"pid":131246,"tid":131246,"ts":1234080174511.143,"ph":"X","cat":"fee","dur":0.34,"name":"_ActionsContainer._check_conflict (/home/ma-user/anaconda3/envs/py311/lib/python3.11/argparse.py:1600)"},{"pid":131246,"tid":131246,"ts":1234080174511.783,"ph":"X","cat":"fee","dur":0.12,"name":"list.append"},{"pid":131246,"tid":131246,"ts":1234080174512.693,"ph":"X","cat":"fee","dur":0.47,"name":"re.Pattern.match"},{"pid":131246,"tid":131246,"ts":1234080174510.953,"ph":"X","cat":"fee","dur":2.37,"name":"_ActionsContainer._add_action (/home/ma-user/anaconda3/envs/py311/lib/python3.11/argparse.py:1473)"},{"pid":131246,"tid":131246,"ts":1234080174513.573,"ph":"X","cat":"fee","dur":0.09,"name":"list.append"},{"pid":131246,"tid":131246,"ts":1234080174510.503,"ph":"X","cat":"fee","dur":3.27,"name":"_ArgumentGroup._add_action (/home/ma-user/anaconda3/envs/py311/lib/python3.11/argparse.py:1662)"},{"pid":131246,"tid":131246,"ts":1234080174510.153,"ph":"X","cat":"fee","dur":3.76,"name":"ArgumentParser._add_action (/home/ma-user/anaconda3/envs/py311/lib/python3.11/argparse.py:1841)"},{"pid":131246,"tid":131246,"ts":1234080174483.342,"ph":"X","cat":"fee","dur":30.691,"name":"_ActionsContainer.add_argument (/home/ma-user/anaconda3/envs/py311/lib/python3.11/argparse.py:1412)"},{"pid":131246,"tid":131246,"ts":1234080174514.993,"ph":"X","cat":"fee","dur":0.12,"name":"builtins.len"},{"pid":131246,"tid":131246,"ts":1234080174516.283,"ph":"X","cat":"fee","dur":0.07,"name":"list.append"},{"pid":131246,"tid":131246,"ts":1234080174516.513,"ph":"X","cat":"fee","dur":0.09,"name":"builtins.len"},{"pid":131246,"tid":131246,"ts":1234080174516.883,"ph":"X","cat":"fee","dur":0.05,"name":"list.append"},{"pid":131246,"tid":131246,"ts":1234080174517.153,"ph":"X","cat":"fee","dur":0.1,"name":"dict.pop"},{"pid":131246,"tid":131246,"ts":1234080174517.513,"ph":"X","cat":"fee","dur":0.19,"name":"str.lstrip"},{"pid":131246,"tid":131246,"ts":1234080174517.883,"ph":"X","cat":"fee","dur":0.23,"name":"str.replace"},{"pid":131246,"tid":131246,"ts":1234080174515.903,"ph":"X","cat":"fee","dur":2.57,"name":"_ActionsContainer._get_optional_kwargs (/home/ma-user/anaconda3/envs/py311/lib/python3.11/argparse.py:1553)"},{"pid":131246,"tid":131246,"ts":1234080174519.183,"ph":"X","cat":"fee","dur":0.07,"name":"dict.pop"},{"pid":131246,"tid":131246,"ts":1234080174519.733,"ph":"X","cat":"fee","dur":0.1,"name":"dict.get"},{"pid":131246,"tid":131246,"ts":1234080174519.523,"ph":"X","cat":"fee","dur":0.43,"name":"_ActionsContainer._registry_get (/home/ma-user/anaconda3/envs/py311/lib/python3.11/argparse.py:1387)"},{"pid":131246,"tid":131246,"ts":1234080174519.033,"ph":"X","cat":"fee","dur":1.07,"name":"_ActionsContainer._pop_action_class (/home/ma-user/anaconda3/envs/py311/lib/python3.11/argparse.py:1587)"},{"pid":131246,"tid":131246,"ts":1234080174520.243,"ph":"X","cat":"fee","dur":0.07,"name":"builtins.callable"},{"pid":131246,"tid":131246,"ts":1234080174521.563,"ph":"X","cat":"fee","dur":0.46,"name":"Action.__init__ (/home/ma-user/anaconda3/envs/py311/lib/python3.11/argparse.py:834)"},{"pid":131246,"tid":131246,"ts":1234080174520.933,"ph":"X","cat":"fee","dur":1.22,"name":"_StoreAction.__init__ (/home/ma-user/anaconda3/envs/py311/lib/python3.11/argparse.py:919)"},{"pid":131246,"tid":131246,"ts":1234080174522.753,"ph":"X","cat":"fee","dur":0.09,"name":"dict.get"},{"pid":131246,"tid":131246,"ts":1234080174522.563,"ph":"X","cat":"fee","dur":0.4,"name":"_ActionsContainer._registry_get (/home/ma-user/anaconda3/envs/py311/lib/python3.11/argparse.py:1387)"},{"pid":131246,"tid":131246,"ts":1234080174523.113,"ph":"X","cat":"fee","dur":0.05,"name":"builtins.callable"},{"pid":131246,"tid":131246,"ts":1234080174523.373,"ph":"X","cat":"fee","dur":0.17,"name":"builtins.hasattr"},{"pid":131246,"tid":131246,"ts":1234080174529.313,"ph":"X","cat":"fee","dur":0.16,"name":"_io.TextIOWrapper.fileno"},{"pid":131246,"tid":131246,"ts":1234080174529.573,"ph":"X","cat":"fee","dur":0.61,"name":"posix.get_terminal_size"},{"pid":131246,"tid":131246,"ts":1234080174524.793,"ph":"X","cat":"fee","dur":6.02,"name":"get_terminal_size (/home/ma-user/anaconda3/envs/py311/lib/python3.11/shutil.py:1386)"},{"pid":131246,"tid":131246,"ts":1234080174531.423,"ph":"X","cat":"fee","dur":0.31,"name":"builtins.max"},{"pid":131246,"tid":131246,"ts":1234080174531.803,"ph":"X","cat":"fee","dur":0.2,"name":"builtins.min"},{"pid":131246,"tid":131246,"ts":1234080174532.663,"ph":"X","cat":"fee","dur":0.34,"name":"HelpFormatter._Section.__init__ (/home/ma-user/anaconda3/envs/py311/lib/python3.11/argparse.py:206)"},{"pid":131246,"tid":131246,"ts":1234080174533.803,"ph":"X","cat":"fee","dur":0.09,"name":"builtins.isinstance"},{"pid":131246,"tid":131246,"ts":1234080174534.363,"ph":"X","cat":"fee","dur":0.13,"name":"Enum.value (/home/ma-user/anaconda3/envs/py311/lib/python3.11/enum.py:1226)"},{"pid":131246,"tid":131246,"ts":1234080174534.123,"ph":"X","cat":"fee","dur":0.5,"name":"property.__get__ (/home/ma-user/anaconda3/envs/py311/lib/python3.11/enum.py:188)"},{"pid":131246,"tid":131246,"ts":1234080174533.663,"ph":"X","cat":"fee","dur":1.38,"name":"_compile (/home/ma-user/anaconda3/envs/py311/lib/python3.11/re/__init__.py:272)"},{"pid":131246,"tid":131246,"ts":1234080174533.493,"ph":"X","cat":"fee","dur":1.66,"name":"compile (/home/ma-user/anaconda3/envs/py311/lib/python3.11/re/__init__.py:225)"},{"pid":131246,"tid":131246,"ts":1234080174535.783,"ph":"X","cat":"fee","dur":0.24,"name":"builtins.isinstance"},{"pid":131246,"tid":131246,"ts":1234080174535.653,"ph":"X","cat":"fee","dur":0.64,"name":"_compile (/home/ma-user/anaconda3/envs/py311/lib/python3.11/re/__init__.py:272)"},{"pid":131246,"tid":131246,"ts":1234080174535.473,"ph":"X","cat":"fee","dur":3.46,"name":"compile (/home/ma-user/anaconda3/envs/py311/lib/python3.11/re/__init__.py:225)"},{"pid":131246,"tid":131246,"ts":1234080174524.293,"ph":"X","cat":"fee","dur":14.81,"name":"HelpFormatter.__init__ (/home/ma-user/anaconda3/envs/py311/lib/python3.11/argparse.py:164)"},{"pid":131246,"tid":131246,"ts":1234080174523.743,"ph":"X","cat":"fee","dur":15.64,"name":"ArgumentParser._get_formatter (/home/ma-user/anaconda3/envs/py311/lib/python3.11/argparse.py:2576)"},{"pid":131246,"tid":131246,"ts":1234080174539.913,"ph":"X","cat":"fee","dur":0.33,"name":"HelpFormatter._metavar_formatter (/home/ma-user/anaconda3/envs/py311/lib/python3.11/argparse.py:578)"},{"pid":131246,"tid":131246,"ts":1234080174540.783,"ph":"X","cat":"fee","dur":0.13,"name":"builtins.isinstance"},{"pid":131246,"tid":131246,"ts":1234080174540.613,"ph":"X","cat":"fee","dur":0.5,"name":"HelpFormatter._metavar_formatter.<locals>.format (/home/ma-user/anaconda3/envs/py311/lib/python3.11/argparse.py:587)"},{"pid":131246,"tid":131246,"ts":1234080174539.663,"ph":"X","cat":"fee","dur":1.91,"name":"HelpFormatter._format_args (/home/ma-user/anaconda3/envs/py311/lib/python3.11/argparse.py:594)"},{"pid":131246,"tid":131246,"ts":1234080174542.923,"ph":"X","cat":"fee","dur":0.39,"name":"_ActionsContainer._check_conflict (/home/ma-user/anaconda3/envs/py311/lib/python3.11/argparse.py:1600)"},{"pid":131246,"tid":131246,"ts":1234080174543.623,"ph":"X","cat":"fee","dur":0.08,"name":"list.append"},{"pid":131246,"tid":131246,"ts":1234080174544.333,"ph":"X","cat":"fee","dur":0.37,"name":"re.Pattern.match"},{"pid":131246,"tid":131246,"ts":1234080174542.723,"ph":"X","cat":"fee","dur":2.13,"name":"_ActionsContainer._add_action (/home/ma-user/anaconda3/envs/py311/lib/python3.11/argparse.py:1473)"},{"pid":131246,"tid":131246,"ts":1234080174545.083,"ph":"X","cat":"fee","dur":0.06,"name":"list.append"},{"pid":131246,"tid":131246,"ts":1234080174542.253,"ph":"X","cat":"fee","dur":3.0,"name":"_ArgumentGroup._add_action (/home/ma-user/anaconda3/envs/py311/lib/python3.11/argparse.py:1662)"},{"pid":131246,"tid":131246,"ts":1234080174541.933,"ph":"X","cat":"fee","dur":3.45,"name":"ArgumentParser._add_action (/home/ma-user/anaconda3/envs/py311/lib/python3.11/argparse.py:1841)"},{"pid":131246,"tid":131246,"ts":1234080174514.793,"ph":"X","cat":"fee","dur":30.71,"name":"_ActionsContainer.add_argument (/home/ma-user/anaconda3/envs/py311/lib/python3.11/argparse.py:1412)"},{"pid":131246,"tid":131246,"ts":1234080174546.483,"ph":"X","cat":"fee","dur":0.12,"name":"builtins.len"},{"pid":131246,"tid":131246,"ts":1234080174548.843,"ph":"X","cat":"fee","dur":0.07,"name":"list.append"},{"pid":131246,"tid":131246,"ts":1234080174549.083,"ph":"X","cat":"fee","dur":0.1,"name":"builtins.len"},{"pid":131246,"tid":131246,"ts":1234080174549.443,"ph":"X","cat":"fee","dur":0.06,"name":"list.append"},{"pid":131246,"tid":131246,"ts":1234080174549.703,"ph":"X","cat":"fee","dur":0.1,"name":"dict.pop"},{"pid":131246,"tid":131246,"ts":1234080174550.073,"ph":"X","cat":"fee","dur":0.19,"name":"str.lstrip"},{"pid":131246,"tid":131246,"ts":1234080174550.443,"ph":"X","cat":"fee","dur":0.17,"name":"str.replace"},{"pid":131246,"tid":131246,"ts":1234080174548.413,"ph":"X","cat":"fee","dur":2.57,"name":"_ActionsContainer._get_optional_kwargs (/home/ma-user/anaconda3/envs/py311/lib/python3.11/argparse.py:1553)"},{"pid":131246,"tid":131246,"ts":1234080174552.033,"ph":"X","cat":"fee","dur":0.09,"name":"dict.pop"},{"pid":131246,"tid":131246,"ts":1234080174552.583,"ph":"X","cat":"fee","dur":0.09,"name":"dict.get"},{"pid":131246,"tid":131246,"ts":1234080174552.383,"ph":"X","cat":"fee","dur":0.41,"name":"_ActionsContainer._registry_get (/home/ma-user/anaconda3/envs/py311/lib/python3.11/argparse.py:1387)"},{"pid":131246,"tid":131246,"ts":1234080174551.873,"ph":"X","cat":"fee","dur":1.06,"name":"_ActionsContainer._pop_action_class (/home/ma-user/anaconda3/envs/py311/lib/python3.11/argparse.py:1587)"},{"pid":131246,"tid":131246,"ts":1234080174553.073,"ph":"X","cat":"fee","dur":0.08,"name":"builtins.callable"},{"pid":131246,"tid":131246,"ts":1234080174554.373,"ph":"X","cat":"fee","dur":0.46,"name":"Action.__init__ (/home/ma-user/anaconda3/envs/py311/lib/python3.11/argparse.py:834)"},{"pid":131246,"tid":131246,"ts":1234080174553.733,"ph":"X","cat":"fee","dur":1.23,"name":"_StoreAction.__init__ (/home/ma-user/anaconda3/envs/py311/lib/python3.11/argparse.py:919)"},{"pid":131246,"tid":131246,"ts":1234080174555.583,"ph":"X","cat":"fee","dur":0.08,"name":"dict.get"},{"pid":131246,"tid":131246,"ts":1234080174555.353,"ph":"X","cat":"fee","dur":0.41,"name":"_ActionsContainer._registry_get (/home/ma-user/anaconda3/envs/py311/lib/python3.11/argparse.py:1387)"},{"pid":131246,"tid":131246,"ts":1234080174555.913,"ph":"X","cat":"fee","dur":0.06,"name":"builtins.callable"},{"pid":131246,"tid":131246,"ts":1234080174556.203,"ph":"X","cat":"fee","dur":0.18,"name":"builtins.hasattr"},{"pid":131246,"tid":131246,"ts":1234080174562.303,"ph":"X","cat":"fee","dur":0.19,"name":"_io.TextIOWrapper.fileno"},{"pid":131246,"tid":131246,"ts":1234080174562.593,"ph":"X","cat":"fee","dur":0.59,"name":"posix.get_terminal_size"},{"pid":131246,"tid":131246,"ts":1234080174557.693,"ph":"X","cat":"fee","dur":6.16,"name":"get_terminal_size (/home/ma-user/anaconda3/envs/py311/lib/python3.11/shutil.py:1386)"},{"pid":131246,"tid":131246,"ts":1234080174564.463,"ph":"X","cat":"fee","dur":0.32,"name":"builtins.max"},{"pid":131246,"tid":131246,"ts":1234080174564.863,"ph":"X","cat":"fee","dur":0.22,"name":"builtins.min"},{"pid":131246,"tid":131246,"ts":1234080174565.683,"ph":"X","cat":"fee","dur":0.32,"name":"HelpFormatter._Section.__init__ (/home/ma-user/anaconda3/envs/py311/lib/python3.11/argparse.py:206)"},{"pid":131246,"tid":131246,"ts":1234080174566.813,"ph":"X","cat":"fee","dur":0.08,"name":"builtins.isinstance"},{"pid":131246,"tid":131246,"ts":1234080174567.413,"ph":"X","cat":"fee","dur":0.12,"name":"Enum.value (/home/ma-user/anaconda3/envs/py311/lib/python3.11/enum.py:1226)"},{"pid":131246,"tid":131246,"ts":1234080174567.163,"ph":"X","cat":"fee","dur":0.51,"name":"property.__get__ (/home/ma-user/anaconda3/envs/py311/lib/python3.11/enum.py:188)"},{"pid":131246,"tid":131246,"ts":1234080174566.663,"ph":"X","cat":"fee","dur":1.42,"name":"_compile (/home/ma-user/anaconda3/envs/py311/lib/python3.11/re/__init__.py:272)"},{"pid":131246,"tid":131246,"ts":1234080174566.483,"ph":"X","cat":"fee","dur":1.7,"name":"compile (/home/ma-user/anaconda3/envs/py311/lib/python3.11/re/__init__.py:225)"},{"pid":131246,"tid":131246,"ts":1234080174568.823,"ph":"X","cat":"fee","dur":0.21,"name":"builtins.isinstance"},{"pid":131246,"tid":131246,"ts":1234080174568.683,"ph":"X","cat":"fee","dur":1.65,"name":"_compile (/home/ma-user/anaconda3/envs/py311/lib/python3.11/re/__init__.py:272)"},{"pid":131246,"tid":131246,"ts":1234080174568.513,"ph":"X","cat":"fee","dur":1.94,"name":"compile (/home/ma-user/anaconda3/envs/py311/lib/python3.11/re/__init__.py:225)"},{"pid":131246,"tid":131246,"ts":1234080174557.173,"ph":"X","cat":"fee","dur":13.45,"name":"HelpFormatter.__init__ (/home/ma-user/anaconda3/envs/py311/lib/python3.11/argparse.py:164)"},{"pid":131246,"tid":131246,"ts":1234080174556.583,"ph":"X","cat":"fee","dur":14.29,"name":"ArgumentParser._get_formatter (/home/ma-user/anaconda3/envs/py311/lib/python3.11/argparse.py:2576)"},{"pid":131246,"tid":131246,"ts":1234080174571.383,"ph":"X","cat":"fee","dur":0.31,"name":"HelpFormatter._metavar_formatter (/home/ma-user/anaconda3/envs/py311/lib/python3.11/argparse.py:578)"},{"pid":131246,"tid":131246,"ts":1234080174572.243,"ph":"X","cat":"fee","dur":0.12,"name":"builtins.isinstance"},{"pid":131246,"tid":131246,"ts":1234080174572.063,"ph":"X","cat":"fee","dur":0.49,"name":"HelpFormatter._metavar_formatter.<locals>.format (/home/ma-user/anaconda3/envs/py311/lib/python3.11/argparse.py:587)"},{"pid":131246,"tid":131246,"ts":1234080174571.143,"ph":"X","cat":"fee","dur":1.87,"name":"HelpFormatter._format_args (/home/ma-user/anaconda3/envs/py311/lib/python3.11/argparse.py:594)"},{"pid":131246,"tid":131246,"ts":1234080174574.303,"ph":"X","cat":"fee","dur":0.37,"name":"_ActionsContainer._check_conflict (/home/ma-user/anaconda3/envs/py311/lib/python3.11/argparse.py:1600)"},{"pid":131246,"tid":131246,"ts":1234080174574.933,"ph":"X","cat":"fee","dur":0.08,"name":"list.append"},{"pid":131246,"tid":131246,"ts":1234080174575.593,"ph":"X","cat":"fee","dur":0.44,"name":"re.Pattern.match"},{"pid":131246,"tid":131246,"ts":1234080174574.123,"ph":"X","cat":"fee","dur":2.05,"name":"_ActionsContainer._add_action (/home/ma-user/anaconda3/envs/py311/lib/python3.11/argparse.py:1473)"},{"pid":131246,"tid":131246,"ts":1234080174576.413,"ph":"X","cat":"fee","dur":0.06,"name":"list.append"},{"pid":131246,"tid":131246,"ts":1234080174573.673,"ph":"X","cat":"fee","dur":2.9,"name":"_ArgumentGroup._add_action (/home/ma-user/anaconda3/envs/py311/lib/python3.11/argparse.py:1662)"},{"pid":131246,"tid":131246,"ts":1234080174573.373,"ph":"X","cat":"fee","dur":3.33,"name":"ArgumentParser._add_action (/home/ma-user/anaconda3/envs/py311/lib/python3.11/argparse.py:1841)"},{"pid":131246,"tid":131246,"ts":1234080174546.303,"ph":"X","cat":"fee","dur":30.51,"name":"_ActionsContainer.add_argument (/home/ma-user/anaconda3/envs/py311/lib/python3.11/argparse.py:1412)"},{"pid":131246,"tid":131246,"ts":1234080174577.813,"ph":"X","cat":"fee","dur":0.11,"name":"builtins.len"},{"pid":131246,"tid":131246,"ts":1234080174579.093,"ph":"X","cat":"fee","dur":0.07,"name":"list.append"},{"pid":131246,"tid":131246,"ts":1234080174579.313,"ph":"X","cat":"fee","dur":0.08,"name":"builtins.len"},{"pid":131246,"tid":131246,"ts":1234080174579.643,"ph":"X","cat":"fee","dur":0.05,"name":"list.append"},{"pid":131246,"tid":131246,"ts":1234080174579.923,"ph":"X","cat":"fee","dur":0.1,"name":"dict.pop"},{"pid":131246,"tid":131246,"ts":1234080174580.283,"ph":"X","cat":"fee","dur":0.18,"name":"str.lstrip"},{"pid":131246,"tid":131246,"ts":1234080174580.633,"ph":"X","cat":"fee","dur":0.16,"name":"str.replace"},{"pid":131246,"tid":131246,"ts":1234080174578.723,"ph":"X","cat":"fee","dur":2.44,"name":"_ActionsContainer._get_optional_kwargs (/home/ma-user/anaconda3/envs/py311/lib/python3.11/argparse.py:1553)"},{"pid":131246,"tid":131246,"ts":1234080174581.893,"ph":"X","cat":"fee","dur":0.08,"name":"dict.pop"},{"pid":131246,"tid":131246,"ts":1234080174582.463,"ph":"X","cat":"fee","dur":0.11,"name":"dict.get"},{"pid":131246,"tid":131246,"ts":1234080174582.243,"ph":"X","cat":"fee","dur":0.46,"name":"_ActionsContainer._registry_get (/home/ma-user/anaconda3/envs/py311/lib/python3.11/argparse.py:1387)"},{"pid":131246,"tid":131246,"ts":1234080174581.713,"ph":"X","cat":"fee","dur":1.12,"name":"_ActionsContainer._pop_action_class (/home/ma-user/anaconda3/envs/py311/lib/python3.11/argparse.py:1587)"},{"pid":131246,"tid":131246,"ts":1234080174582.983,"ph":"X","cat":"fee","dur":0.08,"name":"builtins.callable"},{"pid":131246,"tid":131246,"ts":1234080174584.283,"ph":"X","cat":"fee","dur":0.45,"name":"Action.__init__ (/home/ma-user/anaconda3/envs/py311/lib/python3.11/argparse.py:834)"},{"pid":131246,"tid":131246,"ts":1234080174583.663,"ph":"X","cat":"fee","dur":1.2,"name":"_StoreAction.__init__ (/home/ma-user/anaconda3/envs/py311/lib/python3.11/argparse.py:919)"},{"pid":131246,"tid":131246,"ts":1234080174585.483,"ph":"X","cat":"fee","dur":0.08,"name":"dict.get"},{"pid":131246,"tid":131246,"ts":1234080174585.283,"ph":"X","cat":"fee","dur":0.39,"name":"_ActionsContainer._registry_get (/home/ma-user/anaconda3/envs/py311/lib/python3.11/argparse.py:1387)"},{"pid":131246,"tid":131246,"ts":1234080174585.823,"ph":"X","cat":"fee","dur":0.05,"name":"builtins.callable"},{"pid":131246,"tid":131246,"ts":1234080174586.073,"ph":"X","cat":"fee","dur":0.16,"name":"builtins.hasattr"},{"pid":131246,"tid":131246,"ts":1234080174591.923,"ph":"X","cat":"fee","dur":0.16,"name":"_io.TextIOWrapper.fileno"},{"pid":131246,"tid":131246,"ts":1234080174592.183,"ph":"X","cat":"fee","dur":0.58,"name":"posix.get_terminal_size"},{"pid":131246,"tid":131246,"ts":1234080174587.493,"ph":"X","cat":"fee","dur":5.91,"name":"get_terminal_size (/home/ma-user/anaconda3/envs/py311/lib/python3.11/shutil.py:1386)"},{"pid":131246,"tid":131246,"ts":1234080174594.023,"ph":"X","cat":"fee","dur":0.32,"name":"builtins.max"},{"pid":131246,"tid":131246,"ts":1234080174594.423,"ph":"X","cat":"fee","dur":0.21,"name":"builtins.min"},{"pid":131246,"tid":131246,"ts":1234080174595.223,"ph":"X","cat":"fee","dur":0.32,"name":"HelpFormatter._Section.__init__ (/home/ma-user/anaconda3/envs/py311/lib/python3.11/argparse.py:206)"},{"pid":131246,"tid":131246,"ts":1234080174596.353,"ph":"X","cat":"fee","dur":0.08,"name":"builtins.isinstance"},{"pid":131246,"tid":131246,"ts":1234080174596.933,"ph":"X","cat":"fee","dur":0.13,"name":"Enum.value (/home/ma-user/anaconda3/envs/py311/lib/python3.11/enum.py:1226)"},{"pid":131246,"tid":131246,"ts":1234080174596.683,"ph":"X","cat":"fee","dur":0.52,"name":"property.__get__ (/home/ma-user/anaconda3/envs/py311/lib/python3.11/enum.py:188)"},{"pid":131246,"tid":131246,"ts":1234080174596.203,"ph":"X","cat":"fee","dur":1.43,"name":"_compile (/home/ma-user/anaconda3/envs/py311/lib/python3.11/re/__init__.py:272)"},{"pid":131246,"tid":131246,"ts":1234080174596.013,"ph":"X","cat":"fee","dur":1.72,"name":"compile (/home/ma-user/anaconda3/envs/py311/lib/python3.11/re/__init__.py:225)"},{"pid":131246,"tid":131246,"ts":1234080174598.383,"ph":"X","cat":"fee","dur":0.21,"name":"builtins.isinstance"},{"pid":131246,"tid":131246,"ts":1234080174598.253,"ph":"X","cat":"fee","dur":1.56,"name":"_compile (/home/ma-user/anaconda3/envs/py311/lib/python3.11/re/__init__.py:272)"},{"pid":131246,"tid":131246,"ts":1234080174598.063,"ph":"X","cat":"fee","dur":1.87,"name":"compile (/home/ma-user/anaconda3/envs/py311/lib/python3.11/re/__init__.py:225)"},{"pid":131246,"tid":131246,"ts":1234080174586.973,"ph":"X","cat":"fee","dur":13.13,"name":"HelpFormatter.__init__ (/home/ma-user/anaconda3/envs/py311/lib/python3.11/argparse.py:164)"},{"pid":131246,"tid":131246,"ts":1234080174586.433,"ph":"X","cat":"fee","dur":13.94,"name":"ArgumentParser._get_formatter (/home/ma-user/anaconda3/envs/py311/lib/python3.11/argparse.py:2576)"},{"pid":131246,"tid":131246,"ts":1234080174600.913,"ph":"X","cat":"fee","dur":0.37,"name":"HelpFormatter._metavar_formatter (/home/ma-user/anaconda3/envs/py311/lib/python3.11/argparse.py:578)"},{"pid":131246,"tid":131246,"ts":1234080174601.813,"ph":"X","cat":"fee","dur":0.13,"name":"builtins.isinstance"},{"pid":131246,"tid":131246,"ts":1234080174601.643,"ph":"X","cat":"fee","dur":0.47,"name":"HelpFormatter._metavar_formatter.<locals>.format (/home/ma-user/anaconda3/envs/py311/lib/python3.11/argparse.py:587)"},{"pid":131246,"tid":131246,"ts":1234080174600.673,"ph":"X","cat":"fee","dur":1.86,"name":"HelpFormatter._format_args (/home/ma-user/anaconda3/envs/py311/lib/python3.11/argparse.py:594)"},{"pid":131246,"tid":131246,"ts":1234080174603.873,"ph":"X","cat":"fee","dur":0.39,"name":"_ActionsContainer._check_conflict (/home/ma-user/anaconda3/envs/py311/lib/python3.11/argparse.py:1600)"},{"pid":131246,"tid":131246,"ts":1234080174604.513,"ph":"X","cat":"fee","dur":0.07,"name":"list.append"},{"pid":131246,"tid":131246,"ts":1234080174605.183,"ph":"X","cat":"fee","dur":0.38,"name":"re.Pattern.match"},{"pid":131246,"tid":131246,"ts":1234080174603.683,"ph":"X","cat":"fee","dur":2.04,"name":"_ActionsContainer._add_action (/home/ma-user/anaconda3/envs/py311/lib/python3.11/argparse.py:1473)"},{"pid":131246,"tid":131246,"ts":1234080174605.954,"ph":"X","cat":"fee","dur":0.06,"name":"list.append"},{"pid":131246,"tid":131246,"ts":1234080174603.203,"ph":"X","cat":"fee","dur":2.911,"name":"_ArgumentGroup._add_action (/home/ma-user/anaconda3/envs/py311/lib/python3.11/argparse.py:1662)"},{"pid":131246,"tid":131246,"ts":1234080174602.893,"ph":"X","cat":"fee","dur":3.341,"name":"ArgumentParser._add_action (/home/ma-user/anaconda3/envs/py311/lib/python3.11/argparse.py:1841)"},{"pid":131246,"tid":131246,"ts":1234080174577.643,"ph":"X","cat":"fee","dur":28.711,"name":"_ActionsContainer.add_argument (/home/ma-user/anaconda3/envs/py311/lib/python3.11/argparse.py:1412)"},{"pid":131246,"tid":131246,"ts":1234080174607.374,"ph":"X","cat":"fee","dur":0.1,"name":"builtins.len"},{"pid":131246,"tid":131246,"ts":1234080174608.614,"ph":"X","cat":"fee","dur":0.08,"name":"list.append"},{"pid":131246,"tid":131246,"ts":1234080174608.854,"ph":"X","cat":"fee","dur":0.1,"name":"builtins.len"},{"pid":131246,"tid":131246,"ts":1234080174609.194,"ph":"X","cat":"fee","dur":0.06,"name":"list.append"},{"pid":131246,"tid":131246,"ts":1234080174609.484,"ph":"X","cat":"fee","dur":0.07,"name":"dict.pop"},{"pid":131246,"tid":131246,"ts":1234080174609.814,"ph":"X","cat":"fee","dur":0.17,"name":"str.lstrip"},{"pid":131246,"tid":131246,"ts":1234080174610.154,"ph":"X","cat":"fee","dur":0.17,"name":"str.replace"},{"pid":131246,"tid":131246,"ts":1234080174608.254,"ph":"X","cat":"fee","dur":2.41,"name":"_ActionsContainer._get_optional_kwargs (/home/ma-user/anaconda3/envs/py311/lib/python3.11/argparse.py:1553)"},{"pid":131246,"tid":131246,"ts":1234080174611.404,"ph":"X","cat":"fee","dur":0.07,"name":"dict.pop"},{"pid":131246,"tid":131246,"ts":1234080174611.934,"ph":"X","cat":"fee","dur":0.09,"name":"dict.get"},{"pid":131246,"tid":131246,"ts":1234080174611.734,"ph":"X","cat":"fee","dur":0.41,"name":"_ActionsContainer._registry_get (/home/ma-user/anaconda3/envs/py311/lib/python3.11/argparse.py:1387)"},{"pid":131246,"tid":131246,"ts":1234080174611.234,"ph":"X","cat":"fee","dur":1.03,"name":"_ActionsContainer._pop_action_class (/home/ma-user/anaconda3/envs/py311/lib/python3.11/argparse.py:1587)"},{"pid":131246,"tid":131246,"ts":1234080174612.424,"ph":"X","cat":"fee","dur":0.07,"name":"builtins.callable"},{"pid":131246,"tid":131246,"ts":1234080174613.644,"ph":"X","cat":"fee","dur":0.41,"name":"Action.__init__ (/home/ma-user/anaconda3/envs/py311/lib/python3.11/argparse.py:834)"},{"pid":131246,"tid":131246,"ts":1234080174613.044,"ph":"X","cat":"fee","dur":1.14,"name":"_StoreAction.__init__ (/home/ma-user/anaconda3/envs/py311/lib/python3.11/argparse.py:919)"},{"pid":131246,"tid":131246,"ts":1234080174614.784,"ph":"X","cat":"fee","dur":0.08,"name":"dict.get"},{"pid":131246,"tid":131246,"ts":1234080174614.584,"ph":"X","cat":"fee","dur":0.38,"name":"_ActionsContainer._registry_get (/home/ma-user/anaconda3/envs/py311/lib/python3.11/argparse.py:1387)"},{"pid":131246,"tid":131246,"ts":1234080174615.104,"ph":"X","cat":"fee","dur":0.06,"name":"builtins.callable"},{"pid":131246,"tid":131246,"ts":1234080174615.354,"ph":"X","cat":"fee","dur":0.14,"name":"builtins.hasattr"},{"pid":131246,"tid":131246,"ts":1234080174621.184,"ph":"X","cat":"fee","dur":0.16,"name":"_io.TextIOWrapper.fileno"},{"pid":131246,"tid":131246,"ts":1234080174621.444,"ph":"X","cat":"fee","dur":0.59,"name":"posix.get_terminal_size"},{"pid":131246,"tid":131246,"ts":1234080174616.724,"ph":"X","cat":"fee","dur":5.96,"name":"get_terminal_size (/home/ma-user/anaconda3/envs/py311/lib/python3.11/shutil.py:1386)"},{"pid":131246,"tid":131246,"ts":1234080174623.274,"ph":"X","cat":"fee","dur":0.33,"name":"builtins.max"},{"pid":131246,"tid":131246,"ts":1234080174623.684,"ph":"X","cat":"fee","dur":0.22,"name":"builtins.min"},{"pid":131246,"tid":131246,"ts":1234080174624.564,"ph":"X","cat":"fee","dur":0.31,"name":"HelpFormatter._Section.__init__ (/home/ma-user/anaconda3/envs/py311/lib/python3.11/argparse.py:206)"},{"pid":131246,"tid":131246,"ts":1234080174625.694,"ph":"X","cat":"fee","dur":0.08,"name":"builtins.isinstance"},{"pid":131246,"tid":131246,"ts":1234080174626.264,"ph":"X","cat":"fee","dur":0.13,"name":"Enum.value (/home/ma-user/anaconda3/envs/py311/lib/python3.11/enum.py:1226)"},{"pid":131246,"tid":131246,"ts":1234080174626.024,"ph":"X","cat":"fee","dur":0.51,"name":"property.__get__ (/home/ma-user/anaconda3/envs/py311/lib/python3.11/enum.py:188)"},{"pid":131246,"tid":131246,"ts":1234080174625.554,"ph":"X","cat":"fee","dur":1.38,"name":"_compile (/home/ma-user/anaconda3/envs/py311/lib/python3.11/re/__init__.py:272)"},{"pid":131246,"tid":131246,"ts":1234080174625.354,"ph":"X","cat":"fee","dur":1.69,"name":"compile (/home/ma-user/anaconda3/envs/py311/lib/python3.11/re/__init__.py:225)"},{"pid":131246,"tid":131246,"ts":1234080174627.674,"ph":"X","cat":"fee","dur":0.23,"name":"builtins.isinstance"},{"pid":131246,"tid":131246,"ts":1234080174627.554,"ph":"X","cat":"fee","dur":1.68,"name":"_compile (/home/ma-user/anaconda3/envs/py311/lib/python3.11/re/__init__.py:272)"},{"pid":131246,"tid":131246,"ts":1234080174627.354,"ph":"X","cat":"fee","dur":2.01,"name":"compile (/home/ma-user/anaconda3/envs/py311/lib/python3.11/re/__init__.py:225)"},{"pid":131246,"tid":131246,"ts":1234080174616.284,"ph":"X","cat":"fee","dur":13.24,"name":"HelpFormatter.__init__ (/home/ma-user/anaconda3/envs/py311/lib/python3.11/argparse.py:164)"},{"pid":131246,"tid":131246,"ts":1234080174615.694,"ph":"X","cat":"fee","dur":14.09,"name":"ArgumentParser._get_formatter (/home/ma-user/anaconda3/envs/py311/lib/python3.11/argparse.py:2576)"},{"pid":131246,"tid":131246,"ts":1234080174630.284,"ph":"X","cat":"fee","dur":0.33,"name":"HelpFormatter._metavar_formatter (/home/ma-user/anaconda3/envs/py311/lib/python3.11/argparse.py:578)"},{"pid":131246,"tid":131246,"ts":1234080174631.124,"ph":"X","cat":"fee","dur":0.12,"name":"builtins.isinstance"},{"pid":131246,"tid":131246,"ts":1234080174630.954,"ph":"X","cat":"fee","dur":0.45,"name":"HelpFormatter._metavar_formatter.<locals>.format (/home/ma-user/anaconda3/envs/py311/lib/python3.11/argparse.py:587)"},{"pid":131246,"tid":131246,"ts":1234080174630.064,"ph":"X","cat":"fee","dur":1.79,"name":"HelpFormatter._format_args (/home/ma-user/anaconda3/envs/py311/lib/python3.11/argparse.py:594)"},{"pid":131246,"tid":131246,"ts":1234080174633.174,"ph":"X","cat":"fee","dur":0.34,"name":"_ActionsContainer._check_conflict (/home/ma-user/anaconda3/envs/py311/lib/python3.11/argparse.py:1600)"},{"pid":131246,"tid":131246,"ts":1234080174633.784,"ph":"X","cat":"fee","dur":0.15,"name":"list.append"},{"pid":131246,"tid":131246,"ts":1234080174634.554,"ph":"X","cat":"fee","dur":0.4,"name":"re.Pattern.match"},{"pid":131246,"tid":131246,"ts":1234080174632.984,"ph":"X","cat":"fee","dur":2.14,"name":"_ActionsContainer._add_action (/home/ma-user/anaconda3/envs/py311/lib/python3.11/argparse.py:1473)"},{"pid":131246,"tid":131246,"ts":1234080174635.354,"ph":"X","cat":"fee","dur":0.1,"name":"list.append"},{"pid":131246,"tid":131246,"ts":1234080174632.524,"ph":"X","cat":"fee","dur":3.03,"name":"_ArgumentGroup._add_action (/home/ma-user/anaconda3/envs/py311/lib/python3.11/argparse.py:1662)"},{"pid":131246,"tid":131246,"ts":1234080174632.224,"ph":"X","cat":"fee","dur":3.47,"name":"ArgumentParser._add_action (/home/ma-user/anaconda3/envs/py311/lib/python3.11/argparse.py:1841)"},{"pid":131246,"tid":131246,"ts":1234080174607.184,"ph":"X","cat":"fee","dur":28.62,"name":"_ActionsContainer.add_argument (/home/ma-user/anaconda3/envs/py311/lib/python3.11/argparse.py:1412)"},{"pid":131246,"tid":131246,"ts":1234080174636.694,"ph":"X","cat":"fee","dur":0.12,"name":"builtins.len"},{"pid":131246,"tid":131246,"ts":1234080174637.964,"ph":"X","cat":"fee","dur":0.07,"name":"list.append"},{"pid":131246,"tid":131246,"ts":1234080174638.184,"ph":"X","cat":"fee","dur":0.1,"name":"builtins.len"},{"pid":131246,"tid":131246,"ts":1234080174638.524,"ph":"X","cat":"fee","dur":0.06,"name":"list.append"},{"pid":131246,"tid":131246,"ts":1234080174638.794,"ph":"X","cat":"fee","dur":0.09,"name":"dict.pop"},{"pid":131246,"tid":131246,"ts":1234080174639.134,"ph":"X","cat":"fee","dur":0.18,"name":"str.lstrip"},{"pid":131246,"tid":131246,"ts":1234080174639.474,"ph":"X","cat":"fee","dur":0.17,"name":"str.replace"},{"pid":131246,"tid":131246,"ts":1234080174637.644,"ph":"X","cat":"fee","dur":2.33,"name":"_ActionsContainer._get_optional_kwargs (/home/ma-user/anaconda3/envs/py311/lib/python3.11/argparse.py:1553)"},{"pid":131246,"tid":131246,"ts":1234080174640.694,"ph":"X","cat":"fee","dur":0.07,"name":"dict.pop"},{"pid":131246,"tid":131246,"ts":1234080174641.224,"ph":"X","cat":"fee","dur":0.09,"name":"dict.get"},{"pid":131246,"tid":131246,"ts":1234080174641.014,"ph":"X","cat":"fee","dur":0.42,"name":"_ActionsContainer._registry_get (/home/ma-user/anaconda3/envs/py311/lib/python3.11/argparse.py:1387)"},{"pid":131246,"tid":131246,"ts":1234080174640.524,"ph":"X","cat":"fee","dur":1.04,"name":"_ActionsContainer._pop_action_class (/home/ma-user/anaconda3/envs/py311/lib/python3.11/argparse.py:1587)"},{"pid":131246,"tid":131246,"ts":1234080174641.704,"ph":"X","cat":"fee","dur":0.06,"name":"builtins.callable"},{"pid":131246,"tid":131246,"ts":1234080174642.964,"ph":"X","cat":"fee","dur":0.48,"name":"Action.__init__ (/home/ma-user/anaconda3/envs/py311/lib/python3.11/argparse.py:834)"},{"pid":131246,"tid":131246,"ts":1234080174642.364,"ph":"X","cat":"fee","dur":1.21,"name":"_StoreAction.__init__ (/home/ma-user/anaconda3/envs/py311/lib/python3.11/argparse.py:919)"},{"pid":131246,"tid":131246,"ts":1234080174644.204,"ph":"X","cat":"fee","dur":0.07,"name":"dict.get"},{"pid":131246,"tid":131246,"ts":1234080174644.004,"ph":"X","cat":"fee","dur":0.37,"name":"_ActionsContainer._registry_get (/home/ma-user/anaconda3/envs/py311/lib/python3.11/argparse.py:1387)"},{"pid":131246,"tid":131246,"ts":1234080174644.564,"ph":"X","cat":"fee","dur":0.06,"name":"builtins.callable"},{"pid":131246,"tid":131246,"ts":1234080174644.834,"ph":"X","cat":"fee","dur":0.14,"name":"builtins.hasattr"},{"pid":131246,"tid":131246,"ts":1234080174650.824,"ph":"X","cat":"fee","dur":0.17,"name":"_io.TextIOWrapper.fileno"},{"pid":131246,"tid":131246,"ts":1234080174651.104,"ph":"X","cat":"fee","dur":0.59,"name":"posix.get_terminal_size"},{"pid":131246,"tid":131246,"ts":1234080174646.214,"ph":"X","cat":"fee","dur":6.12,"name":"get_terminal_size (/home/ma-user/anaconda3/envs/py311/lib/python3.11/shutil.py:1386)"},{"pid":131246,"tid":131246,"ts":1234080174652.914,"ph":"X","cat":"fee","dur":0.31,"name":"builtins.max"},{"pid":131246,"tid":131246,"ts":1234080174653.304,"ph":"X","cat":"fee","dur":0.2,"name":"builtins.min"},{"pid":131246,"tid":131246,"ts":1234080174654.124,"ph":"X","cat":"fee","dur":0.31,"name":"HelpFormatter._Section.__init__ (/home/ma-user/anaconda3/envs/py311/lib/python3.11/argparse.py:206)"},{"pid":131246,"tid":131246,"ts":1234080174655.264,"ph":"X","cat":"fee","dur":0.08,"name":"builtins.isinstance"},{"pid":131246,"tid":131246,"ts":1234080174655.894,"ph":"X","cat":"fee","dur":0.13,"name":"Enum.value (/home/ma-user/anaconda3/envs/py311/lib/python3.11/enum.py:1226)"},{"pid":131246,"tid":131246,"ts":1234080174655.644,"ph":"X","cat":"fee","dur":0.53,"name":"property.__get__ (/home/ma-user/anaconda3/envs/py311/lib/python3.11/enum.py:188)"},{"pid":131246,"tid":131246,"ts":1234080174655.134,"ph":"X","cat":"fee","dur":1.45,"name":"_compile (/home/ma-user/anaconda3/envs/py311/lib/python3.11/re/__init__.py:272)"},{"pid":131246,"tid":131246,"ts":1234080174654.934,"ph":"X","cat":"fee","dur":1.75,"name":"compile (/home/ma-user/anaconda3/envs/py311/lib/python3.11/re/__init__.py:225)"},{"pid":131246,"tid":131246,"ts":1234080174658.424,"ph":"X","cat":"fee","dur":0.23,"name":"builtins.isinstance"},{"pid":131246,"tid":131246,"ts":1234080174658.294,"ph":"X","cat":"fee","dur":0.66,"name":"_compile (/home/ma-user/anaconda3/envs/py311/lib/python3.11/re/__init__.py:272)"},{"pid":131246,"tid":131246,"ts":1234080174658.104,"ph":"X","cat":"fee","dur":0.95,"name":"compile (/home/ma-user/anaconda3/envs/py311/lib/python3.11/re/__init__.py:225)"},{"pid":131246,"tid":131246,"ts":1234080174645.744,"ph":"X","cat":"fee","dur":13.48,"name":"HelpFormatter.__init__ (/home/ma-user/anaconda3/envs/py311/lib/python3.11/argparse.py:164)"},{"pid":131246,"tid":131246,"ts":1234080174645.174,"ph":"X","cat":"fee","dur":14.29,"name":"ArgumentParser._get_formatter (/home/ma-user/anaconda3/envs/py311/lib/python3.11/argparse.py:2576)"},{"pid":131246,"tid":131246,"ts":1234080174659.964,"ph":"X","cat":"fee","dur":0.34,"name":"HelpFormatter._metavar_formatter (/home/ma-user/anaconda3/envs/py311/lib/python3.11/argparse.py:578)"},{"pid":131246,"tid":131246,"ts":1234080174660.874,"ph":"X","cat":"fee","dur":0.1,"name":"builtins.isinstance"},{"pid":131246,"tid":131246,"ts":1234080174660.704,"ph":"X","cat":"fee","dur":0.44,"name":"HelpFormatter._metavar_formatter.<locals>.format (/home/ma-user/anaconda3/envs/py311/lib/python3.11/argparse.py:587)"},{"pid":131246,"tid":131246,"ts":1234080174659.724,"ph":"X","cat":"fee","dur":1.85,"name":"HelpFormatter._format_args (/home/ma-user/anaconda3/envs/py311/lib/python3.11/argparse.py:594)"},{"pid":131246,"tid":131246,"ts":1234080174662.934,"ph":"X","cat":"fee","dur":0.41,"name":"_ActionsContainer._check_conflict (/home/ma-user/anaconda3/envs/py311/lib/python3.11/argparse.py:1600)"},{"pid":131246,"tid":131246,"ts":1234080174663.614,"ph":"X","cat":"fee","dur":0.07,"name":"list.append"},{"pid":131246,"tid":131246,"ts":1234080174664.524,"ph":"X","cat":"fee","dur":0.37,"name":"re.Pattern.match"},{"pid":131246,"tid":131246,"ts":1234080174662.724,"ph":"X","cat":"fee","dur":2.33,"name":"_ActionsContainer._add_action (/home/ma-user/anaconda3/envs/py311/lib/python3.11/argparse.py:1473)"},{"pid":131246,"tid":131246,"ts":1234080174665.294,"ph":"X","cat":"fee","dur":0.07,"name":"list.append"},{"pid":131246,"tid":131246,"ts":1234080174662.234,"ph":"X","cat":"fee","dur":3.23,"name":"_ArgumentGroup._add_action (/home/ma-user/anaconda3/envs/py311/lib/python3.11/argparse.py:1662)"},{"pid":131246,"tid":131246,"ts":1234080174661.924,"ph":"X","cat":"fee","dur":3.66,"name":"ArgumentParser._add_action (/home/ma-user/anaconda3/envs/py311/lib/python3.11/argparse.py:1841)"},{"pid":131246,"tid":131246,"ts":1234080174636.504,"ph":"X","cat":"fee","dur":29.21,"name":"_ActionsContainer.add_argument (/home/ma-user/anaconda3/envs/py311/lib/python3.11/argparse.py:1412)"},{"pid":131246,"tid":131246,"ts":1234080174666.634,"ph":"X","cat":"fee","dur":0.12,"name":"builtins.len"},{"pid":131246,"tid":131246,"ts":1234080174667.914,"ph":"X","cat":"fee","dur":0.07,"name":"list.append"},{"pid":131246,"tid":131246,"ts":1234080174668.134,"ph":"X","cat":"fee","dur":0.08,"name":"builtins.len"},{"pid":131246,"tid":131246,"ts":1234080174668.464,"ph":"X","cat":"fee","dur":0.06,"name":"list.append"},{"pid":131246,"tid":131246,"ts":1234080174668.734,"ph":"X","cat":"fee","dur":0.1,"name":"dict.pop"},{"pid":131246,"tid":131246,"ts":1234080174669.094,"ph":"X","cat":"fee","dur":0.18,"name":"str.lstrip"},{"pid":131246,"tid":131246,"ts":1234080174669.444,"ph":"X","cat":"fee","dur":0.12,"name":"str.replace"},{"pid":131246,"tid":131246,"ts":1234080174667.564,"ph":"X","cat":"fee","dur":2.36,"name":"_ActionsContainer._get_optional_kwargs (/home/ma-user/anaconda3/envs/py311/lib/python3.11/argparse.py:1553)"},{"pid":131246,"tid":131246,"ts":1234080174670.604,"ph":"X","cat":"fee","dur":0.08,"name":"dict.pop"},{"pid":131246,"tid":131246,"ts":1234080174671.154,"ph":"X","cat":"fee","dur":0.1,"name":"dict.get"},{"pid":131246,"tid":131246,"ts":1234080174670.934,"ph":"X","cat":"fee","dur":0.44,"name":"_ActionsContainer._registry_get (/home/ma-user/anaconda3/envs/py311/lib/python3.11/argparse.py:1387)"},{"pid":131246,"tid":131246,"ts":1234080174670.444,"ph":"X","cat":"fee","dur":1.07,"name":"_ActionsContainer._pop_action_class (/home/ma-user/anaconda3/envs/py311/lib/python3.11/argparse.py:1587)"},{"pid":131246,"tid":131246,"ts":1234080174671.664,"ph":"X","cat":"fee","dur":0.07,"name":"builtins.callable"},{"pid":131246,"tid":131246,"ts":1234080174672.854,"ph":"X","cat":"fee","dur":0.44,"name":"Action.__init__ (/home/ma-user/anaconda3/envs/py311/lib/python3.11/argparse.py:834)"},{"pid":131246,"tid":131246,"ts":1234080174672.254,"ph":"X","cat":"fee","dur":1.16,"name":"_StoreAction.__init__ (/home/ma-user/anaconda3/envs/py311/lib/python3.11/argparse.py:919)"},{"pid":131246,"tid":131246,"ts":1234080174674.014,"ph":"X","cat":"fee","dur":0.09,"name":"dict.get"},{"pid":131246,"tid":131246,"ts":1234080174673.824,"ph":"X","cat":"fee","dur":0.38,"name":"_ActionsContainer._registry_get (/home/ma-user/anaconda3/envs/py311/lib/python3.11/argparse.py:1387)"},{"pid":131246,"tid":131246,"ts":1234080174674.364,"ph":"X","cat":"fee","dur":0.05,"name":"builtins.callable"},{"pid":131246,"tid":131246,"ts":1234080174674.634,"ph":"X","cat":"fee","dur":0.15,"name":"builtins.hasattr"},{"pid":131246,"tid":131246,"ts":1234080174680.474,"ph":"X","cat":"fee","dur":0.15,"name":"_io.TextIOWrapper.fileno"},{"pid":131246,"tid":131246,"ts":1234080174680.724,"ph":"X","cat":"fee","dur":0.55,"name":"posix.get_terminal_size"},{"pid":131246,"tid":131246,"ts":1234080174676.054,"ph":"X","cat":"fee","dur":5.9,"name":"get_terminal_size (/home/ma-user/anaconda3/envs/py311/lib/python3.11/shutil.py:1386)"},{"pid":131246,"tid":131246,"ts":1234080174682.564,"ph":"X","cat":"fee","dur":0.32,"name":"builtins.max"},{"pid":131246,"tid":131246,"ts":1234080174682.964,"ph":"X","cat":"fee","dur":0.2,"name":"builtins.min"},{"pid":131246,"tid":131246,"ts":1234080174683.804,"ph":"X","cat":"fee","dur":0.31,"name":"HelpFormatter._Section.__init__ (/home/ma-user/anaconda3/envs/py311/lib/python3.11/argparse.py:206)"},{"pid":131246,"tid":131246,"ts":1234080174684.914,"ph":"X","cat":"fee","dur":0.07,"name":"builtins.isinstance"},{"pid":131246,"tid":131246,"ts":1234080174685.474,"ph":"X","cat":"fee","dur":0.12,"name":"Enum.value (/home/ma-user/anaconda3/envs/py311/lib/python3.11/enum.py:1226)"},{"pid":131246,"tid":131246,"ts":1234080174685.234,"ph":"X","cat":"fee","dur":0.5,"name":"property.__get__ (/home/ma-user/anaconda3/envs/py311/lib/python3.11/enum.py:188)"},{"pid":131246,"tid":131246,"ts":1234080174684.784,"ph":"X","cat":"fee","dur":1.35,"name":"_compile (/home/ma-user/anaconda3/envs/py311/lib/python3.11/re/__init__.py:272)"},{"pid":131246,"tid":131246,"ts":1234080174684.574,"ph":"X","cat":"fee","dur":1.66,"name":"compile (/home/ma-user/anaconda3/envs/py311/lib/python3.11/re/__init__.py:225)"},{"pid":131246,"tid":131246,"ts":1234080174687.864,"ph":"X","cat":"fee","dur":0.24,"name":"builtins.isinstance"},{"pid":131246,"tid":131246,"ts":1234080174687.744,"ph":"X","cat":"fee","dur":0.66,"name":"_compile (/home/ma-user/anaconda3/envs/py311/lib/python3.11/re/__init__.py:272)"},{"pid":131246,"tid":131246,"ts":1234080174687.554,"ph":"X","cat":"fee","dur":0.95,"name":"compile (/home/ma-user/anaconda3/envs/py311/lib/python3.11/re/__init__.py:225)"},{"pid":131246,"tid":131246,"ts":1234080174675.594,"ph":"X","cat":"fee","dur":13.08,"name":"HelpFormatter.__init__ (/home/ma-user/anaconda3/envs/py311/lib/python3.11/argparse.py:164)"},{"pid":131246,"tid":131246,"ts":1234080174675.004,"ph":"X","cat":"fee","dur":13.92,"name":"ArgumentParser._get_formatter (/home/ma-user/anaconda3/envs/py311/lib/python3.11/argparse.py:2576)"},{"pid":131246,"tid":131246,"ts":1234080174689.424,"ph":"X","cat":"fee","dur":0.34,"name":"HelpFormatter._metavar_formatter (/home/ma-user/anaconda3/envs/py311/lib/python3.11/argparse.py:578)"},{"pid":131246,"tid":131246,"ts":1234080174690.294,"ph":"X","cat":"fee","dur":0.09,"name":"builtins.isinstance"},{"pid":131246,"tid":131246,"ts":1234080174690.114,"ph":"X","cat":"fee","dur":0.48,"name":"HelpFormatter._metavar_formatter.<locals>.format (/home/ma-user/anaconda3/envs/py311/lib/python3.11/argparse.py:587)"},{"pid":131246,"tid":131246,"ts":1234080174689.174,"ph":"X","cat":"fee","dur":1.87,"name":"HelpFormatter._format_args (/home/ma-user/anaconda3/envs/py311/lib/python3.11/argparse.py:594)"},{"pid":131246,"tid":131246,"ts":1234080174692.284,"ph":"X","cat":"fee","dur":0.39,"name":"_ActionsContainer._check_conflict (/home/ma-user/anaconda3/envs/py311/lib/python3.11/argparse.py:1600)"},{"pid":131246,"tid":131246,"ts":1234080174692.924,"ph":"X","cat":"fee","dur":0.07,"name":"list.append"},{"pid":131246,"tid":131246,"ts":1234080174693.554,"ph":"X","cat":"fee","dur":0.4,"name":"re.Pattern.match"},{"pid":131246,"tid":131246,"ts":1234080174692.104,"ph":"X","cat":"fee","dur":2.0,"name":"_ActionsContainer._add_action (/home/ma-user/anaconda3/envs/py311/lib/python3.11/argparse.py:1473)"},{"pid":131246,"tid":131246,"ts":1234080174694.324,"ph":"X","cat":"fee","dur":0.07,"name":"list.append"},{"pid":131246,"tid":131246,"ts":1234080174691.654,"ph":"X","cat":"fee","dur":2.83,"name":"_ArgumentGroup._add_action (/home/ma-user/anaconda3/envs/py311/lib/python3.11/argparse.py:1662)"},{"pid":131246,"tid":131246,"ts":1234080174691.354,"ph":"X","cat":"fee","dur":3.26,"name":"ArgumentParser._add_action (/home/ma-user/anaconda3/envs/py311/lib/python3.11/argparse.py:1841)"},{"pid":131246,"tid":131246,"ts":1234080174666.444,"ph":"X","cat":"fee","dur":28.29,"name":"_ActionsContainer.add_argument (/home/ma-user/anaconda3/envs/py311/lib/python3.11/argparse.py:1412)"},{"pid":131246,"tid":131246,"ts":1234080174695.644,"ph":"X","cat":"fee","dur":0.12,"name":"builtins.len"},{"pid":131246,"tid":131246,"ts":1234080174696.884,"ph":"X","cat":"fee","dur":0.07,"name":"list.append"},{"pid":131246,"tid":131246,"ts":1234080174697.114,"ph":"X","cat":"fee","dur":0.07,"name":"builtins.len"},{"pid":131246,"tid":131246,"ts":1234080174697.414,"ph":"X","cat":"fee","dur":0.05,"name":"list.append"},{"pid":131246,"tid":131246,"ts":1234080174697.664,"ph":"X","cat":"fee","dur":0.08,"name":"dict.pop"},{"pid":131246,"tid":131246,"ts":1234080174697.994,"ph":"X","cat":"fee","dur":0.18,"name":"str.lstrip"},{"pid":131246,"tid":131246,"ts":1234080174698.344,"ph":"X","cat":"fee","dur":0.2,"name":"str.replace"},{"pid":131246,"tid":131246,"ts":1234080174696.514,"ph":"X","cat":"fee","dur":2.4,"name":"_ActionsContainer._get_optional_kwargs (/home/ma-user/anaconda3/envs/py311/lib/python3.11/argparse.py:1553)"},{"pid":131246,"tid":131246,"ts":1234080174699.864,"ph":"X","cat":"fee","dur":0.08,"name":"dict.pop"},{"pid":131246,"tid":131246,"ts":1234080174700.374,"ph":"X","cat":"fee","dur":0.09,"name":"dict.get"},{"pid":131246,"tid":131246,"ts":1234080174700.184,"ph":"X","cat":"fee","dur":0.4,"name":"_ActionsContainer._registry_get (/home/ma-user/anaconda3/envs/py311/lib/python3.11/argparse.py:1387)"},{"pid":131246,"tid":131246,"ts":1234080174699.714,"ph":"X","cat":"fee","dur":1.0,"name":"_ActionsContainer._pop_action_class (/home/ma-user/anaconda3/envs/py311/lib/python3.11/argparse.py:1587)"},{"pid":131246,"tid":131246,"ts":1234080174700.854,"ph":"X","cat":"fee","dur":0.07,"name":"builtins.callable"},{"pid":131246,"tid":131246,"ts":1234080174702.114,"ph":"X","cat":"fee","dur":0.43,"name":"Action.__init__ (/home/ma-user/anaconda3/envs/py311/lib/python3.11/argparse.py:834)"},{"pid":131246,"tid":131246,"ts":1234080174701.494,"ph":"X","cat":"fee","dur":1.18,"name":"_StoreAction.__init__ (/home/ma-user/anaconda3/envs/py311/lib/python3.11/argparse.py:919)"},{"pid":131246,"tid":131246,"ts":1234080174703.254,"ph":"X","cat":"fee","dur":0.08,"name":"dict.get"},{"pid":131246,"tid":131246,"ts":1234080174703.064,"ph":"X","cat":"fee","dur":0.38,"name":"_ActionsContainer._registry_get (/home/ma-user/anaconda3/envs/py311/lib/python3.11/argparse.py:1387)"},{"pid":131246,"tid":131246,"ts":1234080174703.594,"ph":"X","cat":"fee","dur":0.06,"name":"builtins.callable"},{"pid":131246,"tid":131246,"ts":1234080174703.824,"ph":"X","cat":"fee","dur":0.15,"name":"builtins.hasattr"},{"pid":131246,"tid":131246,"ts":1234080174709.744,"ph":"X","cat":"fee","dur":0.15,"name":"_io.TextIOWrapper.fileno"},{"pid":131246,"tid":131246,"ts":1234080174710.004,"ph":"X","cat":"fee","dur":0.571,"name":"posix.get_terminal_size"},{"pid":131246,"tid":131246,"ts":1234080174705.254,"ph":"X","cat":"fee","dur":6.021,"name":"get_terminal_size (/home/ma-user/anaconda3/envs/py311/lib/python3.11/shutil.py:1386)"},{"pid":131246,"tid":131246,"ts":1234080174711.885,"ph":"X","cat":"fee","dur":0.35,"name":"builtins.max"},{"pid":131246,"tid":131246,"ts":1234080174712.315,"ph":"X","cat":"fee","dur":0.2,"name":"builtins.min"},{"pid":131246,"tid":131246,"ts":1234080174713.115,"ph":"X","cat":"fee","dur":0.32,"name":"HelpFormatter._Section.__init__ (/home/ma-user/anaconda3/envs/py311/lib/python3.11/argparse.py:206)"},{"pid":131246,"tid":131246,"ts":1234080174714.305,"ph":"X","cat":"fee","dur":0.08,"name":"builtins.isinstance"},{"pid":131246,"tid":131246,"ts":1234080174714.885,"ph":"X","cat":"fee","dur":0.13,"name":"Enum.value (/home/ma-user/anaconda3/envs/py311/lib/python3.11/enum.py:1226)"},{"pid":131246,"tid":131246,"ts":1234080174714.625,"ph":"X","cat":"fee","dur":0.53,"name":"property.__get__ (/home/ma-user/anaconda3/envs/py311/lib/python3.11/enum.py:188)"},{"pid":131246,"tid":131246,"ts":1234080174714.155,"ph":"X","cat":"fee","dur":1.4,"name":"_compile (/home/ma-user/anaconda3/envs/py311/lib/python3.11/re/__init__.py:272)"},{"pid":131246,"tid":131246,"ts":1234080174713.935,"ph":"X","cat":"fee","dur":2.71,"name":"compile (/home/ma-user/anaconda3/envs/py311/lib/python3.11/re/__init__.py:225)"},{"pid":131246,"tid":131246,"ts":1234080174717.365,"ph":"X","cat":"fee","dur":0.22,"name":"builtins.isinstance"},{"pid":131246,"tid":131246,"ts":1234080174717.245,"ph":"X","cat":"fee","dur":0.64,"name":"_compile (/home/ma-user/anaconda3/envs/py311/lib/python3.11/re/__init__.py:272)"},{"pid":131246,"tid":131246,"ts":1234080174717.035,"ph":"X","cat":"fee","dur":0.95,"name":"compile (/home/ma-user/anaconda3/envs/py311/lib/python3.11/re/__init__.py:225)"},{"pid":131246,"tid":131246,"ts":1234080174704.774,"ph":"X","cat":"fee","dur":13.381,"name":"HelpFormatter.__init__ (/home/ma-user/anaconda3/envs/py311/lib/python3.11/argparse.py:164)"},{"pid":131246,"tid":131246,"ts":1234080174704.174,"ph":"X","cat":"fee","dur":14.251,"name":"ArgumentParser._get_formatter (/home/ma-user/anaconda3/envs/py311/lib/python3.11/argparse.py:2576)"},{"pid":131246,"tid":131246,"ts":1234080174718.915,"ph":"X","cat":"fee","dur":0.37,"name":"HelpFormatter._metavar_formatter (/home/ma-user/anaconda3/envs/py311/lib/python3.11/argparse.py:578)"},{"pid":131246,"tid":131246,"ts":1234080174719.835,"ph":"X","cat":"fee","dur":0.1,"name":"builtins.isinstance"},{"pid":131246,"tid":131246,"ts":1234080174719.645,"ph":"X","cat":"fee","dur":0.46,"name":"HelpFormatter._metavar_formatter.<locals>.format (/home/ma-user/anaconda3/envs/py311/lib/python3.11/argparse.py:587)"},{"pid":131246,"tid":131246,"ts":1234080174718.685,"ph":"X","cat":"fee","dur":1.85,"name":"HelpFormatter._format_args (/home/ma-user/anaconda3/envs/py311/lib/python3.11/argparse.py:594)"},{"pid":131246,"tid":131246,"ts":1234080174721.805,"ph":"X","cat":"fee","dur":0.37,"name":"_ActionsContainer._check_conflict (/home/ma-user/anaconda3/envs/py311/lib/python3.11/argparse.py:1600)"},{"pid":131246,"tid":131246,"ts":1234080174722.445,"ph":"X","cat":"fee","dur":0.09,"name":"list.append"},{"pid":131246,"tid":131246,"ts":1234080174723.125,"ph":"X","cat":"fee","dur":0.39,"name":"re.Pattern.match"},{"pid":131246,"tid":131246,"ts":1234080174721.615,"ph":"X","cat":"fee","dur":2.06,"name":"_ActionsContainer._add_action (/home/ma-user/anaconda3/envs/py311/lib/python3.11/argparse.py:1473)"},{"pid":131246,"tid":131246,"ts":1234080174723.895,"ph":"X","cat":"fee","dur":0.07,"name":"list.append"},{"pid":131246,"tid":131246,"ts":1234080174721.175,"ph":"X","cat":"fee","dur":2.88,"name":"_ArgumentGroup._add_action (/home/ma-user/anaconda3/envs/py311/lib/python3.11/argparse.py:1662)"},{"pid":131246,"tid":131246,"ts":1234080174720.855,"ph":"X","cat":"fee","dur":3.34,"name":"ArgumentParser._add_action (/home/ma-user/anaconda3/envs/py311/lib/python3.11/argparse.py:1841)"},{"pid":131246,"tid":131246,"ts":1234080174695.464,"ph":"X","cat":"fee","dur":28.861,"name":"_ActionsContainer.add_argument (/home/ma-user/anaconda3/envs/py311/lib/python3.11/argparse.py:1412)"},{"pid":131246,"tid":131246,"ts":1234080174725.355,"ph":"X","cat":"fee","dur":0.12,"name":"builtins.len"},{"pid":131246,"tid":131246,"ts":1234080174726.715,"ph":"X","cat":"fee","dur":0.08,"name":"list.append"},{"pid":131246,"tid":131246,"ts":1234080174726.945,"ph":"X","cat":"fee","dur":0.09,"name":"builtins.len"},{"pid":131246,"tid":131246,"ts":1234080174727.265,"ph":"X","cat":"fee","dur":0.06,"name":"list.append"},{"pid":131246,"tid":131246,"ts":1234080174727.515,"ph":"X","cat":"fee","dur":0.1,"name":"dict.pop"},{"pid":131246,"tid":131246,"ts":1234080174727.865,"ph":"X","cat":"fee","dur":0.21,"name":"str.lstrip"},{"pid":131246,"tid":131246,"ts":1234080174728.255,"ph":"X","cat":"fee","dur":0.17,"name":"str.replace"},{"pid":131246,"tid":131246,"ts":1234080174726.365,"ph":"X","cat":"fee","dur":2.42,"name":"_ActionsContainer._get_optional_kwargs (/home/ma-user/anaconda3/envs/py311/lib/python3.11/argparse.py:1553)"},{"pid":131246,"tid":131246,"ts":1234080174729.465,"ph":"X","cat":"fee","dur":0.08,"name":"dict.pop"},{"pid":131246,"tid":131246,"ts":1234080174729.985,"ph":"X","cat":"fee","dur":0.1,"name":"dict.get"},{"pid":131246,"tid":131246,"ts":1234080174729.785,"ph":"X","cat":"fee","dur":0.42,"name":"_ActionsContainer._registry_get (/home/ma-user/anaconda3/envs/py311/lib/python3.11/argparse.py:1387)"},{"pid":131246,"tid":131246,"ts":1234080174729.315,"ph":"X","cat":"fee","dur":1.02,"name":"_ActionsContainer._pop_action_class (/home/ma-user/anaconda3/envs/py311/lib/python3.11/argparse.py:1587)"},{"pid":131246,"tid":131246,"ts":1234080174730.475,"ph":"X","cat":"fee","dur":0.06,"name":"builtins.callable"},{"pid":131246,"tid":131246,"ts":1234080174731.795,"ph":"X","cat":"fee","dur":0.43,"name":"Action.__init__ (/home/ma-user/anaconda3/envs/py311/lib/python3.11/argparse.py:834)"},{"pid":131246,"tid":131246,"ts":1234080174731.175,"ph":"X","cat":"fee","dur":1.17,"name":"_StoreAction.__init__ (/home/ma-user/anaconda3/envs/py311/lib/python3.11/argparse.py:919)"},{"pid":131246,"tid":131246,"ts":1234080174732.905,"ph":"X","cat":"fee","dur":0.08,"name":"dict.get"},{"pid":131246,"tid":131246,"ts":1234080174732.725,"ph":"X","cat":"fee","dur":0.36,"name":"_ActionsContainer._registry_get (/home/ma-user/anaconda3/envs/py311/lib/python3.11/argparse.py:1387)"},{"pid":131246,"tid":131246,"ts":1234080174733.245,"ph":"X","cat":"fee","dur":0.07,"name":"builtins.callable"},{"pid":131246,"tid":131246,"ts":1234080174733.485,"ph":"X","cat":"fee","dur":0.15,"name":"builtins.hasattr"},{"pid":131246,"tid":131246,"ts":1234080174739.425,"ph":"X","cat":"fee","dur":0.17,"name":"_io.TextIOWrapper.fileno"},{"pid":131246,"tid":131246,"ts":1234080174739.685,"ph":"X","cat":"fee","dur":0.59,"name":"posix.get_terminal_size"},{"pid":131246,"tid":131246,"ts":1234080174734.935,"ph":"X","cat":"fee","dur":5.98,"name":"get_terminal_size (/home/ma-user/anaconda3/envs/py311/lib/python3.11/shutil.py:1386)"},{"pid":131246,"tid":131246,"ts":1234080174741.485,"ph":"X","cat":"fee","dur":0.36,"name":"builtins.max"},{"pid":131246,"tid":131246,"ts":1234080174741.925,"ph":"X","cat":"fee","dur":0.2,"name":"builtins.min"},{"pid":131246,"tid":131246,"ts":1234080174742.715,"ph":"X","cat":"fee","dur":0.31,"name":"HelpFormatter._Section.__init__ (/home/ma-user/anaconda3/envs/py311/lib/python3.11/argparse.py:206)"},{"pid":131246,"tid":131246,"ts":1234080174743.845,"ph":"X","cat":"fee","dur":0.1,"name":"builtins.isinstance"},{"pid":131246,"tid":131246,"ts":1234080174744.435,"ph":"X","cat":"fee","dur":0.12,"name":"Enum.value (/home/ma-user/anaconda3/envs/py311/lib/python3.11/enum.py:1226)"},{"pid":131246,"tid":131246,"ts":1234080174744.175,"ph":"X","cat":"fee","dur":0.53,"name":"property.__get__ (/home/ma-user/anaconda3/envs/py311/lib/python3.11/enum.py:188)"},{"pid":131246,"tid":131246,"ts":1234080174743.705,"ph":"X","cat":"fee","dur":1.41,"name":"_compile (/home/ma-user/anaconda3/envs/py311/lib/python3.11/re/__init__.py:272)"},{"pid":131246,"tid":131246,"ts":1234080174743.505,"ph":"X","cat":"fee","dur":5.63,"name":"compile (/home/ma-user/anaconda3/envs/py311/lib/python3.11/re/__init__.py:225)"},{"pid":131246,"tid":131246,"ts":1234080174749.875,"ph":"X","cat":"fee","dur":0.24,"name":"builtins.isinstance"},{"pid":131246,"tid":131246,"ts":1234080174749.735,"ph":"X","cat":"fee","dur":0.67,"name":"_compile (/home/ma-user/anaconda3/envs/py311/lib/python3.11/re/__init__.py:272)"},{"pid":131246,"tid":131246,"ts":1234080174749.525,"ph":"X","cat":"fee","dur":0.99,"name":"compile (/home/ma-user/anaconda3/envs/py311/lib/python3.11/re/__init__.py:225)"},{"pid":131246,"tid":131246,"ts":1234080174734.475,"ph":"X","cat":"fee","dur":16.2,"name":"HelpFormatter.__init__ (/home/ma-user/anaconda3/envs/py311/lib/python3.11/argparse.py:164)"},{"pid":131246,"tid":131246,"ts":1234080174733.855,"ph":"X","cat":"fee","dur":17.08,"name":"ArgumentParser._get_formatter (/home/ma-user/anaconda3/envs/py311/lib/python3.11/argparse.py:2576)"},{"pid":131246,"tid":131246,"ts":1234080174751.415,"ph":"X","cat":"fee","dur":0.35,"name":"HelpFormatter._metavar_formatter (/home/ma-user/anaconda3/envs/py311/lib/python3.11/argparse.py:578)"},{"pid":131246,"tid":131246,"ts":1234080174752.265,"ph":"X","cat":"fee","dur":0.09,"name":"builtins.isinstance"},{"pid":131246,"tid":131246,"ts":1234080174752.085,"ph":"X","cat":"fee","dur":0.45,"name":"HelpFormatter._metavar_formatter.<locals>.format (/home/ma-user/anaconda3/envs/py311/lib/python3.11/argparse.py:587)"},{"pid":131246,"tid":131246,"ts":1234080174751.175,"ph":"X","cat":"fee","dur":1.78,"name":"HelpFormatter._format_args (/home/ma-user/anaconda3/envs/py311/lib/python3.11/argparse.py:594)"},{"pid":131246,"tid":131246,"ts":1234080174754.285,"ph":"X","cat":"fee","dur":0.37,"name":"_ActionsContainer._check_conflict (/home/ma-user/anaconda3/envs/py311/lib/python3.11/argparse.py:1600)"},{"pid":131246,"tid":131246,"ts":1234080174754.935,"ph":"X","cat":"fee","dur":0.08,"name":"list.append"},{"pid":131246,"tid":131246,"ts":1234080174755.575,"ph":"X","cat":"fee","dur":0.43,"name":"re.Pattern.match"},{"pid":131246,"tid":131246,"ts":1234080174754.095,"ph":"X","cat":"fee","dur":2.07,"name":"_ActionsContainer._add_action (/home/ma-user/anaconda3/envs/py311/lib/python3.11/argparse.py:1473)"},{"pid":131246,"tid":131246,"ts":1234080174756.375,"ph":"X","cat":"fee","dur":0.06,"name":"list.append"},{"pid":131246,"tid":131246,"ts":1234080174753.615,"ph":"X","cat":"fee","dur":2.92,"name":"_ArgumentGroup._add_action (/home/ma-user/anaconda3/envs/py311/lib/python3.11/argparse.py:1662)"},{"pid":131246,"tid":131246,"ts":1234080174753.315,"ph":"X","cat":"fee","dur":3.35,"name":"ArgumentParser._add_action (/home/ma-user/anaconda3/envs/py311/lib/python3.11/argparse.py:1841)"},{"pid":131246,"tid":131246,"ts":1234080174725.165,"ph":"X","cat":"fee","dur":31.62,"name":"_ActionsContainer.add_argument (/home/ma-user/anaconda3/envs/py311/lib/python3.11/argparse.py:1412)"},{"pid":131246,"tid":131246,"ts":1234080174757.705,"ph":"X","cat":"fee","dur":0.11,"name":"builtins.len"},{"pid":131246,"tid":131246,"ts":1234080174758.945,"ph":"X","cat":"fee","dur":0.09,"name":"list.append"},{"pid":131246,"tid":131246,"ts":1234080174759.195,"ph":"X","cat":"fee","dur":0.06,"name":"builtins.len"},{"pid":131246,"tid":131246,"ts":1234080174759.485,"ph":"X","cat":"fee","dur":0.06,"name":"list.append"},{"pid":131246,"tid":131246,"ts":1234080174759.735,"ph":"X","cat":"fee","dur":0.1,"name":"dict.pop"},{"pid":131246,"tid":131246,"ts":1234080174760.125,"ph":"X","cat":"fee","dur":0.18,"name":"str.lstrip"},{"pid":131246,"tid":131246,"ts":1234080174760.475,"ph":"X","cat":"fee","dur":0.19,"name":"str.replace"},{"pid":131246,"tid":131246,"ts":1234080174758.625,"ph":"X","cat":"fee","dur":2.37,"name":"_ActionsContainer._get_optional_kwargs (/home/ma-user/anaconda3/envs/py311/lib/python3.11/argparse.py:1553)"},{"pid":131246,"tid":131246,"ts":1234080174761.725,"ph":"X","cat":"fee","dur":0.08,"name":"dict.pop"},{"pid":131246,"tid":131246,"ts":1234080174762.245,"ph":"X","cat":"fee","dur":0.09,"name":"dict.get"},{"pid":131246,"tid":131246,"ts":1234080174762.035,"ph":"X","cat":"fee","dur":0.43,"name":"_ActionsContainer._registry_get (/home/ma-user/anaconda3/envs/py311/lib/python3.11/argparse.py:1387)"},{"pid":131246,"tid":131246,"ts":1234080174761.545,"ph":"X","cat":"fee","dur":1.05,"name":"_ActionsContainer._pop_action_class (/home/ma-user/anaconda3/envs/py311/lib/python3.11/argparse.py:1587)"},{"pid":131246,"tid":131246,"ts":1234080174762.735,"ph":"X","cat":"fee","dur":0.06,"name":"builtins.callable"},{"pid":131246,"tid":131246,"ts":1234080174765.395,"ph":"X","cat":"fee","dur":0.44,"name":"Action.__init__ (/home/ma-user/anaconda3/envs/py311/lib/python3.11/argparse.py:834)"},{"pid":131246,"tid":131246,"ts":1234080174763.375,"ph":"X","cat":"fee","dur":2.62,"name":"_StoreAction.__init__ (/home/ma-user/anaconda3/envs/py311/lib/python3.11/argparse.py:919)"},{"pid":131246,"tid":131246,"ts":1234080174766.685,"ph":"X","cat":"fee","dur":0.09,"name":"dict.get"},{"pid":131246,"tid":131246,"ts":1234080174766.475,"ph":"X","cat":"fee","dur":0.44,"name":"_ActionsContainer._registry_get (/home/ma-user/anaconda3/envs/py311/lib/python3.11/argparse.py:1387)"},{"pid":131246,"tid":131246,"ts":1234080174767.065,"ph":"X","cat":"fee","dur":0.06,"name":"builtins.callable"},{"pid":131246,"tid":131246,"ts":1234080174767.315,"ph":"X","cat":"fee","dur":0.16,"name":"builtins.hasattr"},{"pid":131246,"tid":131246,"ts":1234080174773.555,"ph":"X","cat":"fee","dur":0.16,"name":"_io.TextIOWrapper.fileno"},{"pid":131246,"tid":131246,"ts":1234080174773.805,"ph":"X","cat":"fee","dur":0.64,"name":"posix.get_terminal_size"},{"pid":131246,"tid":131246,"ts":1234080174768.715,"ph":"X","cat":"fee","dur":6.44,"name":"get_terminal_size (/home/ma-user/anaconda3/envs/py311/lib/python3.11/shutil.py:1386)"},{"pid":131246,"tid":131246,"ts":1234080174775.825,"ph":"X","cat":"fee","dur":0.35,"name":"builtins.max"},{"pid":131246,"tid":131246,"ts":1234080174776.245,"ph":"X","cat":"fee","dur":0.22,"name":"builtins.min"},{"pid":131246,"tid":131246,"ts":1234080174777.075,"ph":"X","cat":"fee","dur":0.32,"name":"HelpFormatter._Section.__init__ (/home/ma-user/anaconda3/envs/py311/lib/python3.11/argparse.py:206)"},{"pid":131246,"tid":131246,"ts":1234080174778.195,"ph":"X","cat":"fee","dur":0.08,"name":"builtins.isinstance"},{"pid":131246,"tid":131246,"ts":1234080174778.755,"ph":"X","cat":"fee","dur":0.13,"name":"Enum.value (/home/ma-user/anaconda3/envs/py311/lib/python3.11/enum.py:1226)"},{"pid":131246,"tid":131246,"ts":1234080174778.515,"ph":"X","cat":"fee","dur":0.51,"name":"property.__get__ (/home/ma-user/anaconda3/envs/py311/lib/python3.11/enum.py:188)"},{"pid":131246,"tid":131246,"ts":1234080174778.065,"ph":"X","cat":"fee","dur":2.33,"name":"_compile (/home/ma-user/anaconda3/envs/py311/lib/python3.11/re/__init__.py:272)"},{"pid":131246,"tid":131246,"ts":1234080174777.875,"ph":"X","cat":"fee","dur":2.63,"name":"compile (/home/ma-user/anaconda3/envs/py311/lib/python3.11/re/__init__.py:225)"},{"pid":131246,"tid":131246,"ts":1234080174781.195,"ph":"X","cat":"fee","dur":0.28,"name":"builtins.isinstance"},{"pid":131246,"tid":131246,"ts":1234080174781.065,"ph":"X","cat":"fee","dur":0.74,"name":"_compile (/home/ma-user/anaconda3/envs/py311/lib/python3.11/re/__init__.py:272)"},{"pid":131246,"tid":131246,"ts":1234080174780.865,"ph":"X","cat":"fee","dur":1.05,"name":"compile (/home/ma-user/anaconda3/envs/py311/lib/python3.11/re/__init__.py:225)"},{"pid":131246,"tid":131246,"ts":1234080174768.245,"ph":"X","cat":"fee","dur":13.84,"name":"HelpFormatter.__init__ (/home/ma-user/anaconda3/envs/py311/lib/python3.11/argparse.py:164)"},{"pid":131246,"tid":131246,"ts":1234080174767.685,"ph":"X","cat":"fee","dur":14.65,"name":"ArgumentParser._get_formatter (/home/ma-user/anaconda3/envs/py311/lib/python3.11/argparse.py:2576)"},{"pid":131246,"tid":131246,"ts":1234080174782.835,"ph":"X","cat":"fee","dur":0.33,"name":"HelpFormatter._metavar_formatter (/home/ma-user/anaconda3/envs/py311/lib/python3.11/argparse.py:578)"},{"pid":131246,"tid":131246,"ts":1234080174783.675,"ph":"X","cat":"fee","dur":0.1,"name":"builtins.isinstance"},{"pid":131246,"tid":131246,"ts":1234080174783.505,"ph":"X","cat":"fee","dur":0.47,"name":"HelpFormatter._metavar_formatter.<locals>.format (/home/ma-user/anaconda3/envs/py311/lib/python3.11/argparse.py:587)"},{"pid":131246,"tid":131246,"ts":1234080174782.595,"ph":"X","cat":"fee","dur":1.84,"name":"HelpFormatter._format_args (/home/ma-user/anaconda3/envs/py311/lib/python3.11/argparse.py:594)"},{"pid":131246,"tid":131246,"ts":1234080174785.915,"ph":"X","cat":"fee","dur":0.4,"name":"_ActionsContainer._check_conflict (/home/ma-user/anaconda3/envs/py311/lib/python3.11/argparse.py:1600)"},{"pid":131246,"tid":131246,"ts":1234080174786.585,"ph":"X","cat":"fee","dur":0.08,"name":"list.append"},{"pid":131246,"tid":131246,"ts":1234080174787.245,"ph":"X","cat":"fee","dur":0.4,"name":"re.Pattern.match"},{"pid":131246,"tid":131246,"ts":1234080174785.705,"ph":"X","cat":"fee","dur":2.1,"name":"_ActionsContainer._add_action (/home/ma-user/anaconda3/envs/py311/lib/python3.11/argparse.py:1473)"},{"pid":131246,"tid":131246,"ts":1234080174788.065,"ph":"X","cat":"fee","dur":0.05,"name":"list.append"},{"pid":131246,"tid":131246,"ts":1234080174785.115,"ph":"X","cat":"fee","dur":3.11,"name":"_ArgumentGroup._add_action (/home/ma-user/anaconda3/envs/py311/lib/python3.11/argparse.py:1662)"},{"pid":131246,"tid":131246,"ts":1234080174784.835,"ph":"X","cat":"fee","dur":3.52,"name":"ArgumentParser._add_action (/home/ma-user/anaconda3/envs/py311/lib/python3.11/argparse.py:1841)"},{"pid":131246,"tid":131246,"ts":1234080174757.495,"ph":"X","cat":"fee","dur":30.98,"name":"_ActionsContainer.add_argument (/home/ma-user/anaconda3/envs/py311/lib/python3.11/argparse.py:1412)"},{"pid":131246,"tid":131246,"ts":1234080174789.415,"ph":"X","cat":"fee","dur":0.11,"name":"builtins.len"},{"pid":131246,"tid":131246,"ts":1234080174790.785,"ph":"X","cat":"fee","dur":0.08,"name":"list.append"},{"pid":131246,"tid":131246,"ts":1234080174791.035,"ph":"X","cat":"fee","dur":0.09,"name":"builtins.len"},{"pid":131246,"tid":131246,"ts":1234080174791.365,"ph":"X","cat":"fee","dur":0.06,"name":"list.append"},{"pid":131246,"tid":131246,"ts":1234080174791.615,"ph":"X","cat":"fee","dur":0.1,"name":"dict.pop"},{"pid":131246,"tid":131246,"ts":1234080174792.025,"ph":"X","cat":"fee","dur":0.16,"name":"str.lstrip"},{"pid":131246,"tid":131246,"ts":1234080174792.365,"ph":"X","cat":"fee","dur":0.18,"name":"str.replace"},{"pid":131246,"tid":131246,"ts":1234080174790.445,"ph":"X","cat":"fee","dur":2.45,"name":"_ActionsContainer._get_optional_kwargs (/home/ma-user/anaconda3/envs/py311/lib/python3.11/argparse.py:1553)"},{"pid":131246,"tid":131246,"ts":1234080174793.635,"ph":"X","cat":"fee","dur":0.07,"name":"dict.pop"},{"pid":131246,"tid":131246,"ts":1234080174794.145,"ph":"X","cat":"fee","dur":0.09,"name":"dict.get"},{"pid":131246,"tid":131246,"ts":1234080174793.955,"ph":"X","cat":"fee","dur":0.4,"name":"_ActionsContainer._registry_get (/home/ma-user/anaconda3/envs/py311/lib/python3.11/argparse.py:1387)"},{"pid":131246,"tid":131246,"ts":1234080174793.455,"ph":"X","cat":"fee","dur":1.03,"name":"_ActionsContainer._pop_action_class (/home/ma-user/anaconda3/envs/py311/lib/python3.11/argparse.py:1587)"},{"pid":131246,"tid":131246,"ts":1234080174794.645,"ph":"X","cat":"fee","dur":0.06,"name":"builtins.callable"},{"pid":131246,"tid":131246,"ts":1234080174795.885,"ph":"X","cat":"fee","dur":0.44,"name":"Action.__init__ (/home/ma-user/anaconda3/envs/py311/lib/python3.11/argparse.py:834)"},{"pid":131246,"tid":131246,"ts":1234080174795.265,"ph":"X","cat":"fee","dur":1.2,"name":"_StoreAction.__init__ (/home/ma-user/anaconda3/envs/py311/lib/python3.11/argparse.py:919)"},{"pid":131246,"tid":131246,"ts":1234080174797.025,"ph":"X","cat":"fee","dur":0.08,"name":"dict.get"},{"pid":131246,"tid":131246,"ts":1234080174796.835,"ph":"X","cat":"fee","dur":0.39,"name":"_ActionsContainer._registry_get (/home/ma-user/anaconda3/envs/py311/lib/python3.11/argparse.py:1387)"},{"pid":131246,"tid":131246,"ts":1234080174797.415,"ph":"X","cat":"fee","dur":0.07,"name":"builtins.callable"},{"pid":131246,"tid":131246,"ts":1234080174797.685,"ph":"X","cat":"fee","dur":0.15,"name":"builtins.hasattr"},{"pid":131246,"tid":131246,"ts":1234080174803.685,"ph":"X","cat":"fee","dur":0.16,"name":"_io.TextIOWrapper.fileno"},{"pid":131246,"tid":131246,"ts":1234080174803.945,"ph":"X","cat":"fee","dur":0.61,"name":"posix.get_terminal_size"},{"pid":131246,"tid":131246,"ts":1234080174799.145,"ph":"X","cat":"fee","dur":6.08,"name":"get_terminal_size (/home/ma-user/anaconda3/envs/py311/lib/python3.11/shutil.py:1386)"},{"pid":131246,"tid":131246,"ts":1234080174805.845,"ph":"X","cat":"fee","dur":0.3,"name":"builtins.max"},{"pid":131246,"tid":131246,"ts":1234080174806.225,"ph":"X","cat":"fee","dur":0.22,"name":"builtins.min"},{"pid":131246,"tid":131246,"ts":1234080174807.015,"ph":"X","cat":"fee","dur":0.32,"name":"HelpFormatter._Section.__init__ (/home/ma-user/anaconda3/envs/py311/lib/python3.11/argparse.py:206)"},{"pid":131246,"tid":131246,"ts":1234080174808.125,"ph":"X","cat":"fee","dur":0.08,"name":"builtins.isinstance"},{"pid":131246,"tid":131246,"ts":1234080174808.705,"ph":"X","cat":"fee","dur":0.12,"name":"Enum.value (/home/ma-user/anaconda3/envs/py311/lib/python3.11/enum.py:1226)"},{"pid":131246,"tid":131246,"ts":1234080174808.455,"ph":"X","cat":"fee","dur":0.51,"name":"property.__get__ (/home/ma-user/anaconda3/envs/py311/lib/python3.11/enum.py:188)"},{"pid":131246,"tid":131246,"ts":1234080174807.995,"ph":"X","cat":"fee","dur":2.47,"name":"_compile (/home/ma-user/anaconda3/envs/py311/lib/python3.11/re/__init__.py:272)"},{"pid":131246,"tid":131246,"ts":1234080174807.805,"ph":"X","cat":"fee","dur":2.79,"name":"compile (/home/ma-user/anaconda3/envs/py311/lib/python3.11/re/__init__.py:225)"},{"pid":131246,"tid":131246,"ts":1234080174811.265,"ph":"X","cat":"fee","dur":0.24,"name":"builtins.isinstance"},{"pid":131246,"tid":131246,"ts":1234080174811.145,"ph":"X","cat":"fee","dur":0.66,"name":"_compile (/home/ma-user/anaconda3/envs/py311/lib/python3.11/re/__init__.py:272)"},{"pid":131246,"tid":131246,"ts":1234080174810.955,"ph":"X","cat":"fee","dur":0.97,"name":"compile (/home/ma-user/anaconda3/envs/py311/lib/python3.11/re/__init__.py:225)"},{"pid":131246,"tid":131246,"ts":1234080174798.655,"ph":"X","cat":"fee","dur":13.44,"name":"HelpFormatter.__init__ (/home/ma-user/anaconda3/envs/py311/lib/python3.11/argparse.py:164)"},{"pid":131246,"tid":131246,"ts":1234080174798.055,"ph":"X","cat":"fee","dur":14.29,"name":"ArgumentParser._get_formatter (/home/ma-user/anaconda3/envs/py311/lib/python3.11/argparse.py:2576)"},{"pid":131246,"tid":131246,"ts":1234080174812.795,"ph":"X","cat":"fee","dur":0.36,"name":"HelpFormatter._metavar_formatter (/home/ma-user/anaconda3/envs/py311/lib/python3.11/argparse.py:578)"},{"pid":131246,"tid":131246,"ts":1234080174813.675,"ph":"X","cat":"fee","dur":0.12,"name":"builtins.isinstance"},{"pid":131246,"tid":131246,"ts":1234080174813.485,"ph":"X","cat":"fee","dur":0.5,"name":"HelpFormatter._metavar_formatter.<locals>.format (/home/ma-user/anaconda3/envs/py311/lib/python3.11/argparse.py:587)"},{"pid":131246,"tid":131246,"ts":1234080174812.575,"ph":"X","cat":"fee","dur":1.841,"name":"HelpFormatter._format_args (/home/ma-user/anaconda3/envs/py311/lib/python3.11/argparse.py:594)"},{"pid":131246,"tid":131246,"ts":1234080174815.706,"ph":"X","cat":"fee","dur":0.36,"name":"_ActionsContainer._check_conflict (/home/ma-user/anaconda3/envs/py311/lib/python3.11/argparse.py:1600)"},{"pid":131246,"tid":131246,"ts":1234080174816.346,"ph":"X","cat":"fee","dur":0.08,"name":"list.append"},{"pid":131246,"tid":131246,"ts":1234080174817.016,"ph":"X","cat":"fee","dur":0.41,"name":"re.Pattern.match"},{"pid":131246,"tid":131246,"ts":1234080174815.496,"ph":"X","cat":"fee","dur":2.07,"name":"_ActionsContainer._add_action (/home/ma-user/anaconda3/envs/py311/lib/python3.11/argparse.py:1473)"},{"pid":131246,"tid":131246,"ts":1234080174817.806,"ph":"X","cat":"fee","dur":0.07,"name":"list.append"},{"pid":131246,"tid":131246,"ts":1234080174815.016,"ph":"X","cat":"fee","dur":2.97,"name":"_ArgumentGroup._add_action (/home/ma-user/anaconda3/envs/py311/lib/python3.11/argparse.py:1662)"},{"pid":131246,"tid":131246,"ts":1234080174814.726,"ph":"X","cat":"fee","dur":3.39,"name":"ArgumentParser._add_action (/home/ma-user/anaconda3/envs/py311/lib/python3.11/argparse.py:1841)"},{"pid":131246,"tid":131246,"ts":1234080174789.215,"ph":"X","cat":"fee","dur":29.021,"name":"_ActionsContainer.add_argument (/home/ma-user/anaconda3/envs/py311/lib/python3.11/argparse.py:1412)"},{"pid":131246,"tid":131246,"ts":1234080174819.206,"ph":"X","cat":"fee","dur":0.12,"name":"builtins.len"},{"pid":131246,"tid":131246,"ts":1234080174820.466,"ph":"X","cat":"fee","dur":0.07,"name":"list.append"},{"pid":131246,"tid":131246,"ts":1234080174820.686,"ph":"X","cat":"fee","dur":0.08,"name":"builtins.len"},{"pid":131246,"tid":131246,"ts":1234080174820.966,"ph":"X","cat":"fee","dur":0.05,"name":"list.append"},{"pid":131246,"tid":131246,"ts":1234080174821.226,"ph":"X","cat":"fee","dur":0.09,"name":"dict.pop"},{"pid":131246,"tid":131246,"ts":1234080174821.586,"ph":"X","cat":"fee","dur":0.16,"name":"str.lstrip"},{"pid":131246,"tid":131246,"ts":1234080174821.916,"ph":"X","cat":"fee","dur":0.17,"name":"str.replace"},{"pid":131246,"tid":131246,"ts":1234080174820.116,"ph":"X","cat":"fee","dur":2.32,"name":"_ActionsContainer._get_optional_kwargs (/home/ma-user/anaconda3/envs/py311/lib/python3.11/argparse.py:1553)"},{"pid":131246,"tid":131246,"ts":1234080174823.136,"ph":"X","cat":"fee","dur":0.08,"name":"dict.pop"},{"pid":131246,"tid":131246,"ts":1234080174823.666,"ph":"X","cat":"fee","dur":0.1,"name":"dict.get"},{"pid":131246,"tid":131246,"ts":1234080174823.456,"ph":"X","cat":"fee","dur":0.43,"name":"_ActionsContainer._registry_get (/home/ma-user/anaconda3/envs/py311/lib/python3.11/argparse.py:1387)"},{"pid":131246,"tid":131246,"ts":1234080174822.966,"ph":"X","cat":"fee","dur":1.06,"name":"_ActionsContainer._pop_action_class (/home/ma-user/anaconda3/envs/py311/lib/python3.11/argparse.py:1587)"},{"pid":131246,"tid":131246,"ts":1234080174824.176,"ph":"X","cat":"fee","dur":0.07,"name":"builtins.callable"},{"pid":131246,"tid":131246,"ts":1234080174825.336,"ph":"X","cat":"fee","dur":0.43,"name":"Action.__init__ (/home/ma-user/anaconda3/envs/py311/lib/python3.11/argparse.py:834)"},{"pid":131246,"tid":131246,"ts":1234080174824.776,"ph":"X","cat":"fee","dur":1.11,"name":"_StoreAction.__init__ (/home/ma-user/anaconda3/envs/py311/lib/python3.11/argparse.py:919)"},{"pid":131246,"tid":131246,"ts":1234080174826.446,"ph":"X","cat":"fee","dur":0.08,"name":"dict.get"},{"pid":131246,"tid":131246,"ts":1234080174826.266,"ph":"X","cat":"fee","dur":0.37,"name":"_ActionsContainer._registry_get (/home/ma-user/anaconda3/envs/py311/lib/python3.11/argparse.py:1387)"},{"pid":131246,"tid":131246,"ts":1234080174826.786,"ph":"X","cat":"fee","dur":0.06,"name":"builtins.callable"},{"pid":131246,"tid":131246,"ts":1234080174827.016,"ph":"X","cat":"fee","dur":0.16,"name":"builtins.hasattr"},{"pid":131246,"tid":131246,"ts":1234080174832.676,"ph":"X","cat":"fee","dur":0.17,"name":"_io.TextIOWrapper.fileno"},{"pid":131246,"tid":131246,"ts":1234080174832.946,"ph":"X","cat":"fee","dur":0.58,"name":"posix.get_terminal_size"},{"pid":131246,"tid":131246,"ts":1234080174828.416,"ph":"X","cat":"fee","dur":5.77,"name":"get_terminal_size (/home/ma-user/anaconda3/envs/py311/lib/python3.11/shutil.py:1386)"},{"pid":131246,"tid":131246,"ts":1234080174834.796,"ph":"X","cat":"fee","dur":0.34,"name":"builtins.max"},{"pid":131246,"tid":131246,"ts":1234080174835.216,"ph":"X","cat":"fee","dur":0.21,"name":"builtins.min"},{"pid":131246,"tid":131246,"ts":1234080174835.996,"ph":"X","cat":"fee","dur":0.31,"name":"HelpFormatter._Section.__init__ (/home/ma-user/anaconda3/envs/py311/lib/python3.11/argparse.py:206)"},{"pid":131246,"tid":131246,"ts":1234080174837.116,"ph":"X","cat":"fee","dur":0.08,"name":"builtins.isinstance"},{"pid":131246,"tid":131246,"ts":1234080174837.676,"ph":"X","cat":"fee","dur":0.13,"name":"Enum.value (/home/ma-user/anaconda3/envs/py311/lib/python3.11/enum.py:1226)"},{"pid":131246,"tid":131246,"ts":1234080174837.436,"ph":"X","cat":"fee","dur":1.51,"name":"property.__get__ (/home/ma-user/anaconda3/envs/py311/lib/python3.11/enum.py:188)"},{"pid":131246,"tid":131246,"ts":1234080174836.976,"ph":"X","cat":"fee","dur":2.41,"name":"_compile (/home/ma-user/anaconda3/envs/py311/lib/python3.11/re/__init__.py:272)"},{"pid":131246,"tid":131246,"ts":1234080174836.776,"ph":"X","cat":"fee","dur":2.72,"name":"compile (/home/ma-user/anaconda3/envs/py311/lib/python3.11/re/__init__.py:225)"},{"pid":131246,"tid":131246,"ts":1234080174840.146,"ph":"X","cat":"fee","dur":0.21,"name":"builtins.isinstance"},{"pid":131246,"tid":131246,"ts":1234080174840.016,"ph":"X","cat":"fee","dur":0.62,"name":"_compile (/home/ma-user/anaconda3/envs/py311/lib/python3.11/re/__init__.py:272)"},{"pid":131246,"tid":131246,"ts":1234080174839.826,"ph":"X","cat":"fee","dur":0.92,"name":"compile (/home/ma-user/anaconda3/envs/py311/lib/python3.11/re/__init__.py:225)"},{"pid":131246,"tid":131246,"ts":1234080174827.956,"ph":"X","cat":"fee","dur":12.97,"name":"HelpFormatter.__init__ (/home/ma-user/anaconda3/envs/py311/lib/python3.11/argparse.py:164)"},{"pid":131246,"tid":131246,"ts":1234080174827.376,"ph":"X","cat":"fee","dur":13.79,"name":"ArgumentParser._get_formatter (/home/ma-user/anaconda3/envs/py311/lib/python3.11/argparse.py:2576)"},{"pid":131246,"tid":131246,"ts":1234080174841.646,"ph":"X","cat":"fee","dur":0.35,"name":"HelpFormatter._metavar_formatter (/home/ma-user/anaconda3/envs/py311/lib/python3.11/argparse.py:578)"},{"pid":131246,"tid":131246,"ts":1234080174842.496,"ph":"X","cat":"fee","dur":0.09,"name":"builtins.isinstance"},{"pid":131246,"tid":131246,"ts":1234080174842.306,"ph":"X","cat":"fee","dur":0.48,"name":"HelpFormatter._metavar_formatter.<locals>.format (/home/ma-user/anaconda3/envs/py311/lib/python3.11/argparse.py:587)"},{"pid":131246,"tid":131246,"ts":1234080174841.396,"ph":"X","cat":"fee","dur":1.84,"name":"HelpFormatter._format_args (/home/ma-user/anaconda3/envs/py311/lib/python3.11/argparse.py:594)"},{"pid":131246,"tid":131246,"ts":1234080174844.546,"ph":"X","cat":"fee","dur":0.38,"name":"_ActionsContainer._check_conflict (/home/ma-user/anaconda3/envs/py311/lib/python3.11/argparse.py:1600)"},{"pid":131246,"tid":131246,"ts":1234080174845.226,"ph":"X","cat":"fee","dur":0.08,"name":"list.append"},{"pid":131246,"tid":131246,"ts":1234080174845.866,"ph":"X","cat":"fee","dur":0.38,"name":"re.Pattern.match"},{"pid":131246,"tid":131246,"ts":1234080174844.326,"ph":"X","cat":"fee","dur":2.07,"name":"_ActionsContainer._add_action (/home/ma-user/anaconda3/envs/py311/lib/python3.11/argparse.py:1473)"},{"pid":131246,"tid":131246,"ts":1234080174846.616,"ph":"X","cat":"fee","dur":0.07,"name":"list.append"},{"pid":131246,"tid":131246,"ts":1234080174843.896,"ph":"X","cat":"fee","dur":2.9,"name":"_ArgumentGroup._add_action (/home/ma-user/anaconda3/envs/py311/lib/python3.11/argparse.py:1662)"},{"pid":131246,"tid":131246,"ts":1234080174843.616,"ph":"X","cat":"fee","dur":3.31,"name":"ArgumentParser._add_action (/home/ma-user/anaconda3/envs/py311/lib/python3.11/argparse.py:1841)"},{"pid":131246,"tid":131246,"ts":1234080174819.006,"ph":"X","cat":"fee","dur":28.04,"name":"_ActionsContainer.add_argument (/home/ma-user/anaconda3/envs/py311/lib/python3.11/argparse.py:1412)"},{"pid":131246,"tid":131246,"ts":1234080174847.976,"ph":"X","cat":"fee","dur":0.11,"name":"builtins.len"},{"pid":131246,"tid":131246,"ts":1234080174850.176,"ph":"X","cat":"fee","dur":0.09,"name":"list.append"},{"pid":131246,"tid":131246,"ts":1234080174850.436,"ph":"X","cat":"fee","dur":0.09,"name":"builtins.len"},{"pid":131246,"tid":131246,"ts":1234080174850.756,"ph":"X","cat":"fee","dur":0.06,"name":"list.append"},{"pid":131246,"tid":131246,"ts":1234080174851.016,"ph":"X","cat":"fee","dur":0.1,"name":"dict.pop"},{"pid":131246,"tid":131246,"ts":1234080174851.356,"ph":"X","cat":"fee","dur":0.17,"name":"str.lstrip"},{"pid":131246,"tid":131246,"ts":1234080174851.696,"ph":"X","cat":"fee","dur":0.16,"name":"str.replace"},{"pid":131246,"tid":131246,"ts":1234080174849.806,"ph":"X","cat":"fee","dur":2.42,"name":"_ActionsContainer._get_optional_kwargs (/home/ma-user/anaconda3/envs/py311/lib/python3.11/argparse.py:1553)"},{"pid":131246,"tid":131246,"ts":1234080174852.946,"ph":"X","cat":"fee","dur":0.09,"name":"dict.pop"},{"pid":131246,"tid":131246,"ts":1234080174853.466,"ph":"X","cat":"fee","dur":0.09,"name":"dict.get"},{"pid":131246,"tid":131246,"ts":1234080174853.286,"ph":"X","cat":"fee","dur":0.38,"name":"_ActionsContainer._registry_get (/home/ma-user/anaconda3/envs/py311/lib/python3.11/argparse.py:1387)"},{"pid":131246,"tid":131246,"ts":1234080174852.756,"ph":"X","cat":"fee","dur":1.05,"name":"_ActionsContainer._pop_action_class (/home/ma-user/anaconda3/envs/py311/lib/python3.11/argparse.py:1587)"},{"pid":131246,"tid":131246,"ts":1234080174853.946,"ph":"X","cat":"fee","dur":0.07,"name":"builtins.callable"},{"pid":131246,"tid":131246,"ts":1234080174855.166,"ph":"X","cat":"fee","dur":0.43,"name":"Action.__init__ (/home/ma-user/anaconda3/envs/py311/lib/python3.11/argparse.py:834)"},{"pid":131246,"tid":131246,"ts":1234080174854.566,"ph":"X","cat":"fee","dur":1.16,"name":"_StoreAction.__init__ (/home/ma-user/anaconda3/envs/py311/lib/python3.11/argparse.py:919)"},{"pid":131246,"tid":131246,"ts":1234080174856.296,"ph":"X","cat":"fee","dur":0.08,"name":"dict.get"},{"pid":131246,"tid":131246,"ts":1234080174856.106,"ph":"X","cat":"fee","dur":0.38,"name":"_ActionsContainer._registry_get (/home/ma-user/anaconda3/envs/py311/lib/python3.11/argparse.py:1387)"},{"pid":131246,"tid":131246,"ts":1234080174856.636,"ph":"X","cat":"fee","dur":0.06,"name":"builtins.callable"},{"pid":131246,"tid":131246,"ts":1234080174856.856,"ph":"X","cat":"fee","dur":0.15,"name":"builtins.hasattr"},{"pid":131246,"tid":131246,"ts":1234080174862.606,"ph":"X","cat":"fee","dur":0.16,"name":"_io.TextIOWrapper.fileno"},{"pid":131246,"tid":131246,"ts":1234080174862.866,"ph":"X","cat":"fee","dur":0.59,"name":"posix.get_terminal_size"},{"pid":131246,"tid":131246,"ts":1234080174858.196,"ph":"X","cat":"fee","dur":5.91,"name":"get_terminal_size (/home/ma-user/anaconda3/envs/py311/lib/python3.11/shutil.py:1386)"},{"pid":131246,"tid":131246,"ts":1234080174864.676,"ph":"X","cat":"fee","dur":0.32,"name":"builtins.max"},{"pid":131246,"tid":131246,"ts":1234080174865.076,"ph":"X","cat":"fee","dur":0.19,"name":"builtins.min"},{"pid":131246,"tid":131246,"ts":1234080174865.856,"ph":"X","cat":"fee","dur":0.3,"name":"HelpFormatter._Section.__init__ (/home/ma-user/anaconda3/envs/py311/lib/python3.11/argparse.py:206)"},{"pid":131246,"tid":131246,"ts":1234080174866.986,"ph":"X","cat":"fee","dur":0.09,"name":"builtins.isinstance"},{"pid":131246,"tid":131246,"ts":1234080174867.576,"ph":"X","cat":"fee","dur":0.12,"name":"Enum.value (/home/ma-user/anaconda3/envs/py311/lib/python3.11/enum.py:1226)"},{"pid":131246,"tid":131246,"ts":1234080174867.326,"ph":"X","cat":"fee","dur":1.41,"name":"property.__get__ (/home/ma-user/anaconda3/envs/py311/lib/python3.11/enum.py:188)"},{"pid":131246,"tid":131246,"ts":1234080174866.866,"ph":"X","cat":"fee","dur":2.35,"name":"_compile (/home/ma-user/anaconda3/envs/py311/lib/python3.11/re/__init__.py:272)"},{"pid":131246,"tid":131246,"ts":1234080174866.636,"ph":"X","cat":"fee","dur":2.69,"name":"compile (/home/ma-user/anaconda3/envs/py311/lib/python3.11/re/__init__.py:225)"},{"pid":131246,"tid":131246,"ts":1234080174869.996,"ph":"X","cat":"fee","dur":0.22,"name":"builtins.isinstance"},{"pid":131246,"tid":131246,"ts":1234080174869.866,"ph":"X","cat":"fee","dur":0.63,"name":"_compile (/home/ma-user/anaconda3/envs/py311/lib/python3.11/re/__init__.py:272)"},{"pid":131246,"tid":131246,"ts":1234080174869.666,"ph":"X","cat":"fee","dur":0.93,"name":"compile (/home/ma-user/anaconda3/envs/py311/lib/python3.11/re/__init__.py:225)"},{"pid":131246,"tid":131246,"ts":1234080174857.746,"ph":"X","cat":"fee","dur":13.02,"name":"HelpFormatter.__init__ (/home/ma-user/anaconda3/envs/py311/lib/python3.11/argparse.py:164)"},{"pid":131246,"tid":131246,"ts":1234080174857.206,"ph":"X","cat":"fee","dur":13.81,"name":"ArgumentParser._get_formatter (/home/ma-user/anaconda3/envs/py311/lib/python3.11/argparse.py:2576)"},{"pid":131246,"tid":131246,"ts":1234080174871.476,"ph":"X","cat":"fee","dur":0.37,"name":"HelpFormatter._metavar_formatter (/home/ma-user/anaconda3/envs/py311/lib/python3.11/argparse.py:578)"},{"pid":131246,"tid":131246,"ts":1234080174872.346,"ph":"X","cat":"fee","dur":0.1,"name":"builtins.isinstance"},{"pid":131246,"tid":131246,"ts":1234080174872.176,"ph":"X","cat":"fee","dur":0.46,"name":"HelpFormatter._metavar_formatter.<locals>.format (/home/ma-user/anaconda3/envs/py311/lib/python3.11/argparse.py:587)"},{"pid":131246,"tid":131246,"ts":1234080174871.256,"ph":"X","cat":"fee","dur":1.81,"name":"HelpFormatter._format_args (/home/ma-user/anaconda3/envs/py311/lib/python3.11/argparse.py:594)"},{"pid":131246,"tid":131246,"ts":1234080174874.356,"ph":"X","cat":"fee","dur":0.38,"name":"_ActionsContainer._check_conflict (/home/ma-user/anaconda3/envs/py311/lib/python3.11/argparse.py:1600)"},{"pid":131246,"tid":131246,"ts":1234080174874.996,"ph":"X","cat":"fee","dur":0.14,"name":"list.append"},{"pid":131246,"tid":131246,"ts":1234080174875.776,"ph":"X","cat":"fee","dur":0.36,"name":"re.Pattern.match"},{"pid":131246,"tid":131246,"ts":1234080174874.166,"ph":"X","cat":"fee","dur":2.13,"name":"_ActionsContainer._add_action (/home/ma-user/anaconda3/envs/py311/lib/python3.11/argparse.py:1473)"},{"pid":131246,"tid":131246,"ts":1234080174876.516,"ph":"X","cat":"fee","dur":0.1,"name":"list.append"},{"pid":131246,"tid":131246,"ts":1234080174873.686,"ph":"X","cat":"fee","dur":3.03,"name":"_ArgumentGroup._add_action (/home/ma-user/anaconda3/envs/py311/lib/python3.11/argparse.py:1662)"},{"pid":131246,"tid":131246,"ts":1234080174873.416,"ph":"X","cat":"fee","dur":3.44,"name":"ArgumentParser._add_action (/home/ma-user/anaconda3/envs/py311/lib/python3.11/argparse.py:1841)"},{"pid":131246,"tid":131246,"ts":1234080174847.786,"ph":"X","cat":"fee","dur":29.18,"name":"_ActionsContainer.add_argument (/home/ma-user/anaconda3/envs/py311/lib/python3.11/argparse.py:1412)"},{"pid":131246,"tid":131246,"ts":1234080174877.856,"ph":"X","cat":"fee","dur":0.1,"name":"builtins.len"},{"pid":131246,"tid":131246,"ts":1234080174879.096,"ph":"X","cat":"fee","dur":0.07,"name":"list.append"},{"pid":131246,"tid":131246,"ts":1234080174879.316,"ph":"X","cat":"fee","dur":0.09,"name":"builtins.len"},{"pid":131246,"tid":131246,"ts":1234080174879.626,"ph":"X","cat":"fee","dur":0.06,"name":"list.append"},{"pid":131246,"tid":131246,"ts":1234080174879.876,"ph":"X","cat":"fee","dur":0.11,"name":"dict.pop"},{"pid":131246,"tid":131246,"ts":1234080174880.276,"ph":"X","cat":"fee","dur":0.17,"name":"str.lstrip"},{"pid":131246,"tid":131246,"ts":1234080174880.616,"ph":"X","cat":"fee","dur":0.14,"name":"str.replace"},{"pid":131246,"tid":131246,"ts":1234080174878.746,"ph":"X","cat":"fee","dur":2.35,"name":"_ActionsContainer._get_optional_kwargs (/home/ma-user/anaconda3/envs/py311/lib/python3.11/argparse.py:1553)"},{"pid":131246,"tid":131246,"ts":1234080174881.786,"ph":"X","cat":"fee","dur":0.07,"name":"dict.pop"},{"pid":131246,"tid":131246,"ts":1234080174882.276,"ph":"X","cat":"fee","dur":0.09,"name":"dict.get"},{"pid":131246,"tid":131246,"ts":1234080174882.086,"ph":"X","cat":"fee","dur":0.4,"name":"_ActionsContainer._registry_get (/home/ma-user/anaconda3/envs/py311/lib/python3.11/argparse.py:1387)"},{"pid":131246,"tid":131246,"ts":1234080174881.626,"ph":"X","cat":"fee","dur":0.99,"name":"_ActionsContainer._pop_action_class (/home/ma-user/anaconda3/envs/py311/lib/python3.11/argparse.py:1587)"},{"pid":131246,"tid":131246,"ts":1234080174882.776,"ph":"X","cat":"fee","dur":0.07,"name":"builtins.callable"},{"pid":131246,"tid":131246,"ts":1234080174884.016,"ph":"X","cat":"fee","dur":0.42,"name":"Action.__init__ (/home/ma-user/anaconda3/envs/py311/lib/python3.11/argparse.py:834)"},{"pid":131246,"tid":131246,"ts":1234080174883.416,"ph":"X","cat":"fee","dur":1.14,"name":"_StoreAction.__init__ (/home/ma-user/anaconda3/envs/py311/lib/python3.11/argparse.py:919)"},{"pid":131246,"tid":131246,"ts":1234080174885.126,"ph":"X","cat":"fee","dur":0.07,"name":"dict.get"},{"pid":131246,"tid":131246,"ts":1234080174884.926,"ph":"X","cat":"fee","dur":0.38,"name":"_ActionsContainer._registry_get (/home/ma-user/anaconda3/envs/py311/lib/python3.11/argparse.py:1387)"},{"pid":131246,"tid":131246,"ts":1234080174885.466,"ph":"X","cat":"fee","dur":0.06,"name":"builtins.callable"},{"pid":131246,"tid":131246,"ts":1234080174885.696,"ph":"X","cat":"fee","dur":0.14,"name":"builtins.hasattr"},{"pid":131246,"tid":131246,"ts":1234080174891.406,"ph":"X","cat":"fee","dur":0.16,"name":"_io.TextIOWrapper.fileno"},{"pid":131246,"tid":131246,"ts":1234080174891.656,"ph":"X","cat":"fee","dur":0.56,"name":"posix.get_terminal_size"},{"pid":131246,"tid":131246,"ts":1234080174886.996,"ph":"X","cat":"fee","dur":5.84,"name":"get_terminal_size (/home/ma-user/anaconda3/envs/py311/lib/python3.11/shutil.py:1386)"},{"pid":131246,"tid":131246,"ts":1234080174893.406,"ph":"X","cat":"fee","dur":0.3,"name":"builtins.max"},{"pid":131246,"tid":131246,"ts":1234080174893.786,"ph":"X","cat":"fee","dur":0.19,"name":"builtins.min"},{"pid":131246,"tid":131246,"ts":1234080174894.596,"ph":"X","cat":"fee","dur":0.34,"name":"HelpFormatter._Section.__init__ (/home/ma-user/anaconda3/envs/py311/lib/python3.11/argparse.py:206)"},{"pid":131246,"tid":131246,"ts":1234080174895.746,"ph":"X","cat":"fee","dur":0.09,"name":"builtins.isinstance"},{"pid":131246,"tid":131246,"ts":1234080174898.806,"ph":"X","cat":"fee","dur":0.12,"name":"Enum.value (/home/ma-user/anaconda3/envs/py311/lib/python3.11/enum.py:1226)"},{"pid":131246,"tid":131246,"ts":1234080174898.536,"ph":"X","cat":"fee","dur":0.54,"name":"property.__get__ (/home/ma-user/anaconda3/envs/py311/lib/python3.11/enum.py:188)"},{"pid":131246,"tid":131246,"ts":1234080174895.616,"ph":"X","cat":"fee","dur":3.89,"name":"_compile (/home/ma-user/anaconda3/envs/py311/lib/python3.11/re/__init__.py:272)"},{"pid":131246,"tid":131246,"ts":1234080174895.416,"ph":"X","cat":"fee","dur":4.2,"name":"compile (/home/ma-user/anaconda3/envs/py311/lib/python3.11/re/__init__.py:225)"},{"pid":131246,"tid":131246,"ts":1234080174900.246,"ph":"X","cat":"fee","dur":0.25,"name":"builtins.isinstance"},{"pid":131246,"tid":131246,"ts":1234080174900.126,"ph":"X","cat":"fee","dur":0.64,"name":"_compile (/home/ma-user/anaconda3/envs/py311/lib/python3.11/re/__init__.py:272)"},{"pid":131246,"tid":131246,"ts":1234080174899.936,"ph":"X","cat":"fee","dur":0.94,"name":"compile (/home/ma-user/anaconda3/envs/py311/lib/python3.11/re/__init__.py:225)"},{"pid":131246,"tid":131246,"ts":1234080174886.556,"ph":"X","cat":"fee","dur":14.49,"name":"HelpFormatter.__init__ (/home/ma-user/anaconda3/envs/py311/lib/python3.11/argparse.py:164)"},{"pid":131246,"tid":131246,"ts":1234080174886.026,"ph":"X","cat":"fee","dur":15.26,"name":"ArgumentParser._get_formatter (/home/ma-user/anaconda3/envs/py311/lib/python3.11/argparse.py:2576)"},{"pid":131246,"tid":131246,"ts":1234080174901.766,"ph":"X","cat":"fee","dur":0.32,"name":"HelpFormatter._metavar_formatter (/home/ma-user/anaconda3/envs/py311/lib/python3.11/argparse.py:578)"},{"pid":131246,"tid":131246,"ts":1234080174902.586,"ph":"X","cat":"fee","dur":0.1,"name":"builtins.isinstance"},{"pid":131246,"tid":131246,"ts":1234080174902.416,"ph":"X","cat":"fee","dur":0.45,"name":"HelpFormatter._metavar_formatter.<locals>.format (/home/ma-user/anaconda3/envs/py311/lib/python3.11/argparse.py:587)"},{"pid":131246,"tid":131246,"ts":1234080174901.536,"ph":"X","cat":"fee","dur":1.77,"name":"HelpFormatter._format_args (/home/ma-user/anaconda3/envs/py311/lib/python3.11/argparse.py:594)"},{"pid":131246,"tid":131246,"ts":1234080174904.636,"ph":"X","cat":"fee","dur":0.4,"name":"_ActionsContainer._check_conflict (/home/ma-user/anaconda3/envs/py311/lib/python3.11/argparse.py:1600)"},{"pid":131246,"tid":131246,"ts":1234080174905.316,"ph":"X","cat":"fee","dur":0.08,"name":"list.append"},{"pid":131246,"tid":131246,"ts":1234080174905.996,"ph":"X","cat":"fee","dur":0.39,"name":"re.Pattern.match"},{"pid":131246,"tid":131246,"ts":1234080174904.466,"ph":"X","cat":"fee","dur":2.07,"name":"_ActionsContainer._add_action (/home/ma-user/anaconda3/envs/py311/lib/python3.11/argparse.py:1473)"},{"pid":131246,"tid":131246,"ts":1234080174906.756,"ph":"X","cat":"fee","dur":0.07,"name":"list.append"},{"pid":131246,"tid":131246,"ts":1234080174904.006,"ph":"X","cat":"fee","dur":2.93,"name":"_ArgumentGroup._add_action (/home/ma-user/anaconda3/envs/py311/lib/python3.11/argparse.py:1662)"},{"pid":131246,"tid":131246,"ts":1234080174903.706,"ph":"X","cat":"fee","dur":3.35,"name":"ArgumentParser._add_action (/home/ma-user/anaconda3/envs/py311/lib/python3.11/argparse.py:1841)"},{"pid":131246,"tid":131246,"ts":1234080174877.676,"ph":"X","cat":"fee","dur":29.5,"name":"_ActionsContainer.add_argument (/home/ma-user/anaconda3/envs/py311/lib/python3.11/argparse.py:1412)"},{"pid":131246,"tid":131246,"ts":1234080174915.336,"ph":"X","cat":"fee","dur":0.24,"name":"Namespace.__init__ (/home/ma-user/anaconda3/envs/py311/lib/python3.11/argparse.py:1315)"},{"pid":131246,"tid":131246,"ts":1234080174916.226,"ph":"X","cat":"fee","dur":0.46,"name":"builtins.hasattr"},{"pid":131246,"tid":131246,"ts":1234080174917.226,"ph":"X","cat":"fee","dur":0.26,"name":"builtins.hasattr"},{"pid":131246,"tid":131246,"ts":1234080174917.916,"ph":"X","cat":"fee","dur":0.68,"name":"builtins.setattr"},{"pid":131246,"tid":131246,"ts":1234080174918.877,"ph":"X","cat":"fee","dur":0.25,"name":"builtins.hasattr"},{"pid":131246,"tid":131246,"ts":1234080174919.387,"ph":"X","cat":"fee","dur":0.62,"name":"builtins.setattr"},{"pid":131246,"tid":131246,"ts":1234080174920.257,"ph":"X","cat":"fee","dur":0.19,"name":"builtins.hasattr"},{"pid":131246,"tid":131246,"ts":1234080174920.687,"ph":"X","cat":"fee","dur":0.33,"name":"builtins.setattr"},{"pid":131246,"tid":131246,"ts":1234080174921.247,"ph":"X","cat":"fee","dur":0.18,"name":"builtins.hasattr"},{"pid":131246,"tid":131246,"ts":1234080174921.667,"ph":"X","cat":"fee","dur":0.28,"name":"builtins.setattr"},{"pid":131246,"tid":131246,"ts":1234080174922.147,"ph":"X","cat":"fee","dur":0.27,"name":"builtins.hasattr"},{"pid":131246,"tid":131246,"ts":1234080174922.627,"ph":"X","cat":"fee","dur":0.32,"name":"builtins.setattr"},{"pid":131246,"tid":131246,"ts":1234080174923.177,"ph":"X","cat":"fee","dur":0.21,"name":"builtins.hasattr"},{"pid":131246,"tid":131246,"ts":1234080174923.597,"ph":"X","cat":"fee","dur":0.43,"name":"builtins.setattr"},{"pid":131246,"tid":131246,"ts":1234080174924.247,"ph":"X","cat":"fee","dur":0.23,"name":"builtins.hasattr"},{"pid":131246,"tid":131246,"ts":1234080174924.687,"ph":"X","cat":"fee","dur":0.53,"name":"builtins.setattr"},{"pid":131246,"tid":131246,"ts":1234080174925.457,"ph":"X","cat":"fee","dur":0.25,"name":"builtins.hasattr"},{"pid":131246,"tid":131246,"ts":1234080174925.927,"ph":"X","cat":"fee","dur":0.42,"name":"builtins.setattr"},{"pid":131246,"tid":131246,"ts":1234080174926.557,"ph":"X","cat":"fee","dur":0.22,"name":"builtins.hasattr"},{"pid":131246,"tid":131246,"ts":1234080174926.987,"ph":"X","cat":"fee","dur":0.32,"name":"builtins.setattr"},{"pid":131246,"tid":131246,"ts":1234080174927.527,"ph":"X","cat":"fee","dur":0.22,"name":"builtins.hasattr"},{"pid":131246,"tid":131246,"ts":1234080174927.977,"ph":"X","cat":"fee","dur":0.36,"name":"builtins.setattr"},{"pid":131246,"tid":131246,"ts":1234080174928.547,"ph":"X","cat":"fee","dur":0.21,"name":"builtins.hasattr"},{"pid":131246,"tid":131246,"ts":1234080174928.957,"ph":"X","cat":"fee","dur":0.69,"name":"builtins.setattr"},{"pid":131246,"tid":131246,"ts":1234080174929.857,"ph":"X","cat":"fee","dur":0.42,"name":"builtins.hasattr"},{"pid":131246,"tid":131246,"ts":1234080174930.477,"ph":"X","cat":"fee","dur":0.51,"name":"builtins.setattr"},{"pid":131246,"tid":131246,"ts":1234080174932.137,"ph":"X","cat":"fee","dur":0.28,"name":"builtins.hasattr"},{"pid":131246,"tid":131246,"ts":1234080174932.637,"ph":"X","cat":"fee","dur":0.33,"name":"builtins.setattr"},{"pid":131246,"tid":131246,"ts":1234080174933.177,"ph":"X","cat":"fee","dur":0.24,"name":"builtins.hasattr"},{"pid":131246,"tid":131246,"ts":1234080174933.627,"ph":"X","cat":"fee","dur":0.33,"name":"builtins.setattr"},{"pid":131246,"tid":131246,"ts":1234080174934.167,"ph":"X","cat":"fee","dur":0.26,"name":"builtins.hasattr"},{"pid":131246,"tid":131246,"ts":1234080174934.627,"ph":"X","cat":"fee","dur":0.36,"name":"builtins.setattr"},{"pid":131246,"tid":131246,"ts":1234080174935.197,"ph":"X","cat":"fee","dur":0.22,"name":"builtins.hasattr"},{"pid":131246,"tid":131246,"ts":1234080174935.617,"ph":"X","cat":"fee","dur":0.91,"name":"builtins.setattr"},{"pid":131246,"tid":131246,"ts":1234080174936.727,"ph":"X","cat":"fee","dur":0.22,"name":"builtins.hasattr"},{"pid":131246,"tid":131246,"ts":1234080174937.147,"ph":"X","cat":"fee","dur":0.28,"name":"builtins.setattr"},{"pid":131246,"tid":131246,"ts":1234080174950.297,"ph":"X","cat":"fee","dur":0.12,"name":"builtins.iter"},{"pid":131246,"tid":131246,"ts":1234080174955.307,"ph":"X","cat":"fee","dur":0.71,"name":"ArgumentParser._parse_optional (/home/ma-user/anaconda3/envs/py311/lib/python3.11/argparse.py:2218)"},{"pid":131246,"tid":131246,"ts":1234080174956.537,"ph":"X","cat":"fee","dur":0.08,"name":"list.append"},{"pid":131246,"tid":131246,"ts":1234080174957.137,"ph":"X","cat":"fee","dur":0.27,"name":"ArgumentParser._parse_optional (/home/ma-user/anaconda3/envs/py311/lib/python3.11/argparse.py:2218)"},{"pid":131246,"tid":131246,"ts":1234080174957.677,"ph":"X","cat":"fee","dur":0.07,"name":"list.append"},{"pid":131246,"tid":131246,"ts":1234080174958.167,"ph":"X","cat":"fee","dur":0.47,"name":"ArgumentParser._parse_optional (/home/ma-user/anaconda3/envs/py311/lib/python3.11/argparse.py:2218)"},{"pid":131246,"tid":131246,"ts":1234080174959.007,"ph":"X","cat":"fee","dur":0.07,"name":"list.append"},{"pid":131246,"tid":131246,"ts":1234080174959.447,"ph":"X","cat":"fee","dur":0.23,"name":"ArgumentParser._parse_optional (/home/ma-user/anaconda3/envs/py311/lib/python3.11/argparse.py:2218)"},{"pid":131246,"tid":131246,"ts":1234080174959.897,"ph":"X","cat":"fee","dur":0.06,"name":"list.append"},{"pid":131246,"tid":131246,"ts":1234080174960.287,"ph":"X","cat":"fee","dur":0.49,"name":"ArgumentParser._parse_optional (/home/ma-user/anaconda3/envs/py311/lib/python3.11/argparse.py:2218)"},{"pid":131246,"tid":131246,"ts":1234080174961.087,"ph":"X","cat":"fee","dur":0.11,"name":"list.append"},{"pid":131246,"tid":131246,"ts":1234080174961.517,"ph":"X","cat":"fee","dur":0.22,"name":"ArgumentParser._parse_optional (/home/ma-user/anaconda3/envs/py311/lib/python3.11/argparse.py:2218)"},{"pid":131246,"tid":131246,"ts":1234080174961.957,"ph":"X","cat":"fee","dur":0.06,"name":"list.append"},{"pid":131246,"tid":131246,"ts":1234080174962.337,"ph":"X","cat":"fee","dur":0.45,"name":"ArgumentParser._parse_optional (/home/ma-user/anaconda3/envs/py311/lib/python3.11/argparse.py:2218)"},{"pid":131246,"tid":131246,"ts":1234080174963.037,"ph":"X","cat":"fee","dur":0.05,"name":"list.append"},{"pid":131246,"tid":131246,"ts":1234080174963.387,"ph":"X","cat":"fee","dur":0.17,"name":"ArgumentParser._parse_optional (/home/ma-user/anaconda3/envs/py311/lib/python3.11/argparse.py:2218)"},{"pid":131246,"tid":131246,"ts":1234080174963.747,"ph":"X","cat":"fee","dur":0.04,"name":"list.append"},{"pid":131246,"tid":131246,"ts":1234080174964.107,"ph":"X","cat":"fee","dur":0.4,"name":"ArgumentParser._parse_optional (/home/ma-user/anaconda3/envs/py311/lib/python3.11/argparse.py:2218)"},{"pid":131246,"tid":131246,"ts":1234080174964.787,"ph":"X","cat":"fee","dur":0.1,"name":"list.append"},{"pid":131246,"tid":131246,"ts":1234080174965.187,"ph":"X","cat":"fee","dur":0.25,"name":"ArgumentParser._parse_optional (/home/ma-user/anaconda3/envs/py311/lib/python3.11/argparse.py:2218)"},{"pid":131246,"tid":131246,"ts":1234080174965.647,"ph":"X","cat":"fee","dur":0.04,"name":"list.append"},{"pid":131246,"tid":131246,"ts":1234080174965.987,"ph":"X","cat":"fee","dur":0.45,"name":"ArgumentParser._parse_optional (/home/ma-user/anaconda3/envs/py311/lib/python3.11/argparse.py:2218)"},{"pid":131246,"tid":131246,"ts":1234080174966.797,"ph":"X","cat":"fee","dur":0.05,"name":"list.append"},{"pid":131246,"tid":131246,"ts":1234080174967.167,"ph":"X","cat":"fee","dur":0.17,"name":"ArgumentParser._parse_optional (/home/ma-user/anaconda3/envs/py311/lib/python3.11/argparse.py:2218)"},{"pid":131246,"tid":131246,"ts":1234080174967.527,"ph":"X","cat":"fee","dur":0.05,"name":"list.append"},{"pid":131246,"tid":131246,"ts":1234080174968.197,"ph":"X","cat":"fee","dur":0.09,"name":"builtins.len"},{"pid":131246,"tid":131246,"ts":1234080174968.627,"ph":"X","cat":"fee","dur":0.34,"name":"str.split"},{"pid":131246,"tid":131246,"ts":1234080174967.877,"ph":"X","cat":"fee","dur":1.66,"name":"ArgumentParser._parse_optional (/home/ma-user/anaconda3/envs/py311/lib/python3.11/argparse.py:2218)"},{"pid":131246,"tid":131246,"ts":1234080174969.877,"ph":"X","cat":"fee","dur":0.07,"name":"list.append"},{"pid":131246,"tid":131246,"ts":1234080174970.287,"ph":"X","cat":"fee","dur":0.39,"name":"ArgumentParser._parse_optional (/home/ma-user/anaconda3/envs/py311/lib/python3.11/argparse.py:2218)"},{"pid":131246,"tid":131246,"ts":1234080174970.947,"ph":"X","cat":"fee","dur":0.05,"name":"list.append"},{"pid":131246,"tid":131246,"ts":1234080174971.307,"ph":"X","cat":"fee","dur":0.18,"name":"ArgumentParser._parse_optional (/home/ma-user/anaconda3/envs/py311/lib/python3.11/argparse.py:2218)"},{"pid":131246,"tid":131246,"ts":1234080174971.687,"ph":"X","cat":"fee","dur":0.04,"name":"list.append"},{"pid":131246,"tid":131246,"ts":1234080174972.047,"ph":"X","cat":"fee","dur":0.34,"name":"ArgumentParser._parse_optional (/home/ma-user/anaconda3/envs/py311/lib/python3.11/argparse.py:2218)"},{"pid":131246,"tid":131246,"ts":1234080174972.637,"ph":"X","cat":"fee","dur":0.04,"name":"list.append"},{"pid":131246,"tid":131246,"ts":1234080174972.977,"ph":"X","cat":"fee","dur":0.17,"name":"ArgumentParser._parse_optional (/home/ma-user/anaconda3/envs/py311/lib/python3.11/argparse.py:2218)"},{"pid":131246,"tid":131246,"ts":1234080174973.317,"ph":"X","cat":"fee","dur":0.1,"name":"list.append"},{"pid":131246,"tid":131246,"ts":1234080174974.867,"ph":"X","cat":"fee","dur":0.28,"name":"str.join"},{"pid":131246,"tid":131246,"ts":1234080174978.057,"ph":"X","cat":"fee","dur":1.06,"name":"ArgumentParser._get_positional_actions.<locals>.<listcomp> (/home/ma-user/anaconda3/envs/py311/lib/python3.11/argparse.py:1854)"},{"pid":131246,"tid":131246,"ts":1234080174977.217,"ph":"X","cat":"fee","dur":2.08,"name":"ArgumentParser._get_positional_actions (/home/ma-user/anaconda3/envs/py311/lib/python3.11/argparse.py:1853)"},{"pid":131246,"tid":131246,"ts":1234080174979.937,"ph":"X","cat":"fee","dur":0.68,"name":"builtins.max"},{"pid":131246,"tid":131246,"ts":1234080174981.677,"ph":"X","cat":"fee","dur":1.15,"name":"ArgumentParser._parse_known_args.<locals>.<listcomp> (/home/ma-user/anaconda3/envs/py311/lib/python3.11/argparse.py:2080)"},{"pid":131246,"tid":131246,"ts":1234080174983.037,"ph":"X","cat":"fee","dur":0.44,"name":"builtins.min"},{"pid":131246,"tid":131246,"ts":1234080174994.877,"ph":"X","cat":"fee","dur":0.4,"name":"str.replace"},{"pid":131246,"tid":131246,"ts":1234080174995.517,"ph":"X","cat":"fee","dur":0.1,"name":"str.replace"},{"pid":131246,"tid":131246,"ts":1234080174994.427,"ph":"X","cat":"fee","dur":1.3,"name":"ArgumentParser._get_nargs_pattern (/home/ma-user/anaconda3/envs/py311/lib/python3.11/argparse.py:2321)"},{"pid":131246,"tid":131246,"ts":1234080174996.997,"ph":"X","cat":"fee","dur":0.24,"name":"builtins.isinstance"},{"pid":131246,"tid":131246,"ts":1234080174998.307,"ph":"X","cat":"fee","dur":0.1,"name":"builtins.isinstance"},{"pid":131246,"tid":131246,"ts":1234080174999.267,"ph":"X","cat":"fee","dur":0.35,"name":"builtins.isinstance"},{"pid":131246,"tid":131246,"ts":1234080174998.997,"ph":"X","cat":"fee","dur":0.73,"name":"isstring (/home/ma-user/anaconda3/envs/py311/lib/python3.11/re/_compiler.py:568)"},{"pid":131246,"tid":131246,"ts":1234080175000.757,"ph":"X","cat":"fee","dur":0.2,"name":"builtins.isinstance"},{"pid":131246,"tid":131246,"ts":1234080175001.397,"ph":"X","cat":"fee","dur":0.06,"name":"builtins.isinstance"},{"pid":131246,"tid":131246,"ts":1234080175003.177,"ph":"X","cat":"fee","dur":0.58,"name":"Enum.__new__ (/home/ma-user/anaconda3/envs/py311/lib/python3.11/enum.py:1074)"},{"pid":131246,"tid":131246,"ts":1234080175002.357,"ph":"X","cat":"fee","dur":1.54,"name":"EnumType.__call__ (/home/ma-user/anaconda3/envs/py311/lib/python3.11/enum.py:669)"},{"pid":131246,"tid":131246,"ts":1234080175000.387,"ph":"X","cat":"fee","dur":3.69,"name":"Flag.__and__ (/home/ma-user/anaconda3/envs/py311/lib/python3.11/enum.py:1483)"},{"pid":131246,"tid":131246,"ts":1234080175005.047,"ph":"X","cat":"fee","dur":0.07,"name":"builtins.isinstance"},{"pid":131246,"tid":131246,"ts":1234080175004.797,"ph":"X","cat":"fee","dur":0.42,"name":"isstring (/home/ma-user/anaconda3/envs/py311/lib/python3.11/re/_compiler.py:568)"},{"pid":131246,"tid":131246,"ts":1234080175006.647,"ph":"X","cat":"fee","dur":0.08,"name":"builtins.isinstance"},{"pid":131246,"tid":131246,"ts":1234080175007.567,"ph":"X","cat":"fee","dur":0.67,"name":"Tokenizer.__next (/home/ma-user/anaconda3/envs/py311/lib/python3.11/re/_parser.py:231)"},{"pid":131246,"tid":131246,"ts":1234080175006.347,"ph":"X","cat":"fee","dur":2.03,"name":"Tokenizer.__init__ (/home/ma-user/anaconda3/envs/py311/lib/python3.11/re/_parser.py:222)"},{"pid":131246,"tid":131246,"ts":1234080175009.107,"ph":"X","cat":"fee","dur":0.56,"name":"State.__init__ (/home/ma-user/anaconda3/envs/py311/lib/python3.11/re/_parser.py:73)"},{"pid":131246,"tid":131246,"ts":1234080175011.627,"ph":"X","cat":"fee","dur":0.11,"name":"builtins.len"},{"pid":131246,"tid":131246,"ts":1234080175011.237,"ph":"X","cat":"fee","dur":0.63,"name":"Tokenizer.tell (/home/ma-user/anaconda3/envs/py311/lib/python3.11/re/_parser.py:284)"},{"pid":131246,"tid":131246,"ts":1234080175013.197,"ph":"X","cat":"fee","dur":0.42,"name":"SubPattern.__init__ (/home/ma-user/anaconda3/envs/py311/lib/python3.11/re/_parser.py:109)"},{"pid":131246,"tid":131246,"ts":1234080175014.857,"ph":"X","cat":"fee","dur":0.42,"name":"Tokenizer.__next (/home/ma-user/anaconda3/envs/py311/lib/python3.11/re/_parser.py:231)"},{"pid":131246,"tid":131246,"ts":1234080175014.537,"ph":"X","cat":"fee","dur":0.91,"name":"Tokenizer.get (/home/ma-user/anaconda3/envs/py311/lib/python3.11/re/_parser.py:252)"},{"pid":131246,"tid":131246,"ts":1234080175016.787,"ph":"X","cat":"fee","dur":0.09,"name":"builtins.len"},{"pid":131246,"tid":131246,"ts":1234080175016.567,"ph":"X","cat":"fee","dur":0.4,"name":"Tokenizer.tell (/home/ma-user/anaconda3/envs/py311/lib/python3.11/re/_parser.py:284)"},{"pid":131246,"tid":131246,"ts":1234080175017.397,"ph":"X","cat":"fee","dur":0.19,"name":"Tokenizer.match (/home/ma-user/anaconda3/envs/py311/lib/python3.11/re/_parser.py:247)"},{"pid":131246,"tid":131246,"ts":1234080175018.977,"ph":"X","cat":"fee","dur":0.08,"name":"builtins.len"},{"pid":131246,"tid":131246,"ts":1234080175018.717,"ph":"X","cat":"fee","dur":0.43,"name":"State.groups (/home/ma-user/anaconda3/envs/py311/lib/python3.11/re/_parser.py:79)"},{"pid":131246,"tid":131246,"ts":1234080175019.447,"ph":"X","cat":"fee","dur":0.12,"name":"list.append"},{"pid":131246,"tid":131246,"ts":1234080175019.967,"ph":"X","cat":"fee","dur":0.07,"name":"builtins.len"},{"pid":131246,"tid":131246,"ts":1234080175019.807,"ph":"X","cat":"fee","dur":0.29,"name":"State.groups (/home/ma-user/anaconda3/envs/py311/lib/python3.11/re/_parser.py:79)"},{"pid":131246,"tid":131246,"ts":1234080175018.187,"ph":"X","cat":"fee","dur":2.33,"name":"State.opengroup (/home/ma-user/anaconda3/envs/py311/lib/python3.11/re/_parser.py:82)"},{"pid":131246,"tid":131246,"ts":1234080175021.717,"ph":"X","cat":"fee","dur":0.08,"name":"builtins.len"},{"pid":131246,"tid":131246,"ts":1234080175021.537,"ph":"X","cat":"fee","dur":0.36,"name":"Tokenizer.tell (/home/ma-user/anaconda3/envs/py311/lib/python3.11/re/_parser.py:284)"},{"pid":131246,"tid":131246,"ts":1234080175022.717,"ph":"X","cat":"fee","dur":0.251,"name":"SubPattern.__init__ (/home/ma-user/anaconda3/envs/py311/lib/python3.11/re/_parser.py:109)"},{"pid":131246,"tid":131246,"ts":1234080175023.928,"ph":"X","cat":"fee","dur":0.36,"name":"Tokenizer.__next (/home/ma-user/anaconda3/envs/py311/lib/python3.11/re/_parser.py:231)"},{"pid":131246,"tid":131246,"ts":1234080175023.638,"ph":"X","cat":"fee","dur":0.78,"name":"Tokenizer.get (/home/ma-user/anaconda3/envs/py311/lib/python3.11/re/_parser.py:252)"},{"pid":131246,"tid":131246,"ts":1234080175024.938,"ph":"X","cat":"fee","dur":0.16,"name":"builtins.ord"},{"pid":131246,"tid":131246,"ts":1234080175025.578,"ph":"X","cat":"fee","dur":0.07,"name":"list.append"},{"pid":131246,"tid":131246,"ts":1234080175025.358,"ph":"X","cat":"fee","dur":0.4,"name":"SubPattern.append (/home/ma-user/anaconda3/envs/py311/lib/python3.11/re/_parser.py:170)"},{"pid":131246,"tid":131246,"ts":1234080175027.818,"ph":"X","cat":"fee","dur":0.07,"name":"builtins.len"},{"pid":131246,"tid":131246,"ts":1234080175027.628,"ph":"X","cat":"fee","dur":0.34,"name":"SubPattern.__len__ (/home/ma-user/anaconda3/envs/py311/lib/python3.11/re/_parser.py:158)"},{"pid":131246,"tid":131246,"ts":1234080175027.298,"ph":"X","cat":"fee","dur":0.82,"name":"builtins.len"},{"pid":131246,"tid":131246,"ts":1234080175029.798,"ph":"X","cat":"fee","dur":0.15,"name":"builtins.isinstance"},{"pid":131246,"tid":131246,"ts":1234080175029.528,"ph":"X","cat":"fee","dur":0.62,"name":"SubPattern.__getitem__ (/home/ma-user/anaconda3/envs/py311/lib/python3.11/re/_parser.py:162)"},{"pid":131246,"tid":131246,"ts":1234080175022.347,"ph":"X","cat":"fee","dur":8.381,"name":"_parse (/home/ma-user/anaconda3/envs/py311/lib/python3.11/re/_parser.py:507)"},{"pid":131246,"tid":131246,"ts":1234080175031.038,"ph":"X","cat":"fee","dur":0.11,"name":"list.append"},{"pid":131246,"tid":131246,"ts":1234080175031.438,"ph":"X","cat":"fee","dur":0.16,"name":"Tokenizer.match (/home/ma-user/anaconda3/envs/py311/lib/python3.11/re/_parser.py:247)"},{"pid":131246,"tid":131246,"ts":1234080175031.818,"ph":"X","cat":"fee","dur":0.08,"name":"builtins.len"},{"pid":131246,"tid":131246,"ts":1234080175021.137,"ph":"X","cat":"fee","dur":10.951,"name":"_parse_sub (/home/ma-user/anaconda3/envs/py311/lib/python3.11/re/_parser.py:447)"},{"pid":131246,"tid":131246,"ts":1234080175032.788,"ph":"X","cat":"fee","dur":0.99,"name":"Tokenizer.__next (/home/ma-user/anaconda3/envs/py311/lib/python3.11/re/_parser.py:231)"},{"pid":131246,"tid":131246,"ts":1234080175032.558,"ph":"X","cat":"fee","dur":1.36,"name":"Tokenizer.match (/home/ma-user/anaconda3/envs/py311/lib/python3.11/re/_parser.py:247)"},{"pid":131246,"tid":131246,"ts":1234080175035.838,"ph":"X","cat":"fee","dur":0.31,"name":"builtins.min"},{"pid":131246,"tid":131246,"ts":1234080175036.348,"ph":"X","cat":"fee","dur":0.24,"name":"builtins.min"},{"pid":131246,"tid":131246,"ts":1234080175034.578,"ph":"X","cat":"fee","dur":2.27,"name":"SubPattern.getwidth (/home/ma-user/anaconda3/envs/py311/lib/python3.11/re/_parser.py:172)"},{"pid":131246,"tid":131246,"ts":1234080175034.348,"ph":"X","cat":"fee","dur":2.88,"name":"State.closegroup (/home/ma-user/anaconda3/envs/py311/lib/python3.11/re/_parser.py:94)"},{"pid":131246,"tid":131246,"ts":1234080175037.938,"ph":"X","cat":"fee","dur":0.08,"name":"list.append"},{"pid":131246,"tid":131246,"ts":1234080175037.728,"ph":"X","cat":"fee","dur":0.4,"name":"SubPattern.append (/home/ma-user/anaconda3/envs/py311/lib/python3.11/re/_parser.py:170)"},{"pid":131246,"tid":131246,"ts":1234080175038.798,"ph":"X","cat":"fee","dur":0.07,"name":"builtins.len"},{"pid":131246,"tid":131246,"ts":1234080175038.668,"ph":"X","cat":"fee","dur":0.27,"name":"SubPattern.__len__ (/home/ma-user/anaconda3/envs/py311/lib/python3.11/re/_parser.py:158)"},{"pid":131246,"tid":131246,"ts":1234080175038.488,"ph":"X","cat":"fee","dur":0.59,"name":"builtins.len"},{"pid":131246,"tid":131246,"ts":1234080175040.158,"ph":"X","cat":"fee","dur":0.11,"name":"builtins.isinstance"},{"pid":131246,"tid":131246,"ts":1234080175039.958,"ph":"X","cat":"fee","dur":0.5,"name":"SubPattern.__getitem__ (/home/ma-user/anaconda3/envs/py311/lib/python3.11/re/_parser.py:162)"},{"pid":131246,"tid":131246,"ts":1234080175012.557,"ph":"X","cat":"fee","dur":28.371,"name":"_parse (/home/ma-user/anaconda3/envs/py311/lib/python3.11/re/_parser.py:507)"},{"pid":131246,"tid":131246,"ts":1234080175041.228,"ph":"X","cat":"fee","dur":0.06,"name":"list.append"},{"pid":131246,"tid":131246,"ts":1234080175041.508,"ph":"X","cat":"fee","dur":0.24,"name":"Tokenizer.match (/home/ma-user/anaconda3/envs/py311/lib/python3.11/re/_parser.py:247)"},{"pid":131246,"tid":131246,"ts":1234080175041.938,"ph":"X","cat":"fee","dur":0.05,"name":"builtins.len"},{"pid":131246,"tid":131246,"ts":1234080175010.647,"ph":"X","cat":"fee","dur":31.491,"name":"_parse_sub (/home/ma-user/anaconda3/envs/py311/lib/python3.11/re/_parser.py:447)"},{"pid":131246,"tid":131246,"ts":1234080175042.868,"ph":"X","cat":"fee","dur":0.08,"name":"builtins.isinstance"},{"pid":131246,"tid":131246,"ts":1234080175042.698,"ph":"X","cat":"fee","dur":0.75,"name":"fix_flags (/home/ma-user/anaconda3/envs/py311/lib/python3.11/re/_parser.py:954)"},{"pid":131246,"tid":131246,"ts":1234080175005.837,"ph":"X","cat":"fee","dur":38.241,"name":"parse (/home/ma-user/anaconda3/envs/py311/lib/python3.11/re/_parser.py:970)"},{"pid":131246,"tid":131246,"ts":1234080175046.418,"ph":"X","cat":"fee","dur":0.16,"name":"SubPattern.getwidth (/home/ma-user/anaconda3/envs/py311/lib/python3.11/re/_parser.py:172)"},{"pid":131246,"tid":131246,"ts":1234080175047.058,"ph":"X","cat":"fee","dur":0.24,"name":"builtins.min"},{"pid":131246,"tid":131246,"ts":1234080175047.448,"ph":"X","cat":"fee","dur":0.24,"name":"builtins.min"},{"pid":131246,"tid":131246,"ts":1234080175045.738,"ph":"X","cat":"fee","dur":2.15,"name":"SubPattern.getwidth (/home/ma-user/anaconda3/envs/py311/lib/python3.11/re/_parser.py:172)"},{"pid":131246,"tid":131246,"ts":1234080175049.108,"ph":"X","cat":"fee","dur":0.16,"name":"_get_iscased (/home/ma-user/anaconda3/envs/py311/lib/python3.11/re/_compiler.py:426)"},{"pid":131246,"tid":131246,"ts":1234080175050.228,"ph":"X","cat":"fee","dur":0.3,"name":"_combine_flags (/home/ma-user/anaconda3/envs/py311/lib/python3.11/re/_compiler.py:31)"},{"pid":131246,"tid":131246,"ts":1234080175051.078,"ph":"X","cat":"fee","dur":0.14,"name":"_get_iscased (/home/ma-user/anaconda3/envs/py311/lib/python3.11/re/_compiler.py:426)"},{"pid":131246,"tid":131246,"ts":1234080175051.608,"ph":"X","cat":"fee","dur":0.1,"name":"list.append"},{"pid":131246,"tid":131246,"ts":1234080175050.818,"ph":"X","cat":"fee","dur":1.11,"name":"_get_literal_prefix (/home/ma-user/anaconda3/envs/py311/lib/python3.11/re/_compiler.py:434)"},{"pid":131246,"tid":131246,"ts":1234080175052.368,"ph":"X","cat":"fee","dur":0.06,"name":"builtins.len"},{"pid":131246,"tid":131246,"ts":1234080175052.798,"ph":"X","cat":"fee","dur":0.1,"name":"list.extend"},{"pid":131246,"tid":131246,"ts":1234080175048.638,"ph":"X","cat":"fee","dur":4.47,"name":"_get_literal_prefix (/home/ma-user/anaconda3/envs/py311/lib/python3.11/re/_compiler.py:434)"},{"pid":131246,"tid":131246,"ts":1234080175053.738,"ph":"X","cat":"fee","dur":0.07,"name":"list.append"},{"pid":131246,"tid":131246,"ts":1234080175053.928,"ph":"X","cat":"fee","dur":0.07,"name":"builtins.len"},{"pid":131246,"tid":131246,"ts":1234080175054.118,"ph":"X","cat":"fee","dur":0.07,"name":"list.append"},{"pid":131246,"tid":131246,"ts":1234080175054.488,"ph":"X","cat":"fee","dur":0.05,"name":"list.append"},{"pid":131246,"tid":131246,"ts":1234080175055.788,"ph":"X","cat":"fee","dur":0.06,"name":"list.append"},{"pid":131246,"tid":131246,"ts":1234080175056.168,"ph":"X","cat":"fee","dur":0.27,"name":"builtins.min"},{"pid":131246,"tid":131246,"ts":1234080175056.518,"ph":"X","cat":"fee","dur":0.11,"name":"list.append"},{"pid":131246,"tid":131246,"ts":1234080175056.818,"ph":"X","cat":"fee","dur":0.07,"name":"builtins.len"},{"pid":131246,"tid":131246,"ts":1234080175056.968,"ph":"X","cat":"fee","dur":0.05,"name":"list.append"},{"pid":131246,"tid":131246,"ts":1234080175057.138,"ph":"X","cat":"fee","dur":0.05,"name":"list.append"},{"pid":131246,"tid":131246,"ts":1234080175057.348,"ph":"X","cat":"fee","dur":0.1,"name":"list.extend"},{"pid":131246,"tid":131246,"ts":1234080175058.078,"ph":"X","cat":"fee","dur":0.06,"name":"builtins.len"},{"pid":131246,"tid":131246,"ts":1234080175058.498,"ph":"X","cat":"fee","dur":0.06,"name":"builtins.len"},{"pid":131246,"tid":131246,"ts":1234080175057.828,"ph":"X","cat":"fee","dur":1.16,"name":"_generate_overlap_table (/home/ma-user/anaconda3/envs/py311/lib/python3.11/re/_compiler.py:405)"},{"pid":131246,"tid":131246,"ts":1234080175059.178,"ph":"X","cat":"fee","dur":0.12,"name":"list.extend"},{"pid":131246,"tid":131246,"ts":1234080175059.508,"ph":"X","cat":"fee","dur":0.06,"name":"builtins.len"},{"pid":131246,"tid":131246,"ts":1234080175045.488,"ph":"X","cat":"fee","dur":14.31,"name":"_compile_info (/home/ma-user/anaconda3/envs/py311/lib/python3.11/re/_compiler.py:509)"},{"pid":131246,"tid":131246,"ts":1234080175061.868,"ph":"X","cat":"fee","dur":0.05,"name":"list.append"},{"pid":131246,"tid":131246,"ts":1234080175062.128,"ph":"X","cat":"fee","dur":0.07,"name":"list.append"},{"pid":131246,"tid":131246,"ts":1234080175062.478,"ph":"X","cat":"fee","dur":0.21,"name":"_combine_flags (/home/ma-user/anaconda3/envs/py311/lib/python3.11/re/_compiler.py:31)"},{"pid":131246,"tid":131246,"ts":1234080175063.738,"ph":"X","cat":"fee","dur":0.16,"name":"builtins.isinstance"},{"pid":131246,"tid":131246,"ts":1234080175063.578,"ph":"X","cat":"fee","dur":0.49,"name":"SubPattern.__getitem__ (/home/ma-user/anaconda3/envs/py311/lib/python3.11/re/_parser.py:162)"},{"pid":131246,"tid":131246,"ts":1234080175064.478,"ph":"X","cat":"fee","dur":0.05,"name":"list.append"},{"pid":131246,"tid":131246,"ts":1234080175064.628,"ph":"X","cat":"fee","dur":0.05,"name":"list.append"},{"pid":131246,"tid":131246,"ts":1234080175065.028,"ph":"X","cat":"fee","dur":0.11,"name":"builtins.isinstance"},{"pid":131246,"tid":131246,"ts":1234080175064.878,"ph":"X","cat":"fee","dur":0.55,"name":"SubPattern.__getitem__ (/home/ma-user/anaconda3/envs/py311/lib/python3.11/re/_parser.py:162)"},{"pid":131246,"tid":131246,"ts":1234080175062.918,"ph":"X","cat":"fee","dur":2.87,"name":"_compile (/home/ma-user/anaconda3/envs/py311/lib/python3.11/re/_compiler.py:37)"},{"pid":131246,"tid":131246,"ts":1234080175066.118,"ph":"X","cat":"fee","dur":0.07,"name":"list.append"},{"pid":131246,"tid":131246,"ts":1234080175066.438,"ph":"X","cat":"fee","dur":0.06,"name":"list.append"},{"pid":131246,"tid":131246,"ts":1234080175060.368,"ph":"X","cat":"fee","dur":6.28,"name":"_compile (/home/ma-user/anaconda3/envs/py311/lib/python3.11/re/_compiler.py:37)"},{"pid":131246,"tid":131246,"ts":1234080175067.058,"ph":"X","cat":"fee","dur":0.06,"name":"list.append"},{"pid":131246,"tid":131246,"ts":1234080175044.818,"ph":"X","cat":"fee","dur":22.41,"name":"_code (/home/ma-user/anaconda3/envs/py311/lib/python3.11/re/_compiler.py:571)"},{"pid":131246,"tid":131246,"ts":1234080175067.958,"ph":"X","cat":"fee","dur":0.06,"name":"builtins.len"},{"pid":131246,"tid":131246,"ts":1234080175067.818,"ph":"X","cat":"fee","dur":0.28,"name":"State.groups (/home/ma-user/anaconda3/envs/py311/lib/python3.11/re/_parser.py:79)"},{"pid":131246,"tid":131246,"ts":1234080175068.538,"ph":"X","cat":"fee","dur":0.22,"name":"dict.items"},{"pid":131246,"tid":131246,"ts":1234080175069.648,"ph":"X","cat":"fee","dur":0.07,"name":"builtins.len"},{"pid":131246,"tid":131246,"ts":1234080175069.518,"ph":"X","cat":"fee","dur":0.27,"name":"State.groups (/home/ma-user/anaconda3/envs/py311/lib/python3.11/re/_parser.py:79)"},{"pid":131246,"tid":131246,"ts":1234080175070.198,"ph":"X","cat":"fee","dur":0.5,"name":"_sre.compile"},{"pid":131246,"tid":131246,"ts":1234080175004.557,"ph":"X","cat":"fee","dur":66.271,"name":"compile (/home/ma-user/anaconda3/envs/py311/lib/python3.11/re/_compiler.py:738)"},{"pid":131246,"tid":131246,"ts":1234080175072.168,"ph":"X","cat":"fee","dur":0.25,"name":"builtins.isinstance"},{"pid":131246,"tid":131246,"ts":1234080175072.828,"ph":"X","cat":"fee","dur":0.06,"name":"builtins.isinstance"},{"pid":131246,"tid":131246,"ts":1234080175074.008,"ph":"X","cat":"fee","dur":0.49,"name":"Enum.__new__ (/home/ma-user/anaconda3/envs/py311/lib/python3.11/enum.py:1074)"},{"pid":131246,"tid":131246,"ts":1234080175073.498,"ph":"X","cat":"fee","dur":1.13,"name":"EnumType.__call__ (/home/ma-user/anaconda3/envs/py311/lib/python3.11/enum.py:669)"},{"pid":131246,"tid":131246,"ts":1234080175071.978,"ph":"X","cat":"fee","dur":2.81,"name":"Flag.__and__ (/home/ma-user/anaconda3/envs/py311/lib/python3.11/enum.py:1483)"},{"pid":131246,"tid":131246,"ts":1234080175075.118,"ph":"X","cat":"fee","dur":0.12,"name":"builtins.len"},{"pid":131246,"tid":131246,"ts":1234080174996.857,"ph":"X","cat":"fee","dur":78.981,"name":"_compile (/home/ma-user/anaconda3/envs/py311/lib/python3.11/re/__init__.py:272)"},{"pid":131246,"tid":131246,"ts":1234080175076.198,"ph":"X","cat":"fee","dur":0.92,"name":"re.Pattern.match"},{"pid":131246,"tid":131246,"ts":1234080174996.657,"ph":"X","cat":"fee","dur":80.591,"name":"match (/home/ma-user/anaconda3/envs/py311/lib/python3.11/re/__init__.py:163)"},{"pid":131246,"tid":131246,"ts":1234080175077.828,"ph":"X","cat":"fee","dur":0.52,"name":"re.Match.group"},{"pid":131246,"tid":131246,"ts":1234080175078.458,"ph":"X","cat":"fee","dur":0.08,"name":"builtins.len"},{"pid":131246,"tid":131246,"ts":1234080174991.937,"ph":"X","cat":"fee","dur":87.591,"name":"ArgumentParser._match_argument (/home/ma-user/anaconda3/envs/py311/lib/python3.11/argparse.py:2180)"},{"pid":131246,"tid":131246,"ts":1234080175080.298,"ph":"X","cat":"fee","dur":0.11,"name":"list.append"},{"pid":131246,"tid":131246,"ts":1234080175083.268,"ph":"X","cat":"fee","dur":0.26,"name":"set.add"},{"pid":131246,"tid":131246,"ts":1234080175089.568,"ph":"X","cat":"fee","dur":0.28,"name":"list.remove"},{"pid":131246,"tid":131246,"ts":1234080175090.858,"ph":"X","cat":"fee","dur":0.06,"name":"builtins.len"},{"pid":131246,"tid":131246,"ts":1234080175094.998,"ph":"X","cat":"fee","dur":0.1,"name":"dict.get"},{"pid":131246,"tid":131246,"ts":1234080175094.758,"ph":"X","cat":"fee","dur":0.45,"name":"_ActionsContainer._registry_get (/home/ma-user/anaconda3/envs/py311/lib/python3.11/argparse.py:1387)"},{"pid":131246,"tid":131246,"ts":1234080175095.388,"ph":"X","cat":"fee","dur":0.07,"name":"builtins.callable"},{"pid":131246,"tid":131246,"ts":1234080175094.368,"ph":"X","cat":"fee","dur":2.2,"name":"ArgumentParser._get_value (/home/ma-user/anaconda3/envs/py311/lib/python3.11/argparse.py:2510)"},{"pid":131246,"tid":131246,"ts":1234080175098.128,"ph":"X","cat":"fee","dur":0.61,"name":"ArgumentParser._check_value (/home/ma-user/anaconda3/envs/py311/lib/python3.11/argparse.py:2536)"},{"pid":131246,"tid":131246,"ts":1234080175088.828,"ph":"X","cat":"fee","dur":10.1,"name":"ArgumentParser._get_values (/home/ma-user/anaconda3/envs/py311/lib/python3.11/argparse.py:2454)"},{"pid":131246,"tid":131246,"ts":1234080175099.278,"ph":"X","cat":"fee","dur":0.11,"name":"set.add"},{"pid":131246,"tid":131246,"ts":1234080175099.608,"ph":"X","cat":"fee","dur":0.1,"name":"dict.get"},{"pid":131246,"tid":131246,"ts":1234080175101.048,"ph":"X","cat":"fee","dur":0.34,"name":"builtins.setattr"},{"pid":131246,"tid":131246,"ts":1234080175100.748,"ph":"X","cat":"fee","dur":0.77,"name":"_StoreAction.__call__ (/home/ma-user/anaconda3/envs/py311/lib/python3.11/argparse.py:948)"},{"pid":131246,"tid":131246,"ts":1234080175082.928,"ph":"X","cat":"fee","dur":18.78,"name":"ArgumentParser._parse_known_args.<locals>.take_action (/home/ma-user/anaconda3/envs/py311/lib/python3.11/argparse.py:1953)"},{"pid":131246,"tid":131246,"ts":1234080174988.847,"ph":"X","cat":"fee","dur":113.091,"name":"ArgumentParser._parse_known_args.<locals>.consume_optional (/home/ma-user/anaconda3/envs/py311/lib/python3.11/argparse.py:1974)"},{"pid":131246,"tid":131246,"ts":1234080175102.988,"ph":"X","cat":"fee","dur":1.01,"name":"ArgumentParser._parse_known_args.<locals>.<listcomp> (/home/ma-user/anaconda3/envs/py311/lib/python3.11/argparse.py:2080)"},{"pid":131246,"tid":131246,"ts":1234080175104.228,"ph":"X","cat":"fee","dur":0.52,"name":"builtins.min"},{"pid":131246,"tid":131246,"ts":1234080175106.798,"ph":"X","cat":"fee","dur":0.31,"name":"str.replace"},{"pid":131246,"tid":131246,"ts":1234080175107.298,"ph":"X","cat":"fee","dur":0.1,"name":"str.replace"},{"pid":131246,"tid":131246,"ts":1234080175106.388,"ph":"X","cat":"fee","dur":1.12,"name":"ArgumentParser._get_nargs_pattern (/home/ma-user/anaconda3/envs/py311/lib/python3.11/argparse.py:2321)"},{"pid":131246,"tid":131246,"ts":1234080175108.208,"ph":"X","cat":"fee","dur":0.21,"name":"builtins.isinstance"},{"pid":131246,"tid":131246,"ts":1234080175108.078,"ph":"X","cat":"fee","dur":0.88,"name":"_compile (/home/ma-user/anaconda3/envs/py311/lib/python3.11/re/__init__.py:272)"},{"pid":131246,"tid":131246,"ts":1234080175109.228,"ph":"X","cat":"fee","dur":0.46,"name":"re.Pattern.match"},{"pid":131246,"tid":131246,"ts":1234080175107.878,"ph":"X","cat":"fee","dur":1.95,"name":"match (/home/ma-user/anaconda3/envs/py311/lib/python3.11/re/__init__.py:163)"},{"pid":131246,"tid":131246,"ts":1234080175110.088,"ph":"X","cat":"fee","dur":0.23,"name":"re.Match.group"},{"pid":131246,"tid":131246,"ts":1234080175110.418,"ph":"X","cat":"fee","dur":0.1,"name":"builtins.len"},{"pid":131246,"tid":131246,"ts":1234080175106.168,"ph":"X","cat":"fee","dur":4.42,"name":"ArgumentParser._match_argument (/home/ma-user/anaconda3/envs/py311/lib/python3.11/argparse.py:2180)"},{"pid":131246,"tid":131246,"ts":1234080175111.158,"ph":"X","cat":"fee","dur":0.11,"name":"list.append"},{"pid":131246,"tid":131246,"ts":1234080175111.878,"ph":"X","cat":"fee","dur":0.09,"name":"set.add"},{"pid":131246,"tid":131246,"ts":1234080175112.728,"ph":"X","cat":"fee","dur":0.24,"name":"list.remove"},{"pid":131246,"tid":131246,"ts":1234080175113.578,"ph":"X","cat":"fee","dur":0.07,"name":"builtins.len"},{"pid":131246,"tid":131246,"ts":1234080175114.698,"ph":"X","cat":"fee","dur":0.1,"name":"dict.get"},{"pid":131246,"tid":131246,"ts":1234080175114.478,"ph":"X","cat":"fee","dur":0.45,"name":"_ActionsContainer._registry_get (/home/ma-user/anaconda3/envs/py311/lib/python3.11/argparse.py:1387)"},{"pid":131246,"tid":131246,"ts":1234080175115.108,"ph":"X","cat":"fee","dur":0.07,"name":"builtins.callable"},{"pid":131246,"tid":131246,"ts":1234080175114.178,"ph":"X","cat":"fee","dur":1.43,"name":"ArgumentParser._get_value (/home/ma-user/anaconda3/envs/py311/lib/python3.11/argparse.py:2510)"},{"pid":131246,"tid":131246,"ts":1234080175115.958,"ph":"X","cat":"fee","dur":0.14,"name":"ArgumentParser._check_value (/home/ma-user/anaconda3/envs/py311/lib/python3.11/argparse.py:2536)"},{"pid":131246,"tid":131246,"ts":1234080175112.288,"ph":"X","cat":"fee","dur":3.93,"name":"ArgumentParser._get_values (/home/ma-user/anaconda3/envs/py311/lib/python3.11/argparse.py:2454)"},{"pid":131246,"tid":131246,"ts":1234080175116.538,"ph":"X","cat":"fee","dur":0.1,"name":"set.add"},{"pid":131246,"tid":131246,"ts":1234080175116.858,"ph":"X","cat":"fee","dur":0.09,"name":"dict.get"},{"pid":131246,"tid":131246,"ts":1234080175117.618,"ph":"X","cat":"fee","dur":0.27,"name":"builtins.setattr"},{"pid":131246,"tid":131246,"ts":1234080175117.398,"ph":"X","cat":"fee","dur":0.56,"name":"_StoreAction.__call__ (/home/ma-user/anaconda3/envs/py311/lib/python3.11/argparse.py:948)"},{"pid":131246,"tid":131246,"ts":1234080175111.728,"ph":"X","cat":"fee","dur":6.42,"name":"ArgumentParser._parse_known_args.<locals>.take_action (/home/ma-user/anaconda3/envs/py311/lib/python3.11/argparse.py:1953)"},{"pid":131246,"tid":131246,"ts":1234080175105.278,"ph":"X","cat":"fee","dur":13.07,"name":"ArgumentParser._parse_known_args.<locals>.consume_optional (/home/ma-user/anaconda3/envs/py311/lib/python3.11/argparse.py:1974)"},{"pid":131246,"tid":131246,"ts":1234080175119.108,"ph":"X","cat":"fee","dur":0.69,"name":"ArgumentParser._parse_known_args.<locals>.<listcomp> (/home/ma-user/anaconda3/envs/py311/lib/python3.11/argparse.py:2080)"},{"pid":131246,"tid":131246,"ts":1234080175120.008,"ph":"X","cat":"fee","dur":0.37,"name":"builtins.min"},{"pid":131246,"tid":131246,"ts":1234080175123.148,"ph":"X","cat":"fee","dur":0.21,"name":"str.replace"},{"pid":131246,"tid":131246,"ts":1234080175123.548,"ph":"X","cat":"fee","dur":0.08,"name":"str.replace"},{"pid":131246,"tid":131246,"ts":1234080175122.788,"ph":"X","cat":"fee","dur":0.96,"name":"ArgumentParser._get_nargs_pattern (/home/ma-user/anaconda3/envs/py311/lib/python3.11/argparse.py:2321)"},{"pid":131246,"tid":131246,"ts":1234080175124.398,"ph":"X","cat":"fee","dur":0.22,"name":"builtins.isinstance"},{"pid":131246,"tid":131246,"ts":1234080175124.268,"ph":"X","cat":"fee","dur":0.77,"name":"_compile (/home/ma-user/anaconda3/envs/py311/lib/python3.11/re/__init__.py:272)"},{"pid":131246,"tid":131246,"ts":1234080175125.218,"ph":"X","cat":"fee","dur":0.3,"name":"re.Pattern.match"},{"pid":131246,"tid":131246,"ts":1234080175124.068,"ph":"X","cat":"fee","dur":1.57,"name":"match (/home/ma-user/anaconda3/envs/py311/lib/python3.11/re/__init__.py:163)"},{"pid":131246,"tid":131246,"ts":1234080175125.908,"ph":"X","cat":"fee","dur":0.18,"name":"re.Match.group"},{"pid":131246,"tid":131246,"ts":1234080175126.198,"ph":"X","cat":"fee","dur":0.08,"name":"builtins.len"},{"pid":131246,"tid":131246,"ts":1234080175122.578,"ph":"X","cat":"fee","dur":3.76,"name":"ArgumentParser._match_argument (/home/ma-user/anaconda3/envs/py311/lib/python3.11/argparse.py:2180)"},{"pid":131246,"tid":131246,"ts":1234080175126.858,"ph":"X","cat":"fee","dur":0.09,"name":"list.append"},{"pid":131246,"tid":131246,"ts":1234080175127.479,"ph":"X","cat":"fee","dur":0.08,"name":"set.add"},{"pid":131246,"tid":131246,"ts":1234080175128.239,"ph":"X","cat":"fee","dur":0.24,"name":"list.remove"},{"pid":131246,"tid":131246,"ts":1234080175129.069,"ph":"X","cat":"fee","dur":0.06,"name":"builtins.len"},{"pid":131246,"tid":131246,"ts":1234080175130.139,"ph":"X","cat":"fee","dur":0.11,"name":"dict.get"},{"pid":131246,"tid":131246,"ts":1234080175129.919,"ph":"X","cat":"fee","dur":0.43,"name":"_ActionsContainer._registry_get (/home/ma-user/anaconda3/envs/py311/lib/python3.11/argparse.py:1387)"},{"pid":131246,"tid":131246,"ts":1234080175130.529,"ph":"X","cat":"fee","dur":0.06,"name":"builtins.callable"},{"pid":131246,"tid":131246,"ts":1234080175129.619,"ph":"X","cat":"fee","dur":1.26,"name":"ArgumentParser._get_value (/home/ma-user/anaconda3/envs/py311/lib/python3.11/argparse.py:2510)"},{"pid":131246,"tid":131246,"ts":1234080175131.169,"ph":"X","cat":"fee","dur":0.13,"name":"ArgumentParser._check_value (/home/ma-user/anaconda3/envs/py311/lib/python3.11/argparse.py:2536)"},{"pid":131246,"tid":131246,"ts":1234080175127.849,"ph":"X","cat":"fee","dur":3.6,"name":"ArgumentParser._get_values (/home/ma-user/anaconda3/envs/py311/lib/python3.11/argparse.py:2454)"},{"pid":131246,"tid":131246,"ts":1234080175131.729,"ph":"X","cat":"fee","dur":0.11,"name":"set.add"},{"pid":131246,"tid":131246,"ts":1234080175132.009,"ph":"X","cat":"fee","dur":0.08,"name":"dict.get"},{"pid":131246,"tid":131246,"ts":1234080175132.729,"ph":"X","cat":"fee","dur":0.27,"name":"builtins.setattr"},{"pid":131246,"tid":131246,"ts":1234080175132.559,"ph":"X","cat":"fee","dur":0.52,"name":"_StoreAction.__call__ (/home/ma-user/anaconda3/envs/py311/lib/python3.11/argparse.py:948)"},{"pid":131246,"tid":131246,"ts":1234080175127.339,"ph":"X","cat":"fee","dur":5.93,"name":"ArgumentParser._parse_known_args.<locals>.take_action (/home/ma-user/anaconda3/envs/py311/lib/python3.11/argparse.py:1953)"},{"pid":131246,"tid":131246,"ts":1234080175121.778,"ph":"X","cat":"fee","dur":11.661,"name":"ArgumentParser._parse_known_args.<locals>.consume_optional (/home/ma-user/anaconda3/envs/py311/lib/python3.11/argparse.py:1974)"},{"pid":131246,"tid":131246,"ts":1234080175134.119,"ph":"X","cat":"fee","dur":0.63,"name":"ArgumentParser._parse_known_args.<locals>.<listcomp> (/home/ma-user/anaconda3/envs/py311/lib/python3.11/argparse.py:2080)"},{"pid":131246,"tid":131246,"ts":1234080175134.939,"ph":"X","cat":"fee","dur":0.34,"name":"builtins.min"},{"pid":131246,"tid":131246,"ts":1234080175136.729,"ph":"X","cat":"fee","dur":0.19,"name":"str.replace"},{"pid":131246,"tid":131246,"ts":1234080175137.109,"ph":"X","cat":"fee","dur":0.08,"name":"str.replace"},{"pid":131246,"tid":131246,"ts":1234080175136.459,"ph":"X","cat":"fee","dur":0.84,"name":"ArgumentParser._get_nargs_pattern (/home/ma-user/anaconda3/envs/py311/lib/python3.11/argparse.py:2321)"},{"pid":131246,"tid":131246,"ts":1234080175137.949,"ph":"X","cat":"fee","dur":0.2,"name":"builtins.isinstance"},{"pid":131246,"tid":131246,"ts":1234080175137.809,"ph":"X","cat":"fee","dur":0.7,"name":"_compile (/home/ma-user/anaconda3/envs/py311/lib/python3.11/re/__init__.py:272)"},{"pid":131246,"tid":131246,"ts":1234080175138.709,"ph":"X","cat":"fee","dur":0.21,"name":"re.Pattern.match"},{"pid":131246,"tid":131246,"ts":1234080175137.609,"ph":"X","cat":"fee","dur":1.43,"name":"match (/home/ma-user/anaconda3/envs/py311/lib/python3.11/re/__init__.py:163)"},{"pid":131246,"tid":131246,"ts":1234080175139.289,"ph":"X","cat":"fee","dur":0.16,"name":"re.Match.group"},{"pid":131246,"tid":131246,"ts":1234080175139.549,"ph":"X","cat":"fee","dur":0.09,"name":"builtins.len"},{"pid":131246,"tid":131246,"ts":1234080175136.239,"ph":"X","cat":"fee","dur":3.47,"name":"ArgumentParser._match_argument (/home/ma-user/anaconda3/envs/py311/lib/python3.11/argparse.py:2180)"},{"pid":131246,"tid":131246,"ts":1234080175140.129,"ph":"X","cat":"fee","dur":0.08,"name":"list.append"},{"pid":131246,"tid":131246,"ts":1234080175140.699,"ph":"X","cat":"fee","dur":0.09,"name":"set.add"},{"pid":131246,"tid":131246,"ts":1234080175141.439,"ph":"X","cat":"fee","dur":0.2,"name":"list.remove"},{"pid":131246,"tid":131246,"ts":1234080175142.189,"ph":"X","cat":"fee","dur":0.07,"name":"builtins.len"},{"pid":131246,"tid":131246,"ts":1234080175143.199,"ph":"X","cat":"fee","dur":0.11,"name":"dict.get"},{"pid":131246,"tid":131246,"ts":1234080175142.979,"ph":"X","cat":"fee","dur":0.43,"name":"_ActionsContainer._registry_get (/home/ma-user/anaconda3/envs/py311/lib/python3.11/argparse.py:1387)"},{"pid":131246,"tid":131246,"ts":1234080175143.579,"ph":"X","cat":"fee","dur":0.06,"name":"builtins.callable"},{"pid":131246,"tid":131246,"ts":1234080175142.699,"ph":"X","cat":"fee","dur":1.34,"name":"ArgumentParser._get_value (/home/ma-user/anaconda3/envs/py311/lib/python3.11/argparse.py:2510)"},{"pid":131246,"tid":131246,"ts":1234080175145.289,"ph":"X","cat":"fee","dur":0.15,"name":"ArgumentParser._check_value (/home/ma-user/anaconda3/envs/py311/lib/python3.11/argparse.py:2536)"},{"pid":131246,"tid":131246,"ts":1234080175141.059,"ph":"X","cat":"fee","dur":4.52,"name":"ArgumentParser._get_values (/home/ma-user/anaconda3/envs/py311/lib/python3.11/argparse.py:2454)"},{"pid":131246,"tid":131246,"ts":1234080175146.269,"ph":"X","cat":"fee","dur":0.26,"name":"builtins.setattr"},{"pid":131246,"tid":131246,"ts":1234080175146.099,"ph":"X","cat":"fee","dur":0.5,"name":"_StoreAction.__call__ (/home/ma-user/anaconda3/envs/py311/lib/python3.11/argparse.py:948)"},{"pid":131246,"tid":131246,"ts":1234080175140.559,"ph":"X","cat":"fee","dur":6.2,"name":"ArgumentParser._parse_known_args.<locals>.take_action (/home/ma-user/anaconda3/envs/py311/lib/python3.11/argparse.py:1953)"},{"pid":131246,"tid":131246,"ts":1234080175135.609,"ph":"X","cat":"fee","dur":11.32,"name":"ArgumentParser._parse_known_args.<locals>.consume_optional (/home/ma-user/anaconda3/envs/py311/lib/python3.11/argparse.py:1974)"},{"pid":131246,"tid":131246,"ts":1234080175147.499,"ph":"X","cat":"fee","dur":0.6,"name":"ArgumentParser._parse_known_args.<locals>.<listcomp> (/home/ma-user/anaconda3/envs/py311/lib/python3.11/argparse.py:2080)"},{"pid":131246,"tid":131246,"ts":1234080175148.289,"ph":"X","cat":"fee","dur":0.27,"name":"builtins.min"},{"pid":131246,"tid":131246,"ts":1234080175151.189,"ph":"X","cat":"fee","dur":0.22,"name":"str.replace"},{"pid":131246,"tid":131246,"ts":1234080175151.589,"ph":"X","cat":"fee","dur":0.08,"name":"str.replace"},{"pid":131246,"tid":131246,"ts":1234080175150.349,"ph":"X","cat":"fee","dur":1.45,"name":"ArgumentParser._get_nargs_pattern (/home/ma-user/anaconda3/envs/py311/lib/python3.11/argparse.py:2321)"},{"pid":131246,"tid":131246,"ts":1234080175152.419,"ph":"X","cat":"fee","dur":0.24,"name":"builtins.isinstance"},{"pid":131246,"tid":131246,"ts":1234080175152.299,"ph":"X","cat":"fee","dur":0.74,"name":"_compile (/home/ma-user/anaconda3/envs/py311/lib/python3.11/re/__init__.py:272)"},{"pid":131246,"tid":131246,"ts":1234080175153.219,"ph":"X","cat":"fee","dur":0.26,"name":"re.Pattern.match"},{"pid":131246,"tid":131246,"ts":1234080175152.099,"ph":"X","cat":"fee","dur":1.48,"name":"match (/home/ma-user/anaconda3/envs/py311/lib/python3.11/re/__init__.py:163)"},{"pid":131246,"tid":131246,"ts":1234080175153.799,"ph":"X","cat":"fee","dur":0.18,"name":"re.Match.group"},{"pid":131246,"tid":131246,"ts":1234080175154.079,"ph":"X","cat":"fee","dur":0.08,"name":"builtins.len"},{"pid":131246,"tid":131246,"ts":1234080175149.489,"ph":"X","cat":"fee","dur":4.74,"name":"ArgumentParser._match_argument (/home/ma-user/anaconda3/envs/py311/lib/python3.11/argparse.py:2180)"},{"pid":131246,"tid":131246,"ts":1234080175154.599,"ph":"X","cat":"fee","dur":0.1,"name":"list.append"},{"pid":131246,"tid":131246,"ts":1234080175155.809,"ph":"X","cat":"fee","dur":0.35,"name":"set.add"},{"pid":131246,"tid":131246,"ts":1234080175158.019,"ph":"X","cat":"fee","dur":0.23,"name":"list.remove"},{"pid":131246,"tid":131246,"ts":1234080175158.799,"ph":"X","cat":"fee","dur":0.07,"name":"builtins.len"},{"pid":131246,"tid":131246,"ts":1234080175160.619,"ph":"X","cat":"fee","dur":0.1,"name":"dict.get"},{"pid":131246,"tid":131246,"ts":1234080175160.429,"ph":"X","cat":"fee","dur":0.41,"name":"_ActionsContainer._registry_get (/home/ma-user/anaconda3/envs/py311/lib/python3.11/argparse.py:1387)"},{"pid":131246,"tid":131246,"ts":1234080175161.009,"ph":"X","cat":"fee","dur":0.06,"name":"builtins.callable"},{"pid":131246,"tid":131246,"ts":1234080175159.329,"ph":"X","cat":"fee","dur":1.99,"name":"ArgumentParser._get_value (/home/ma-user/anaconda3/envs/py311/lib/python3.11/argparse.py:2510)"},{"pid":131246,"tid":131246,"ts":1234080175161.599,"ph":"X","cat":"fee","dur":0.13,"name":"ArgumentParser._check_value (/home/ma-user/anaconda3/envs/py311/lib/python3.11/argparse.py:2536)"},{"pid":131246,"tid":131246,"ts":1234080175156.409,"ph":"X","cat":"fee","dur":5.44,"name":"ArgumentParser._get_values (/home/ma-user/anaconda3/envs/py311/lib/python3.11/argparse.py:2454)"},{"pid":131246,"tid":131246,"ts":1234080175162.109,"ph":"X","cat":"fee","dur":0.1,"name":"set.add"},{"pid":131246,"tid":131246,"ts":1234080175162.369,"ph":"X","cat":"fee","dur":0.08,"name":"dict.get"},{"pid":131246,"tid":131246,"ts":1234080175163.029,"ph":"X","cat":"fee","dur":0.38,"name":"builtins.setattr"},{"pid":131246,"tid":131246,"ts":1234080175162.849,"ph":"X","cat":"fee","dur":0.63,"name":"_StoreAction.__call__ (/home/ma-user/anaconda3/envs/py311/lib/python3.11/argparse.py:948)"},{"pid":131246,"tid":131246,"ts":1234080175155.069,"ph":"X","cat":"fee","dur":8.57,"name":"ArgumentParser._parse_known_args.<locals>.take_action (/home/ma-user/anaconda3/envs/py311/lib/python3.11/argparse.py:1953)"},{"pid":131246,"tid":131246,"ts":1234080175148.869,"ph":"X","cat":"fee","dur":14.93,"name":"ArgumentParser._parse_known_args.<locals>.consume_optional (/home/ma-user/anaconda3/envs/py311/lib/python3.11/argparse.py:1974)"},{"pid":131246,"tid":131246,"ts":1234080175164.329,"ph":"X","cat":"fee","dur":0.48,"name":"ArgumentParser._parse_known_args.<locals>.<listcomp> (/home/ma-user/anaconda3/envs/py311/lib/python3.11/argparse.py:2080)"},{"pid":131246,"tid":131246,"ts":1234080175164.979,"ph":"X","cat":"fee","dur":0.26,"name":"builtins.min"},{"pid":131246,"tid":131246,"ts":1234080175166.639,"ph":"X","cat":"fee","dur":0.16,"name":"str.replace"},{"pid":131246,"tid":131246,"ts":1234080175166.969,"ph":"X","cat":"fee","dur":0.08,"name":"str.replace"},{"pid":131246,"tid":131246,"ts":1234080175166.379,"ph":"X","cat":"fee","dur":0.77,"name":"ArgumentParser._get_nargs_pattern (/home/ma-user/anaconda3/envs/py311/lib/python3.11/argparse.py:2321)"},{"pid":131246,"tid":131246,"ts":1234080175167.779,"ph":"X","cat":"fee","dur":0.2,"name":"builtins.isinstance"},{"pid":131246,"tid":131246,"ts":1234080175167.659,"ph":"X","cat":"fee","dur":0.65,"name":"_compile (/home/ma-user/anaconda3/envs/py311/lib/python3.11/re/__init__.py:272)"},{"pid":131246,"tid":131246,"ts":1234080175168.499,"ph":"X","cat":"fee","dur":0.22,"name":"re.Pattern.match"},{"pid":131246,"tid":131246,"ts":1234080175167.459,"ph":"X","cat":"fee","dur":1.36,"name":"match (/home/ma-user/anaconda3/envs/py311/lib/python3.11/re/__init__.py:163)"},{"pid":131246,"tid":131246,"ts":1234080175169.029,"ph":"X","cat":"fee","dur":0.16,"name":"re.Match.group"},{"pid":131246,"tid":131246,"ts":1234080175169.299,"ph":"X","cat":"fee","dur":0.08,"name":"builtins.len"},{"pid":131246,"tid":131246,"ts":1234080175166.169,"ph":"X","cat":"fee","dur":3.27,"name":"ArgumentParser._match_argument (/home/ma-user/anaconda3/envs/py311/lib/python3.11/argparse.py:2180)"},{"pid":131246,"tid":131246,"ts":1234080175169.799,"ph":"X","cat":"fee","dur":0.09,"name":"list.append"},{"pid":131246,"tid":131246,"ts":1234080175171.429,"ph":"X","cat":"fee","dur":0.1,"name":"set.add"},{"pid":131246,"tid":131246,"ts":1234080175172.199,"ph":"X","cat":"fee","dur":0.19,"name":"list.remove"},{"pid":131246,"tid":131246,"ts":1234080175172.899,"ph":"X","cat":"fee","dur":0.08,"name":"builtins.len"},{"pid":131246,"tid":131246,"ts":1234080175173.899,"ph":"X","cat":"fee","dur":0.09,"name":"dict.get"},{"pid":131246,"tid":131246,"ts":1234080175173.709,"ph":"X","cat":"fee","dur":0.39,"name":"_ActionsContainer._registry_get (/home/ma-user/anaconda3/envs/py311/lib/python3.11/argparse.py:1387)"},{"pid":131246,"tid":131246,"ts":1234080175174.269,"ph":"X","cat":"fee","dur":0.06,"name":"builtins.callable"},{"pid":131246,"tid":131246,"ts":1234080175173.449,"ph":"X","cat":"fee","dur":1.13,"name":"ArgumentParser._get_value (/home/ma-user/anaconda3/envs/py311/lib/python3.11/argparse.py:2510)"},{"pid":131246,"tid":131246,"ts":1234080175174.859,"ph":"X","cat":"fee","dur":0.13,"name":"ArgumentParser._check_value (/home/ma-user/anaconda3/envs/py311/lib/python3.11/argparse.py:2536)"},{"pid":131246,"tid":131246,"ts":1234080175171.789,"ph":"X","cat":"fee","dur":3.32,"name":"ArgumentParser._get_values (/home/ma-user/anaconda3/envs/py311/lib/python3.11/argparse.py:2454)"},{"pid":131246,"tid":131246,"ts":1234080175175.379,"ph":"X","cat":"fee","dur":0.26,"name":"set.add"},{"pid":131246,"tid":131246,"ts":1234080175175.829,"ph":"X","cat":"fee","dur":0.08,"name":"dict.get"},{"pid":131246,"tid":131246,"ts":1234080175176.439,"ph":"X","cat":"fee","dur":0.37,"name":"builtins.setattr"},{"pid":131246,"tid":131246,"ts":1234080175176.289,"ph":"X","cat":"fee","dur":0.59,"name":"_StoreAction.__call__ (/home/ma-user/anaconda3/envs/py311/lib/python3.11/argparse.py:948)"},{"pid":131246,"tid":131246,"ts":1234080175171.249,"ph":"X","cat":"fee","dur":5.79,"name":"ArgumentParser._parse_known_args.<locals>.take_action (/home/ma-user/anaconda3/envs/py311/lib/python3.11/argparse.py:1953)"},{"pid":131246,"tid":131246,"ts":1234080175165.569,"ph":"X","cat":"fee","dur":11.61,"name":"ArgumentParser._parse_known_args.<locals>.consume_optional (/home/ma-user/anaconda3/envs/py311/lib/python3.11/argparse.py:1974)"},{"pid":131246,"tid":131246,"ts":1234080175177.709,"ph":"X","cat":"fee","dur":0.46,"name":"ArgumentParser._parse_known_args.<locals>.<listcomp> (/home/ma-user/anaconda3/envs/py311/lib/python3.11/argparse.py:2080)"},{"pid":131246,"tid":131246,"ts":1234080175178.339,"ph":"X","cat":"fee","dur":0.28,"name":"builtins.min"},{"pid":131246,"tid":131246,"ts":1234080175179.839,"ph":"X","cat":"fee","dur":0.21,"name":"str.replace"},{"pid":131246,"tid":131246,"ts":1234080175180.209,"ph":"X","cat":"fee","dur":0.08,"name":"str.replace"},{"pid":131246,"tid":131246,"ts":1234080175179.569,"ph":"X","cat":"fee","dur":0.82,"name":"ArgumentParser._get_nargs_pattern (/home/ma-user/anaconda3/envs/py311/lib/python3.11/argparse.py:2321)"},{"pid":131246,"tid":131246,"ts":1234080175181.019,"ph":"X","cat":"fee","dur":0.21,"name":"builtins.isinstance"},{"pid":131246,"tid":131246,"ts":1234080175180.899,"ph":"X","cat":"fee","dur":0.67,"name":"_compile (/home/ma-user/anaconda3/envs/py311/lib/python3.11/re/__init__.py:272)"},{"pid":131246,"tid":131246,"ts":1234080175181.739,"ph":"X","cat":"fee","dur":0.25,"name":"re.Pattern.match"},{"pid":131246,"tid":131246,"ts":1234080175180.699,"ph":"X","cat":"fee","dur":1.39,"name":"match (/home/ma-user/anaconda3/envs/py311/lib/python3.11/re/__init__.py:163)"},{"pid":131246,"tid":131246,"ts":1234080175182.319,"ph":"X","cat":"fee","dur":0.17,"name":"re.Match.group"},{"pid":131246,"tid":131246,"ts":1234080175182.589,"ph":"X","cat":"fee","dur":0.09,"name":"builtins.len"},{"pid":131246,"tid":131246,"ts":1234080175179.369,"ph":"X","cat":"fee","dur":3.37,"name":"ArgumentParser._match_argument (/home/ma-user/anaconda3/envs/py311/lib/python3.11/argparse.py:2180)"},{"pid":131246,"tid":131246,"ts":1234080175183.379,"ph":"X","cat":"fee","dur":0.09,"name":"list.append"},{"pid":131246,"tid":131246,"ts":1234080175183.959,"ph":"X","cat":"fee","dur":0.09,"name":"set.add"},{"pid":131246,"tid":131246,"ts":1234080175184.649,"ph":"X","cat":"fee","dur":0.18,"name":"list.remove"},{"pid":131246,"tid":131246,"ts":1234080175185.349,"ph":"X","cat":"fee","dur":0.06,"name":"builtins.len"},{"pid":131246,"tid":131246,"ts":1234080175186.329,"ph":"X","cat":"fee","dur":0.1,"name":"dict.get"},{"pid":131246,"tid":131246,"ts":1234080175186.119,"ph":"X","cat":"fee","dur":0.42,"name":"_ActionsContainer._registry_get (/home/ma-user/anaconda3/envs/py311/lib/python3.11/argparse.py:1387)"},{"pid":131246,"tid":131246,"ts":1234080175186.699,"ph":"X","cat":"fee","dur":0.07,"name":"builtins.callable"},{"pid":131246,"tid":131246,"ts":1234080175185.839,"ph":"X","cat":"fee","dur":1.17,"name":"ArgumentParser._get_value (/home/ma-user/anaconda3/envs/py311/lib/python3.11/argparse.py:2510)"},{"pid":131246,"tid":131246,"ts":1234080175187.269,"ph":"X","cat":"fee","dur":0.53,"name":"ArgumentParser._check_value (/home/ma-user/anaconda3/envs/py311/lib/python3.11/argparse.py:2536)"},{"pid":131246,"tid":131246,"ts":1234080175184.299,"ph":"X","cat":"fee","dur":3.62,"name":"ArgumentParser._get_values (/home/ma-user/anaconda3/envs/py311/lib/python3.11/argparse.py:2454)"},{"pid":131246,"tid":131246,"ts":1234080175188.169,"ph":"X","cat":"fee","dur":0.11,"name":"set.add"},{"pid":131246,"tid":131246,"ts":1234080175188.469,"ph":"X","cat":"fee","dur":0.09,"name":"dict.get"},{"pid":131246,"tid":131246,"ts":1234080175189.199,"ph":"X","cat":"fee","dur":0.3,"name":"builtins.setattr"},{"pid":131246,"tid":131246,"ts":1234080175188.929,"ph":"X","cat":"fee","dur":0.66,"name":"_StoreAction.__call__ (/home/ma-user/anaconda3/envs/py311/lib/python3.11/argparse.py:948)"},{"pid":131246,"tid":131246,"ts":1234080175183.809,"ph":"X","cat":"fee","dur":5.94,"name":"ArgumentParser._parse_known_args.<locals>.take_action (/home/ma-user/anaconda3/envs/py311/lib/python3.11/argparse.py:1953)"},{"pid":131246,"tid":131246,"ts":1234080175178.889,"ph":"X","cat":"fee","dur":11.0,"name":"ArgumentParser._parse_known_args.<locals>.consume_optional (/home/ma-user/anaconda3/envs/py311/lib/python3.11/argparse.py:1974)"},{"pid":131246,"tid":131246,"ts":1234080175190.519,"ph":"X","cat":"fee","dur":0.44,"name":"ArgumentParser._parse_known_args.<locals>.<listcomp> (/home/ma-user/anaconda3/envs/py311/lib/python3.11/argparse.py:2080)"},{"pid":131246,"tid":131246,"ts":1234080175191.119,"ph":"X","cat":"fee","dur":0.24,"name":"builtins.min"},{"pid":131246,"tid":131246,"ts":1234080175192.709,"ph":"X","cat":"fee","dur":0.17,"name":"str.replace"},{"pid":131246,"tid":131246,"ts":1234080175193.989,"ph":"X","cat":"fee","dur":0.11,"name":"str.replace"},{"pid":131246,"tid":131246,"ts":1234080175192.469,"ph":"X","cat":"fee","dur":1.75,"name":"ArgumentParser._get_nargs_pattern (/home/ma-user/anaconda3/envs/py311/lib/python3.11/argparse.py:2321)"},{"pid":131246,"tid":131246,"ts":1234080175194.929,"ph":"X","cat":"fee","dur":0.2,"name":"builtins.isinstance"},{"pid":131246,"tid":131246,"ts":1234080175194.799,"ph":"X","cat":"fee","dur":0.67,"name":"_compile (/home/ma-user/anaconda3/envs/py311/lib/python3.11/re/__init__.py:272)"},{"pid":131246,"tid":131246,"ts":1234080175195.669,"ph":"X","cat":"fee","dur":0.26,"name":"re.Pattern.match"},{"pid":131246,"tid":131246,"ts":1234080175194.589,"ph":"X","cat":"fee","dur":1.44,"name":"match (/home/ma-user/anaconda3/envs/py311/lib/python3.11/re/__init__.py:163)"},{"pid":131246,"tid":131246,"ts":1234080175196.269,"ph":"X","cat":"fee","dur":0.17,"name":"re.Match.group"},{"pid":131246,"tid":131246,"ts":1234080175196.539,"ph":"X","cat":"fee","dur":0.1,"name":"builtins.len"},{"pid":131246,"tid":131246,"ts":1234080175192.279,"ph":"X","cat":"fee","dur":4.42,"name":"ArgumentParser._match_argument (/home/ma-user/anaconda3/envs/py311/lib/python3.11/argparse.py:2180)"},{"pid":131246,"tid":131246,"ts":1234080175197.109,"ph":"X","cat":"fee","dur":0.08,"name":"list.append"},{"pid":131246,"tid":131246,"ts":1234080175197.699,"ph":"X","cat":"fee","dur":0.09,"name":"set.add"},{"pid":131246,"tid":131246,"ts":1234080175198.389,"ph":"X","cat":"fee","dur":0.21,"name":"list.remove"},{"pid":131246,"tid":131246,"ts":1234080175199.109,"ph":"X","cat":"fee","dur":0.08,"name":"builtins.len"},{"pid":131246,"tid":131246,"ts":1234080175200.109,"ph":"X","cat":"fee","dur":0.1,"name":"dict.get"},{"pid":131246,"tid":131246,"ts":1234080175199.899,"ph":"X","cat":"fee","dur":0.42,"name":"_ActionsContainer._registry_get (/home/ma-user/anaconda3/envs/py311/lib/python3.11/argparse.py:1387)"},{"pid":131246,"tid":131246,"ts":1234080175200.499,"ph":"X","cat":"fee","dur":0.06,"name":"builtins.callable"},{"pid":131246,"tid":131246,"ts":1234080175199.639,"ph":"X","cat":"fee","dur":1.3,"name":"ArgumentParser._get_value (/home/ma-user/anaconda3/envs/py311/lib/python3.11/argparse.py:2510)"},{"pid":131246,"tid":131246,"ts":1234080175201.219,"ph":"X","cat":"fee","dur":0.11,"name":"ArgumentParser._check_value (/home/ma-user/anaconda3/envs/py311/lib/python3.11/argparse.py:2536)"},{"pid":131246,"tid":131246,"ts":1234080175198.039,"ph":"X","cat":"fee","dur":3.41,"name":"ArgumentParser._get_values (/home/ma-user/anaconda3/envs/py311/lib/python3.11/argparse.py:2454)"},{"pid":131246,"tid":131246,"ts":1234080175201.719,"ph":"X","cat":"fee","dur":0.08,"name":"set.add"},{"pid":131246,"tid":131246,"ts":1234080175201.949,"ph":"X","cat":"fee","dur":0.09,"name":"dict.get"},{"pid":131246,"tid":131246,"ts":1234080175202.609,"ph":"X","cat":"fee","dur":0.24,"name":"builtins.setattr"},{"pid":131246,"tid":131246,"ts":1234080175202.429,"ph":"X","cat":"fee","dur":0.49,"name":"_StoreAction.__call__ (/home/ma-user/anaconda3/envs/py311/lib/python3.11/argparse.py:948)"},{"pid":131246,"tid":131246,"ts":1234080175197.559,"ph":"X","cat":"fee","dur":5.52,"name":"ArgumentParser._parse_known_args.<locals>.take_action (/home/ma-user/anaconda3/envs/py311/lib/python3.11/argparse.py:1953)"},{"pid":131246,"tid":131246,"ts":1234080175191.669,"ph":"X","cat":"fee","dur":11.56,"name":"ArgumentParser._parse_known_args.<locals>.consume_optional (/home/ma-user/anaconda3/envs/py311/lib/python3.11/argparse.py:1974)"},{"pid":131246,"tid":131246,"ts":1234080175203.809,"ph":"X","cat":"fee","dur":0.43,"name":"ArgumentParser._parse_known_args.<locals>.<listcomp> (/home/ma-user/anaconda3/envs/py311/lib/python3.11/argparse.py:2080)"},{"pid":131246,"tid":131246,"ts":1234080175204.409,"ph":"X","cat":"fee","dur":0.27,"name":"builtins.min"},{"pid":131246,"tid":131246,"ts":1234080175206.009,"ph":"X","cat":"fee","dur":0.19,"name":"str.replace"},{"pid":131246,"tid":131246,"ts":1234080175206.379,"ph":"X","cat":"fee","dur":0.08,"name":"str.replace"},{"pid":131246,"tid":131246,"ts":1234080175205.769,"ph":"X","cat":"fee","dur":0.79,"name":"ArgumentParser._get_nargs_pattern (/home/ma-user/anaconda3/envs/py311/lib/python3.11/argparse.py:2321)"},{"pid":131246,"tid":131246,"ts":1234080175207.199,"ph":"X","cat":"fee","dur":0.21,"name":"builtins.isinstance"},{"pid":131246,"tid":131246,"ts":1234080175207.059,"ph":"X","cat":"fee","dur":0.69,"name":"_compile (/home/ma-user/anaconda3/envs/py311/lib/python3.11/re/__init__.py:272)"},{"pid":131246,"tid":131246,"ts":1234080175207.939,"ph":"X","cat":"fee","dur":0.23,"name":"re.Pattern.match"},{"pid":131246,"tid":131246,"ts":1234080175206.869,"ph":"X","cat":"fee","dur":1.39,"name":"match (/home/ma-user/anaconda3/envs/py311/lib/python3.11/re/__init__.py:163)"},{"pid":131246,"tid":131246,"ts":1234080175208.479,"ph":"X","cat":"fee","dur":0.15,"name":"re.Match.group"},{"pid":131246,"tid":131246,"ts":1234080175208.739,"ph":"X","cat":"fee","dur":0.08,"name":"builtins.len"},{"pid":131246,"tid":131246,"ts":1234080175205.549,"ph":"X","cat":"fee","dur":3.33,"name":"ArgumentParser._match_argument (/home/ma-user/anaconda3/envs/py311/lib/python3.11/argparse.py:2180)"},{"pid":131246,"tid":131246,"ts":1234080175209.249,"ph":"X","cat":"fee","dur":0.09,"name":"list.append"},{"pid":131246,"tid":131246,"ts":1234080175209.829,"ph":"X","cat":"fee","dur":0.1,"name":"set.add"},{"pid":131246,"tid":131246,"ts":1234080175210.529,"ph":"X","cat":"fee","dur":0.19,"name":"list.remove"},{"pid":131246,"tid":131246,"ts":1234080175211.139,"ph":"X","cat":"fee","dur":0.07,"name":"builtins.len"},{"pid":131246,"tid":131246,"ts":1234080175212.099,"ph":"X","cat":"fee","dur":0.09,"name":"dict.get"},{"pid":131246,"tid":131246,"ts":1234080175211.899,"ph":"X","cat":"fee","dur":0.4,"name":"_ActionsContainer._registry_get (/home/ma-user/anaconda3/envs/py311/lib/python3.11/argparse.py:1387)"},{"pid":131246,"tid":131246,"ts":1234080175212.469,"ph":"X","cat":"fee","dur":0.06,"name":"builtins.callable"},{"pid":131246,"tid":131246,"ts":1234080175211.639,"ph":"X","cat":"fee","dur":1.19,"name":"ArgumentParser._get_value (/home/ma-user/anaconda3/envs/py311/lib/python3.11/argparse.py:2510)"},{"pid":131246,"tid":131246,"ts":1234080175213.099,"ph":"X","cat":"fee","dur":0.11,"name":"ArgumentParser._check_value (/home/ma-user/anaconda3/envs/py311/lib/python3.11/argparse.py:2536)"},{"pid":131246,"tid":131246,"ts":1234080175210.189,"ph":"X","cat":"fee","dur":3.14,"name":"ArgumentParser._get_values (/home/ma-user/anaconda3/envs/py311/lib/python3.11/argparse.py:2454)"},{"pid":131246,"tid":131246,"ts":1234080175215.229,"ph":"X","cat":"fee","dur":0.1,"name":"set.add"},{"pid":131246,"tid":131246,"ts":1234080175215.529,"ph":"X","cat":"fee","dur":0.1,"name":"dict.get"},{"pid":131246,"tid":131246,"ts":1234080175216.209,"ph":"X","cat":"fee","dur":0.38,"name":"builtins.setattr"},{"pid":131246,"tid":131246,"ts":1234080175216.039,"ph":"X","cat":"fee","dur":0.63,"name":"_StoreAction.__call__ (/home/ma-user/anaconda3/envs/py311/lib/python3.11/argparse.py:948)"},{"pid":131246,"tid":131246,"ts":1234080175209.689,"ph":"X","cat":"fee","dur":7.16,"name":"ArgumentParser._parse_known_args.<locals>.take_action (/home/ma-user/anaconda3/envs/py311/lib/python3.11/argparse.py:1953)"},{"pid":131246,"tid":131246,"ts":1234080175204.989,"ph":"X","cat":"fee","dur":12.0,"name":"ArgumentParser._parse_known_args.<locals>.consume_optional (/home/ma-user/anaconda3/envs/py311/lib/python3.11/argparse.py:1974)"},{"pid":131246,"tid":131246,"ts":1234080175221.459,"ph":"X","cat":"fee","dur":0.07,"name":"builtins.len"},{"pid":131246,"tid":131246,"ts":1234080175221.209,"ph":"X","cat":"fee","dur":0.83,"name":"ArgumentParser._match_arguments_partial (/home/ma-user/anaconda3/envs/py311/lib/python3.11/argparse.py:2202)"},{"pid":131246,"tid":131246,"ts":1234080175223.259,"ph":"X","cat":"fee","dur":0.06,"name":"builtins.len"},{"pid":131246,"tid":131246,"ts":1234080175218.939,"ph":"X","cat":"fee","dur":4.88,"name":"ArgumentParser._parse_known_args.<locals>.consume_positionals (/home/ma-user/anaconda3/envs/py311/lib/python3.11/argparse.py:2051)"},{"pid":131246,"tid":131246,"ts":1234080175224.329,"ph":"X","cat":"fee","dur":0.1,"name":"list.extend"},{"pid":131246,"tid":131246,"ts":1234080175225.239,"ph":"X","cat":"fee","dur":0.09,"name":"builtins.isinstance"},{"pid":131246,"tid":131246,"ts":1234080175225.519,"ph":"X","cat":"fee","dur":0.16,"name":"builtins.hasattr"},{"pid":131246,"tid":131246,"ts":1234080175226.389,"ph":"X","cat":"fee","dur":0.12,"name":"builtins.isinstance"},{"pid":131246,"tid":131246,"ts":1234080175227.059,"ph":"X","cat":"fee","dur":0.4,"name":"builtins.isinstance"},{"pid":131246,"tid":131246,"ts":1234080175227.769,"ph":"X","cat":"fee","dur":0.12,"name":"builtins.isinstance"},{"pid":131246,"tid":131246,"ts":1234080175228.279,"ph":"X","cat":"fee","dur":0.12,"name":"builtins.isinstance"},{"pid":131246,"tid":131246,"ts":1234080175228.639,"ph":"X","cat":"fee","dur":0.08,"name":"builtins.isinstance"},{"pid":131246,"tid":131246,"ts":1234080175228.979,"ph":"X","cat":"fee","dur":0.06,"name":"builtins.isinstance"},{"pid":131246,"tid":131246,"ts":1234080175229.199,"ph":"X","cat":"fee","dur":0.2,"name":"builtins.hasattr"},{"pid":131246,"tid":131246,"ts":1234080175229.629,"ph":"X","cat":"fee","dur":0.15,"name":"builtins.getattr"},{"pid":131246,"tid":131246,"ts":1234080175230.699,"ph":"X","cat":"fee","dur":0.08,"name":"dict.get"},{"pid":131246,"tid":131246,"ts":1234080175230.499,"ph":"X","cat":"fee","dur":0.39,"name":"_ActionsContainer._registry_get (/home/ma-user/anaconda3/envs/py311/lib/python3.11/argparse.py:1387)"},{"pid":131246,"tid":131246,"ts":1234080175231.049,"ph":"X","cat":"fee","dur":0.07,"name":"builtins.callable"},{"pid":131246,"tid":131246,"ts":1234080175230.239,"ph":"X","cat":"fee","dur":1.17,"name":"ArgumentParser._get_value (/home/ma-user/anaconda3/envs/py311/lib/python3.11/argparse.py:2510)"},{"pid":131246,"tid":131246,"ts":1234080175231.56,"ph":"X","cat":"fee","dur":0.25,"name":"builtins.setattr"},{"pid":131246,"tid":131246,"ts":1234080175232.2,"ph":"X","cat":"fee","dur":0.08,"name":"builtins.isinstance"},{"pid":131246,"tid":131246,"ts":1234080175232.43,"ph":"X","cat":"fee","dur":0.15,"name":"builtins.hasattr"},{"pid":131246,"tid":131246,"ts":1234080175232.8,"ph":"X","cat":"fee","dur":0.13,"name":"builtins.getattr"},{"pid":131246,"tid":131246,"ts":1234080175233.69,"ph":"X","cat":"fee","dur":0.06,"name":"dict.get"},{"pid":131246,"tid":131246,"ts":1234080175233.52,"ph":"X","cat":"fee","dur":0.32,"name":"_ActionsContainer._registry_get (/home/ma-user/anaconda3/envs/py311/lib/python3.11/argparse.py:1387)"},{"pid":131246,"tid":131246,"ts":1234080175234.0,"ph":"X","cat":"fee","dur":0.08,"name":"builtins.callable"},{"pid":131246,"tid":131246,"ts":1234080175233.26,"ph":"X","cat":"fee","dur":1.02,"name":"ArgumentParser._get_value (/home/ma-user/anaconda3/envs/py311/lib/python3.11/argparse.py:2510)"},{"pid":131246,"tid":131246,"ts":1234080175234.43,"ph":"X","cat":"fee","dur":0.36,"name":"builtins.setattr"},{"pid":131246,"tid":131246,"ts":1234080174949.597,"ph":"X","cat":"fee","dur":285.633,"name":"ArgumentParser._parse_known_args (/home/ma-user/anaconda3/envs/py311/lib/python3.11/argparse.py:1906)"},{"pid":131246,"tid":131246,"ts":1234080175237.39,"ph":"X","cat":"fee","dur":0.16,"name":"builtins.hasattr"},{"pid":131246,"tid":131246,"ts":1234080174913.336,"ph":"X","cat":"fee","dur":324.344,"name":"ArgumentParser.parse_known_args (/home/ma-user/anaconda3/envs/py311/lib/python3.11/argparse.py:1868)"},{"pid":131246,"tid":131246,"ts":1234080174908.806,"ph":"X","cat":"fee","dur":329.214,"name":"ArgumentParser.parse_args (/home/ma-user/anaconda3/envs/py311/lib/python3.11/argparse.py:1861)"},{"pid":131246,"tid":131246,"ts":1234080175280.52,"ph":"X","cat":"fee","dur":14.33,"name":"socket.__init__ (/home/ma-user/anaconda3/envs/py311/lib/python3.11/socket.py:220)"},{"pid":131246,"tid":131246,"ts":1234080175295.95,"ph":"X","cat":"fee","dur":0.08,"name":"socket.__enter__ (/home/ma-user/anaconda3/envs/py311/lib/python3.11/socket.py:236)"},{"pid":131246,"tid":131246,"ts":1234080175296.66,"ph":"X","cat":"fee","dur":11.99,"name":"socket.bind"},{"pid":131246,"tid":131246,"ts":1234080175312.48,"ph":"X","cat":"fee","dur":12.05,"name":"socket.close"},{"pid":131246,"tid":131246,"ts":1234080175312.12,"ph":"X","cat":"fee","dur":12.62,"name":"socket._real_close (/home/ma-user/anaconda3/envs/py311/lib/python3.11/socket.py:494)"},{"pid":131246,"tid":131246,"ts":1234080175311.0,"ph":"X","cat":"fee","dur":13.93,"name":"socket.close (/home/ma-user/anaconda3/envs/py311/lib/python3.11/socket.py:498)"},{"pid":131246,"tid":131246,"ts":1234080175309.72,"ph":"X","cat":"fee","dur":15.36,"name":"socket.__exit__ (/home/ma-user/anaconda3/envs/py311/lib/python3.11/socket.py:239)"},{"pid":131246,"tid":131246,"ts":1234080175277.69,"ph":"X","cat":"fee","dur":47.7,"name":"is_port_available (/home/lc/omni_infer/tools/scripts/start_api_servers.py:34)"},{"pid":131246,"tid":131246,"ts":1234080175275.28,"ph":"X","cat":"fee","dur":53.12,"name":"find_available_port (/home/lc/omni_infer/tools/scripts/start_api_servers.py:44)"},{"pid":131246,"tid":131246,"ts":1234080175456.892,"ph":"X","cat":"fee","dur":4.98,"name":"socket.__init__ (/home/ma-user/anaconda3/envs/py311/lib/python3.11/socket.py:220)"},{"pid":131246,"tid":131246,"ts":1234080175462.502,"ph":"X","cat":"fee","dur":0.09,"name":"socket.__enter__ (/home/ma-user/anaconda3/envs/py311/lib/python3.11/socket.py:236)"},{"pid":131246,"tid":131246,"ts":1234080175463.042,"ph":"X","cat":"fee","dur":1.87,"name":"socket.bind"},{"pid":131246,"tid":131246,"ts":1234080175466.562,"ph":"X","cat":"fee","dur":2.76,"name":"socket.close"},{"pid":131246,"tid":131246,"ts":1234080175466.282,"ph":"X","cat":"fee","dur":3.21,"name":"socket._real_close (/home/ma-user/anaconda3/envs/py311/lib/python3.11/socket.py:494)"},{"pid":131246,"tid":131246,"ts":1234080175465.742,"ph":"X","cat":"fee","dur":3.95,"name":"socket.close (/home/ma-user/anaconda3/envs/py311/lib/python3.11/socket.py:498)"},{"pid":131246,"tid":131246,"ts":1234080175465.332,"ph":"X","cat":"fee","dur":4.51,"name":"socket.__exit__ (/home/ma-user/anaconda3/envs/py311/lib/python3.11/socket.py:239)"},{"pid":131246,"tid":131246,"ts":1234080175456.122,"ph":"X","cat":"fee","dur":13.98,"name":"is_port_available (/home/lc/omni_infer/tools/scripts/start_api_servers.py:34)"},{"pid":131246,"tid":131246,"ts":1234080175455.432,"ph":"X","cat":"fee","dur":15.09,"name":"find_available_port (/home/lc/omni_infer/tools/scripts/start_api_servers.py:44)"},{"pid":131246,"tid":131246,"ts":1234080175479.842,"ph":"X","cat":"fee","dur":0.53,"name":"str.split"},{"pid":131246,"tid":131246,"ts":1234080175480.542,"ph":"X","cat":"fee","dur":0.19,"name":"list.extend"},{"pid":131246,"tid":131246,"ts":1234080175486.152,"ph":"X","cat":"fee","dur":100.561,"name":"io.open"},{"pid":131246,"tid":131246,"ts":1234080175587.743,"ph":"X","cat":"fee","dur":15.34,"name":"builtins.print"},{"pid":131246,"tid":131246,"ts":1234080175604.273,"ph":"X","cat":"fee","dur":5.56,"name":"builtins.print"},{"pid":131246,"tid":131246,"ts":1234080175610.263,"ph":"X","cat":"fee","dur":4.46,"name":"builtins.print"},{"pid":131246,"tid":131246,"ts":1234080175615.283,"ph":"X","cat":"fee","dur":0.82,"name":"str.join"},{"pid":131246,"tid":131246,"ts":1234080175616.533,"ph":"X","cat":"fee","dur":6.05,"name":"builtins.print"},{"pid":131246,"tid":131246,"ts":1234080176505.322,"ph":"X","cat":"fee","dur":0.41,"name":"list.append"},{"pid":131246,"tid":131246,"ts":1234080176507.372,"ph":"X","cat":"fee","dur":0.45,"name":"ProcessManager.__init__ (/home/lc/omni_infer/tools/scripts/start_api_servers.py:55)"},{"pid":131246,"tid":131246,"ts":1234080176513.422,"ph":"X","cat":"fee","dur":0.67,"name":"atexit.register"},{"pid":131246,"tid":131246,"ts":1234080176517.302,"ph":"X","cat":"fee","dur":0.24,"name":"builtins.next"},{"pid":131246,"tid":131246,"ts":1234080176511.512,"ph":"X","cat":"fee","dur":7.14,"name":"finalize.__init__ (/home/ma-user/anaconda3/envs/py311/lib/python3.11/weakref.py:568)"},{"pid":131246,"tid":131246,"ts":1234080176519.542,"ph":"X","cat":"fee","dur":10.29,"name":"builtins.print"},{"pid":131246,"tid":131246,"ts":1234080176531.482,"ph":"X","cat":"fee","dur":4.11,"name":"builtins.print"},{"pid":131246,"tid":131246,"ts":1234080176536.032,"ph":"X","cat":"fee","dur":4.5,"name":"builtins.print"},{"pid":131246,"tid":131246,"ts":1234080175250.62,"ph":"X","cat":"fee","dur":1290.182,"name":"start_single_node_api_servers (/home/lc/omni_infer/tools/scripts/start_api_servers.py:59)"},{"pid":131246,"tid":131246,"ts":1234080176546.442,"ph":"X","cat":"fee","dur":0.65,"name":"_enum_to_int (/home/ma-user/anaconda3/envs/py311/lib/python3.11/signal.py:34)"},{"pid":131246,"tid":131246,"ts":1234080176547.382,"ph":"X","cat":"fee","dur":3.01,"name":"_enum_to_int (/home/ma-user/anaconda3/envs/py311/lib/python3.11/signal.py:34)"},{"pid":131246,"tid":131246,"ts":1234080176550.542,"ph":"X","cat":"fee","dur":1.0,"name":"_signal.signal"},{"pid":131246,"tid":131246,"ts":1234080176557.952,"ph":"X","cat":"fee","dur":0.11,"name":"Enum._missing_ (/home/ma-user/anaconda3/envs/py311/lib/python3.11/enum.py:1163)"},{"pid":131246,"tid":131246,"ts":1234080176558.432,"ph":"X","cat":"fee","dur":0.7,"name":"builtins.isinstance"},{"pid":131246,"tid":131246,"ts":1234080176559.722,"ph":"X","cat":"fee","dur":0.51,"name":"builtins.issubclass"},{"pid":131246,"tid":131246,"ts":1234080176554.842,"ph":"X","cat":"fee","dur":8.45,"name":"Enum.__new__ (/home/ma-user/anaconda3/envs/py311/lib/python3.11/enum.py:1074)"},{"pid":131246,"tid":131246,"ts":1234080176553.422,"ph":"X","cat":"fee","dur":10.09,"name":"EnumType.__call__ (/home/ma-user/anaconda3/envs/py311/lib/python3.11/enum.py:669)"},{"pid":131246,"tid":131246,"ts":1234080176552.172,"ph":"X","cat":"fee","dur":12.3,"name":"_int_to_enum (/home/ma-user/anaconda3/envs/py311/lib/python3.11/signal.py:24)"},{"pid":131246,"tid":131246,"ts":1234080176545.742,"ph":"X","cat":"fee","dur":18.89,"name":"signal (/home/ma-user/anaconda3/envs/py311/lib/python3.11/signal.py:54)"},{"pid":131246,"tid":131246,"ts":1234080176565.622,"ph":"X","cat":"fee","dur":4.86,"name":"builtins.print"},{"pid":131246,"tid":131246,"ts":1234080176570.952,"ph":"X","cat":"fee","dur":1000058.11,"name":"time.sleep"},{"pid":131246,"tid":131246,"ts":1234081176643.632,"ph":"X","cat":"fee","dur":2.141,"name":"_thread.lock.acquire"},{"pid":131246,"tid":131246,"ts":1234081176646.323,"ph":"X","cat":"fee","dur":4.99,"name":"posix.waitpid"},{"pid":131246,"tid":131246,"ts":1234081176652.993,"ph":"X","cat":"fee","dur":0.22,"name":"_thread.lock.release"},{"pid":131246,"tid":131246,"ts":1234081176642.262,"ph":"X","cat":"fee","dur":11.371,"name":"Popen._internal_poll (/home/ma-user/anaconda3/envs/py311/lib/python3.11/subprocess.py:1915)"},{"pid":131246,"tid":131246,"ts":1234081176637.562,"ph":"X","cat":"fee","dur":16.601,"name":"Popen.poll (/home/ma-user/anaconda3/envs/py311/lib/python3.11/subprocess.py:1229)"},{"pid":131246,"tid":131246,"ts":1234081176655.623,"ph":"X","cat":"fee","dur":1000057.52,"name":"time.sleep"},{"pid":131246,"tid":131246,"ts":1234082176721.293,"ph":"X","cat":"fee","dur":1.76,"name":"_thread.lock.acquire"},{"pid":131246,"tid":131246,"ts":1234082176723.673,"ph":"X","cat":"fee","dur":4.01,"name":"posix.waitpid"},{"pid":131246,"tid":131246,"ts":1234082176732.273,"ph":"X","cat":"fee","dur":0.27,"name":"_thread.lock.release"},{"pid":131246,"tid":131246,"ts":1234082176719.993,"ph":"X","cat":"fee","dur":12.77,"name":"Popen._internal_poll (/home/ma-user/anaconda3/envs/py311/lib/python3.11/subprocess.py:1915)"},{"pid":131246,"tid":131246,"ts":1234082176719.343,"ph":"X","cat":"fee","dur":13.88,"name":"Popen.poll (/home/ma-user/anaconda3/envs/py311/lib/python3.11/subprocess.py:1229)"},{"pid":131246,"tid":131246,"ts":1234082176734.183,"ph":"X","cat":"fee","dur":1000057.35,"name":"time.sleep"},{"pid":131246,"tid":131246,"ts":1234083176795.863,"ph":"X","cat":"fee","dur":0.97,"name":"_thread.lock.acquire"},{"pid":131246,"tid":131246,"ts":1234083176797.413,"ph":"X","cat":"fee","dur":3.38,"name":"posix.waitpid"},{"pid":131246,"tid":131246,"ts":1234083176801.343,"ph":"X","cat":"fee","dur":0.18,"name":"_thread.lock.release"},{"pid":131246,"tid":131246,"ts":1234083176795.193,"ph":"X","cat":"fee","dur":6.52,"name":"Popen._internal_poll (/home/ma-user/anaconda3/envs/py311/lib/python3.11/subprocess.py:1915)"},{"pid":131246,"tid":131246,"ts":1234083176794.813,"ph":"X","cat":"fee","dur":7.21,"name":"Popen.poll (/home/ma-user/anaconda3/envs/py311/lib/python3.11/subprocess.py:1229)"},{"pid":131246,"tid":131246,"ts":1234083176802.703,"ph":"X","cat":"fee","dur":1000055.82,"name":"time.sleep"},{"pid":131246,"tid":131246,"ts":1234084176862.993,"ph":"X","cat":"fee","dur":1.15,"name":"_thread.lock.acquire"},{"pid":131246,"tid":131246,"ts":1234084176864.523,"ph":"X","cat":"fee","dur":4.02,"name":"posix.waitpid"},{"pid":131246,"tid":131246,"ts":1234084176869.253,"ph":"X","cat":"fee","dur":0.08,"name":"_thread.lock.release"},{"pid":131246,"tid":131246,"ts":1234084176862.263,"ph":"X","cat":"fee","dur":7.3,"name":"Popen._internal_poll (/home/ma-user/anaconda3/envs/py311/lib/python3.11/subprocess.py:1915)"},{"pid":131246,"tid":131246,"ts":1234084176861.943,"ph":"X","cat":"fee","dur":8.03,"name":"Popen.poll (/home/ma-user/anaconda3/envs/py311/lib/python3.11/subprocess.py:1229)"},{"pid":131246,"tid":131246,"ts":1234084176872.923,"ph":"X","cat":"fee","dur":1000054.89,"name":"time.sleep"},{"pid":131246,"tid":131246,"ts":1234085176930.494,"ph":"X","cat":"fee","dur":0.67,"name":"_thread.lock.acquire"},{"pid":131246,"tid":131246,"ts":1234085176931.454,"ph":"X","cat":"fee","dur":2.94,"name":"posix.waitpid"},{"pid":131246,"tid":131246,"ts":1234085176934.834,"ph":"X","cat":"fee","dur":0.09,"name":"_thread.lock.release"},{"pid":131246,"tid":131246,"ts":1234085176930.104,"ph":"X","cat":"fee","dur":4.97,"name":"Popen._internal_poll (/home/ma-user/anaconda3/envs/py311/lib/python3.11/subprocess.py:1915)"},{"pid":131246,"tid":131246,"ts":1234085176929.834,"ph":"X","cat":"fee","dur":5.41,"name":"Popen.poll (/home/ma-user/anaconda3/envs/py311/lib/python3.11/subprocess.py:1229)"},{"pid":131246,"tid":131246,"ts":1234085176935.694,"ph":"X","cat":"fee","dur":1000056.89,"name":"time.sleep"},{"pid":131246,"tid":131246,"ts":1234086176997.234,"ph":"X","cat":"fee","dur":1.44,"name":"_thread.lock.acquire"},{"pid":131246,"tid":131246,"ts":1234086176998.894,"ph":"X","cat":"fee","dur":5.01,"name":"posix.waitpid"},{"pid":131246,"tid":131246,"ts":1234086177004.424,"ph":"X","cat":"fee","dur":0.09,"name":"_thread.lock.release"},{"pid":131246,"tid":131246,"ts":1234086176996.614,"ph":"X","cat":"fee","dur":8.03,"name":"Popen._internal_poll (/home/ma-user/anaconda3/envs/py311/lib/python3.11/subprocess.py:1915)"},{"pid":131246,"tid":131246,"ts":1234086176996.364,"ph":"X","cat":"fee","dur":8.5,"name":"Popen.poll (/home/ma-user/anaconda3/envs/py311/lib/python3.11/subprocess.py:1229)"},{"pid":131246,"tid":131246,"ts":1234086177005.544,"ph":"X","cat":"fee","dur":1000055.84,"name":"time.sleep"},{"pid":131246,"tid":131246,"ts":1234087177065.224,"ph":"X","cat":"fee","dur":1.51,"name":"_thread.lock.acquire"},{"pid":131246,"tid":131246,"ts":1234087177067.074,"ph":"X","cat":"fee","dur":4.14,"name":"posix.waitpid"},{"pid":131246,"tid":131246,"ts":1234087177071.724,"ph":"X","cat":"fee","dur":0.66,"name":"_thread.lock.release"},{"pid":131246,"tid":131246,"ts":1234087177064.734,"ph":"X","cat":"fee","dur":7.8,"name":"Popen._internal_poll (/home/ma-user/anaconda3/envs/py311/lib/python3.11/subprocess.py:1915)"},{"pid":131246,"tid":131246,"ts":1234087177064.454,"ph":"X","cat":"fee","dur":8.3,"name":"Popen.poll (/home/ma-user/anaconda3/envs/py311/lib/python3.11/subprocess.py:1229)"},{"pid":131246,"tid":131246,"ts":1234087177073.344,"ph":"X","cat":"fee","dur":1000056.49,"name":"time.sleep"},{"pid":131246,"tid":131246,"ts":1234088177134.374,"ph":"X","cat":"fee","dur":1.05,"name":"_thread.lock.acquire"},{"pid":131246,"tid":131246,"ts":1234088177135.704,"ph":"X","cat":"fee","dur":5.12,"name":"posix.waitpid"},{"pid":131246,"tid":131246,"ts":1234088177141.294,"ph":"X","cat":"fee","dur":0.1,"name":"_thread.lock.release"},{"pid":131246,"tid":131246,"ts":1234088177133.074,"ph":"X","cat":"fee","dur":8.48,"name":"Popen._internal_poll (/home/ma-user/anaconda3/envs/py311/lib/python3.11/subprocess.py:1915)"},{"pid":131246,"tid":131246,"ts":1234088177132.604,"ph":"X","cat":"fee","dur":9.36,"name":"Popen.poll (/home/ma-user/anaconda3/envs/py311/lib/python3.11/subprocess.py:1229)"},{"pid":131246,"tid":131246,"ts":1234088177142.454,"ph":"X","cat":"fee","dur":1000057.2,"name":"time.sleep"},{"pid":131246,"tid":131246,"ts":1234089177206.724,"ph":"X","cat":"fee","dur":2.57,"name":"_thread.lock.acquire"},{"pid":131246,"tid":131246,"ts":1234089177209.874,"ph":"X","cat":"fee","dur":4.04,"name":"posix.waitpid"},{"pid":131246,"tid":131246,"ts":1234089177214.464,"ph":"X","cat":"fee","dur":0.1,"name":"_thread.lock.release"},{"pid":131246,"tid":131246,"ts":1234089177205.614,"ph":"X","cat":"fee","dur":9.28,"name":"Popen._internal_poll (/home/ma-user/anaconda3/envs/py311/lib/python3.11/subprocess.py:1915)"},{"pid":131246,"tid":131246,"ts":1234089177205.234,"ph":"X","cat":"fee","dur":10.41,"name":"Popen.poll (/home/ma-user/anaconda3/envs/py311/lib/python3.11/subprocess.py:1229)"},{"pid":131246,"tid":131246,"ts":1234089177216.314,"ph":"X","cat":"fee","dur":1000055.31,"name":"time.sleep"},{"pid":131246,"tid":131246,"ts":1234090177275.074,"ph":"X","cat":"fee","dur":0.96,"name":"_thread.lock.acquire"},{"pid":131246,"tid":131246,"ts":1234090177283.235,"ph":"X","cat":"fee","dur":3.29,"name":"posix.waitpid"},{"pid":131246,"tid":131246,"ts":1234090177287.085,"ph":"X","cat":"fee","dur":0.13,"name":"_thread.lock.release"},{"pid":131246,"tid":131246,"ts":1234090177274.584,"ph":"X","cat":"fee","dur":12.791,"name":"Popen._internal_poll (/home/ma-user/anaconda3/envs/py311/lib/python3.11/subprocess.py:1915)"},{"pid":131246,"tid":131246,"ts":1234090177274.314,"ph":"X","cat":"fee","dur":13.411,"name":"Popen.poll (/home/ma-user/anaconda3/envs/py311/lib/python3.11/subprocess.py:1229)"},{"pid":131246,"tid":131246,"ts":1234090177288.185,"ph":"X","cat":"fee","dur":1000056.58,"name":"time.sleep"},{"pid":131246,"tid":131246,"ts":1234091177348.696,"ph":"X","cat":"fee","dur":1.86,"name":"_thread.lock.acquire"},{"pid":131246,"tid":131246,"ts":1234091177350.836,"ph":"X","cat":"fee","dur":4.02,"name":"posix.waitpid"},{"pid":131246,"tid":131246,"ts":1234091177355.356,"ph":"X","cat":"fee","dur":0.1,"name":"_thread.lock.release"},{"pid":131246,"tid":131246,"ts":1234091177348.166,"ph":"X","cat":"fee","dur":7.46,"name":"Popen._internal_poll (/home/ma-user/anaconda3/envs/py311/lib/python3.11/subprocess.py:1915)"},{"pid":131246,"tid":131246,"ts":1234091177347.856,"ph":"X","cat":"fee","dur":8.03,"name":"Popen.poll (/home/ma-user/anaconda3/envs/py311/lib/python3.11/subprocess.py:1229)"},{"pid":131246,"tid":131246,"ts":1234091177356.566,"ph":"X","cat":"fee","dur":1000056.42,"name":"time.sleep"},{"pid":131246,"tid":131246,"ts":1234092177416.816,"ph":"X","cat":"fee","dur":1.45,"name":"_thread.lock.acquire"},{"pid":131246,"tid":131246,"ts":1234092177418.646,"ph":"X","cat":"fee","dur":5.01,"name":"posix.waitpid"},{"pid":131246,"tid":131246,"ts":1234092177424.166,"ph":"X","cat":"fee","dur":0.15,"name":"_thread.lock.release"},{"pid":131246,"tid":131246,"ts":1234092177416.256,"ph":"X","cat":"fee","dur":8.28,"name":"Popen._internal_poll (/home/ma-user/anaconda3/envs/py311/lib/python3.11/subprocess.py:1915)"},{"pid":131246,"tid":131246,"ts":1234092177416.026,"ph":"X","cat":"fee","dur":8.92,"name":"Popen.poll (/home/ma-user/anaconda3/envs/py311/lib/python3.11/subprocess.py:1229)"},{"pid":131246,"tid":131246,"ts":1234092177425.436,"ph":"X","cat":"fee","dur":1000055.1,"name":"time.sleep"},{"pid":131246,"tid":131246,"ts":1234093177484.526,"ph":"X","cat":"fee","dur":2.02,"name":"_thread.lock.acquire"},{"pid":131246,"tid":131246,"ts":1234093177486.816,"ph":"X","cat":"fee","dur":5.11,"name":"posix.waitpid"},{"pid":131246,"tid":131246,"ts":1234093177492.406,"ph":"X","cat":"fee","dur":0.34,"name":"_thread.lock.release"},{"pid":131246,"tid":131246,"ts":1234093177483.926,"ph":"X","cat":"fee","dur":8.97,"name":"Popen._internal_poll (/home/ma-user/anaconda3/envs/py311/lib/python3.11/subprocess.py:1915)"},{"pid":131246,"tid":131246,"ts":1234093177483.646,"ph":"X","cat":"fee","dur":9.64,"name":"Popen.poll (/home/ma-user/anaconda3/envs/py311/lib/python3.11/subprocess.py:1229)"},{"pid":131246,"tid":131246,"ts":1234093177494.026,"ph":"X","cat":"fee","dur":1000058.35,"name":"time.sleep"},{"pid":131246,"tid":131246,"ts":1234094177561.246,"ph":"X","cat":"fee","dur":2.47,"name":"_thread.lock.acquire"},{"pid":131246,"tid":131246,"ts":1234094177564.436,"ph":"X","cat":"fee","dur":5.71,"name":"posix.waitpid"},{"pid":131246,"tid":131246,"ts":1234094177571.406,"ph":"X","cat":"fee","dur":0.16,"name":"_thread.lock.release"},{"pid":131246,"tid":131246,"ts":1234094177560.016,"ph":"X","cat":"fee","dur":11.74,"name":"Popen._internal_poll (/home/ma-user/anaconda3/envs/py311/lib/python3.11/subprocess.py:1915)"},{"pid":131246,"tid":131246,"ts":1234094177559.366,"ph":"X","cat":"fee","dur":12.97,"name":"Popen.poll (/home/ma-user/anaconda3/envs/py311/lib/python3.11/subprocess.py:1229)"},{"pid":131246,"tid":131246,"ts":1234094177573.456,"ph":"X","cat":"fee","dur":1000055.07,"name":"time.sleep"},{"pid":131246,"tid":131246,"ts":1234095177632.046,"ph":"X","cat":"fee","dur":0.48,"name":"_thread.lock.acquire"},{"pid":131246,"tid":131246,"ts":1234095177632.756,"ph":"X","cat":"fee","dur":3.22,"name":"posix.waitpid"},{"pid":131246,"tid":131246,"ts":1234095177636.696,"ph":"X","cat":"fee","dur":0.08,"name":"_thread.lock.release"},{"pid":131246,"tid":131246,"ts":1234095177631.816,"ph":"X","cat":"fee","dur":5.12,"name":"Popen._internal_poll (/home/ma-user/anaconda3/envs/py311/lib/python3.11/subprocess.py:1915)"},{"pid":131246,"tid":131246,"ts":1234095177631.546,"ph":"X","cat":"fee","dur":5.6,"name":"Popen.poll (/home/ma-user/anaconda3/envs/py311/lib/python3.11/subprocess.py:1229)"},{"pid":131246,"tid":131246,"ts":1234095177637.586,"ph":"X","cat":"fee","dur":1000061.13,"name":"time.sleep"},{"pid":131246,"tid":131246,"ts":1234096177710.846,"ph":"X","cat":"fee","dur":5.54,"name":"_thread.lock.acquire"},{"pid":131246,"tid":131246,"ts":1234096177716.946,"ph":"X","cat":"fee","dur":7.03,"name":"posix.waitpid"},{"pid":131246,"tid":131246,"ts":1234096177725.606,"ph":"X","cat":"fee","dur":0.35,"name":"_thread.lock.release"},{"pid":131246,"tid":131246,"ts":1234096177708.546,"ph":"X","cat":"fee","dur":17.94,"name":"Popen._internal_poll (/home/ma-user/anaconda3/envs/py311/lib/python3.11/subprocess.py:1915)"},{"pid":131246,"tid":131246,"ts":1234096177708.036,"ph":"X","cat":"fee","dur":19.41,"name":"Popen.poll (/home/ma-user/anaconda3/envs/py311/lib/python3.11/subprocess.py:1229)"},{"pid":131246,"tid":131246,"ts":1234096177728.696,"ph":"X","cat":"fee","dur":1000056.59,"name":"time.sleep"},{"pid":131246,"tid":131246,"ts":1234097177790.327,"ph":"X","cat":"fee","dur":1.74,"name":"_thread.lock.acquire"},{"pid":131246,"tid":131246,"ts":1234097177792.367,"ph":"X","cat":"fee","dur":4.34,"name":"posix.waitpid"},{"pid":131246,"tid":131246,"ts":1234097177797.417,"ph":"X","cat":"fee","dur":0.15,"name":"_thread.lock.release"},{"pid":131246,"tid":131246,"ts":1234097177789.527,"ph":"X","cat":"fee","dur":8.24,"name":"Popen._internal_poll (/home/ma-user/anaconda3/envs/py311/lib/python3.11/subprocess.py:1915)"},{"pid":131246,"tid":131246,"ts":1234097177789.177,"ph":"X","cat":"fee","dur":8.97,"name":"Popen.poll (/home/ma-user/anaconda3/envs/py311/lib/python3.11/subprocess.py:1229)"},{"pid":131246,"tid":131246,"ts":1234097177803.987,"ph":"X","cat":"fee","dur":1000057.15,"name":"time.sleep"},{"pid":131246,"tid":131246,"ts":1234098177863.787,"ph":"X","cat":"fee","dur":1.08,"name":"_thread.lock.acquire"},{"pid":131246,"tid":131246,"ts":1234098177865.147,"ph":"X","cat":"fee","dur":3.58,"name":"posix.waitpid"},{"pid":131246,"tid":131246,"ts":1234098177869.167,"ph":"X","cat":"fee","dur":0.08,"name":"_thread.lock.release"},{"pid":131246,"tid":131246,"ts":1234098177863.247,"ph":"X","cat":"fee","dur":6.16,"name":"Popen._internal_poll (/home/ma-user/anaconda3/envs/py311/lib/python3.11/subprocess.py:1915)"},{"pid":131246,"tid":131246,"ts":1234098177863.007,"ph":"X","cat":"fee","dur":6.59,"name":"Popen.poll (/home/ma-user/anaconda3/envs/py311/lib/python3.11/subprocess.py:1229)"},{"pid":131246,"tid":131246,"ts":1234098177869.977,"ph":"X","cat":"fee","dur":1000056.57,"name":"time.sleep"},{"pid":131246,"tid":131246,"ts":1234099177930.457,"ph":"X","cat":"fee","dur":1.16,"name":"_thread.lock.acquire"},{"pid":131246,"tid":131246,"ts":1234099177931.957,"ph":"X","cat":"fee","dur":4.651,"name":"posix.waitpid"},{"pid":131246,"tid":131246,"ts":1234099177937.198,"ph":"X","cat":"fee","dur":0.09,"name":"_thread.lock.release"},{"pid":131246,"tid":131246,"ts":1234099177929.797,"ph":"X","cat":"fee","dur":7.651,"name":"Popen._internal_poll (/home/ma-user/anaconda3/envs/py311/lib/python3.11/subprocess.py:1915)"},{"pid":131246,"tid":131246,"ts":1234099177929.457,"ph":"X","cat":"fee","dur":8.261,"name":"Popen.poll (/home/ma-user/anaconda3/envs/py311/lib/python3.11/subprocess.py:1229)"},{"pid":131246,"tid":131246,"ts":1234099177938.178,"ph":"X","cat":"fee","dur":1000056.339,"name":"time.sleep"},{"pid":131246,"tid":131246,"ts":1234100177998.818,"ph":"X","cat":"fee","dur":1.1,"name":"_thread.lock.acquire"},{"pid":131246,"tid":131246,"ts":1234100178000.158,"ph":"X","cat":"fee","dur":4.06,"name":"posix.waitpid"},{"pid":131246,"tid":131246,"ts":1234100178004.668,"ph":"X","cat":"fee","dur":0.07,"name":"_thread.lock.release"},{"pid":131246,"tid":131246,"ts":1234100177998.148,"ph":"X","cat":"fee","dur":6.78,"name":"Popen._internal_poll (/home/ma-user/anaconda3/envs/py311/lib/python3.11/subprocess.py:1915)"},{"pid":131246,"tid":131246,"ts":1234100177997.888,"ph":"X","cat":"fee","dur":7.71,"name":"Popen.poll (/home/ma-user/anaconda3/envs/py311/lib/python3.11/subprocess.py:1229)"},{"pid":131246,"tid":131246,"ts":1234100178005.938,"ph":"X","cat":"fee","dur":1000054.6,"name":"time.sleep"},{"pid":131246,"tid":131246,"ts":1234101178063.408,"ph":"X","cat":"fee","dur":0.83,"name":"_thread.lock.acquire"},{"pid":131246,"tid":131246,"ts":1234101178064.488,"ph":"X","cat":"fee","dur":5.16,"name":"posix.waitpid"},{"pid":131246,"tid":131246,"ts":1234101178070.088,"ph":"X","cat":"fee","dur":0.07,"name":"_thread.lock.release"},{"pid":131246,"tid":131246,"ts":1234101178062.968,"ph":"X","cat":"fee","dur":7.4,"name":"Popen._internal_poll (/home/ma-user/anaconda3/envs/py311/lib/python3.11/subprocess.py:1915)"},{"pid":131246,"tid":131246,"ts":1234101178062.678,"ph":"X","cat":"fee","dur":8.01,"name":"Popen.poll (/home/ma-user/anaconda3/envs/py311/lib/python3.11/subprocess.py:1229)"},{"pid":131246,"tid":131246,"ts":1234101178070.958,"ph":"X","cat":"fee","dur":1000057.41,"name":"time.sleep"},{"pid":131246,"tid":131246,"ts":1234102178132.258,"ph":"X","cat":"fee","dur":1.01,"name":"_thread.lock.acquire"},{"pid":131246,"tid":131246,"ts":1234102178133.598,"ph":"X","cat":"fee","dur":3.26,"name":"posix.waitpid"},{"pid":131246,"tid":131246,"ts":1234102178137.268,"ph":"X","cat":"fee","dur":0.08,"name":"_thread.lock.release"},{"pid":131246,"tid":131246,"ts":1234102178131.808,"ph":"X","cat":"fee","dur":5.75,"name":"Popen._internal_poll (/home/ma-user/anaconda3/envs/py311/lib/python3.11/subprocess.py:1915)"},{"pid":131246,"tid":131246,"ts":1234102178131.548,"ph":"X","cat":"fee","dur":6.35,"name":"Popen.poll (/home/ma-user/anaconda3/envs/py311/lib/python3.11/subprocess.py:1229)"},{"pid":131246,"tid":131246,"ts":1234102178138.278,"ph":"X","cat":"fee","dur":1000059.34,"name":"time.sleep"},{"pid":131246,"tid":131246,"ts":1234103178205.029,"ph":"X","cat":"fee","dur":3.33,"name":"_thread.lock.acquire"},{"pid":131246,"tid":131246,"ts":1234103178209.109,"ph":"X","cat":"fee","dur":7.58,"name":"posix.waitpid"},{"pid":131246,"tid":131246,"ts":1234103178217.919,"ph":"X","cat":"fee","dur":0.08,"name":"_thread.lock.release"},{"pid":131246,"tid":131246,"ts":1234103178203.519,"ph":"X","cat":"fee","dur":14.92,"name":"Popen._internal_poll (/home/ma-user/anaconda3/envs/py311/lib/python3.11/subprocess.py:1915)"},{"pid":131246,"tid":131246,"ts":1234103178203.199,"ph":"X","cat":"fee","dur":16.36,"name":"Popen.poll (/home/ma-user/anaconda3/envs/py311/lib/python3.11/subprocess.py:1229)"},{"pid":131246,"tid":131246,"ts":1234103178220.589,"ph":"X","cat":"fee","dur":1000059.04,"name":"time.sleep"},{"pid":131246,"tid":131246,"ts":1234104178287.389,"ph":"X","cat":"fee","dur":1.97,"name":"_thread.lock.acquire"},{"pid":131246,"tid":131246,"ts":1234104178290.109,"ph":"X","cat":"fee","dur":5.24,"name":"posix.waitpid"},{"pid":131246,"tid":131246,"ts":1234104178296.519,"ph":"X","cat":"fee","dur":0.13,"name":"_thread.lock.release"},{"pid":131246,"tid":131246,"ts":1234104178286.319,"ph":"X","cat":"fee","dur":10.53,"name":"Popen._internal_poll (/home/ma-user/anaconda3/envs/py311/lib/python3.11/subprocess.py:1915)"},{"pid":131246,"tid":131246,"ts":1234104178285.949,"ph":"X","cat":"fee","dur":11.53,"name":"Popen.poll (/home/ma-user/anaconda3/envs/py311/lib/python3.11/subprocess.py:1229)"},{"pid":131246,"tid":131246,"ts":1234104178297.939,"ph":"X","cat":"fee","dur":1000058.77,"name":"time.sleep"},{"pid":131246,"tid":131246,"ts":1234105178367.459,"ph":"X","cat":"fee","dur":3.53,"name":"_thread.lock.acquire"},{"pid":131246,"tid":131246,"ts":1234105178372.249,"ph":"X","cat":"fee","dur":214.062,"name":"posix.waitpid"},{"pid":131246,"tid":131246,"ts":1234105178591.941,"ph":"X","cat":"fee","dur":0.68,"name":"posix.WIFSTOPPED"},{"pid":131246,"tid":131246,"ts":1234105178592.921,"ph":"X","cat":"fee","dur":0.43,"name":"posix.waitstatus_to_exitcode"},{"pid":131246,"tid":131246,"ts":1234105178591.771,"ph":"X","cat":"fee","dur":10.36,"name":"Popen._handle_exitstatus (/home/ma-user/anaconda3/envs/py311/lib/python3.11/subprocess.py:1903)"},{"pid":131246,"tid":131246,"ts":1234105178603.521,"ph":"X","cat":"fee","dur":0.14,"name":"_thread.lock.release"},{"pid":131246,"tid":131246,"ts":1234105178365.879,"ph":"X","cat":"fee","dur":237.942,"name":"Popen._internal_poll (/home/ma-user/anaconda3/envs/py311/lib/python3.11/subprocess.py:1915)"},{"pid":131246,"tid":131246,"ts":1234105178365.319,"ph":"X","cat":"fee","dur":238.702,"name":"Popen.poll (/home/ma-user/anaconda3/envs/py311/lib/python3.11/subprocess.py:1229)"},{"pid":131246,"tid":131246,"ts":1234105178611.891,"ph":"X","cat":"fee","dur":34.111,"name":"builtins.print"},{"pid":131246,"tid":131246,"ts":1234105178647.472,"ph":"X","cat":"fee","dur":1000054.93,"name":"time.sleep"},{"pid":131246,"tid":131246,"ts":1234106178707.522,"ph":"X","cat":"fee","dur":0.49,"name":"Popen._internal_poll (/home/ma-user/anaconda3/envs/py311/lib/python3.11/subprocess.py:1915)"},{"pid":131246,"tid":131246,"ts":1234106178707.212,"ph":"X","cat":"fee","dur":1.99,"name":"Popen.poll (/home/ma-user/anaconda3/envs/py311/lib/python3.11/subprocess.py:1229)"},{"pid":131246,"tid":131246,"ts":1234106178711.092,"ph":"X","cat":"fee","dur":13.53,"name":"builtins.print"},{"pid":131246,"tid":131246,"ts":1234106178725.342,"ph":"X","cat":"fee","dur":1000054.84,"name":"time.sleep"},{"pid":131246,"tid":131246,"ts":1234107178785.462,"ph":"X","cat":"fee","dur":0.98,"name":"Popen._internal_poll (/home/ma-user/anaconda3/envs/py311/lib/python3.11/subprocess.py:1915)"},{"pid":131246,"tid":131246,"ts":1234107178784.902,"ph":"X","cat":"fee","dur":2.14,"name":"Popen.poll (/home/ma-user/anaconda3/envs/py311/lib/python3.11/subprocess.py:1229)"},{"pid":131246,"tid":131246,"ts":1234107178788.802,"ph":"X","cat":"fee","dur":12.97,"name":"builtins.print"},{"pid":131246,"tid":131246,"ts":1234107178802.472,"ph":"X","cat":"fee","dur":1000054.2,"name":"time.sleep"},{"pid":131246,"tid":131246,"ts":1234108178861.032,"ph":"X","cat":"fee","dur":0.43,"name":"Popen._internal_poll (/home/ma-user/anaconda3/envs/py311/lib/python3.11/subprocess.py:1915)"},{"pid":131246,"tid":131246,"ts":1234108178860.792,"ph":"X","cat":"fee","dur":1.51,"name":"Popen.poll (/home/ma-user/anaconda3/envs/py311/lib/python3.11/subprocess.py:1229)"},{"pid":131246,"tid":131246,"ts":1234108178863.852,"ph":"X","cat":"fee","dur":9.82,"name":"builtins.print"},{"pid":131246,"tid":131246,"ts":1234109011363.836,"ph":"X","cat":"fee","dur":17.23,"name":"builtins.print"},{"pid":131246,"tid":131246,"ts":1234109011384.566,"ph":"X","cat":"fee","dur":0.22,"name":"Popen._internal_poll (/home/ma-user/anaconda3/envs/py311/lib/python3.11/subprocess.py:1915)"},{"pid":131246,"tid":131246,"ts":1234109011384.036,"ph":"X","cat":"fee","dur":1.04,"name":"Popen.poll (/home/ma-user/anaconda3/envs/py311/lib/python3.11/subprocess.py:1229)"},{"pid":131246,"tid":131246,"ts":1234109011385.836,"ph":"X","cat":"fee","dur":15.251,"name":"_io.TextIOWrapper.close"},{"pid":131246,"tid":131246,"ts":1234109011402.107,"ph":"X","cat":"fee","dur":5.06,"name":"builtins.print"},{"pid":131246,"tid":131246,"ts":1234109011408.897,"ph":"X","cat":"fee","dur":1.23,"name":"sys.exit"},{"pid":131246,"tid":131246,"ts":1234109011363.026,"ph":"X","cat":"fee","dur":48.531,"name":"signal_handler (/home/lc/omni_infer/tools/scripts/start_api_servers.py:177)"},{"pid":131246,"tid":131246,"ts":1234108178874.052,"ph":"X","cat":"fee","dur":832537.844,"name":"time.sleep"},{"pid":131246,"tid":131246,"ts":1234080173907.867,"ph":"X","cat":"fee","dur":28837508.649,"name":"<module> (/home/lc/omni_infer/tools/scripts/start_api_servers.py:1)"},{"pid":131246,"tid":131246,"ts":1234080173894.537,"ph":"X","cat":"fee","dur":28837522.909,"name":"builtins.exec"},{"pid":131246,"tid":131246,"ts":1234109011450.087,"ph":"X","cat":"fee","dur":0.49,"name":"gc.isenabled"},{"pid":131246,"tid":131246,"ts":1234109011451.097,"ph":"X","cat":"fee","dur":0.35,"name":"gc.disable"},{"pid":131246,"tid":131246,"ts":1234109011456.697,"ph":"X","cat":"fee","dur":0.66,"name":"dict.items"},{"pid":131246,"tid":131246,"ts":1234109011459.217,"ph":"X","cat":"fee","dur":3.42,"name":"finalize._select_for_exit.<locals>.<listcomp> (/home/ma-user/anaconda3/envs/py311/lib/python3.11/weakref.py:637)"},{"pid":131246,"tid":131246,"ts":1234109011466.537,"ph":"X","cat":"fee","dur":0.9,"name":"finalize._select_for_exit.<locals>.<lambda> (/home/ma-user/anaconda3/envs/py311/lib/python3.11/weakref.py:638)"},{"pid":131246,"tid":131246,"ts":1234109011464.347,"ph":"X","cat":"fee","dur":4.41,"name":"list.sort"},{"pid":131246,"tid":131246,"ts":1234109011469.697,"ph":"X","cat":"fee","dur":0.57,"name":"finalize._select_for_exit.<locals>.<listcomp> (/home/ma-user/anaconda3/envs/py311/lib/python3.11/weakref.py:639)"},{"pid":131246,"tid":131246,"ts":1234109011454.427,"ph":"X","cat":"fee","dur":16.06,"name":"finalize._select_for_exit (/home/ma-user/anaconda3/envs/py311/lib/python3.11/weakref.py:634)"},{"pid":131246,"tid":131246,"ts":1234109011473.097,"ph":"X","cat":"fee","dur":1.06,"name":"list.pop"},{"pid":131246,"tid":131246,"ts":1234109011478.357,"ph":"X","cat":"fee","dur":2.24,"name":"dict.pop"},{"pid":131246,"tid":131246,"ts":1234109011489.237,"ph":"X","cat":"fee","dur":0.16,"name":"Popen._internal_poll (/home/ma-user/anaconda3/envs/py311/lib/python3.11/subprocess.py:1915)"},{"pid":131246,"tid":131246,"ts":1234109011488.887,"ph":"X","cat":"fee","dur":0.66,"name":"Popen.poll (/home/ma-user/anaconda3/envs/py311/lib/python3.11/subprocess.py:1229)"},{"pid":131246,"tid":131246,"ts":1234109011489.967,"ph":"X","cat":"fee","dur":0.22,"name":"_io.TextIOWrapper.close"},{"pid":131246,"tid":131246,"ts":1234109011491.287,"ph":"X","cat":"fee","dur":7.181,"name":"builtins.print"},{"pid":131246,"tid":131246,"ts":1234109011487.897,"ph":"X","cat":"fee","dur":10.951,"name":"start_single_node_api_servers.<locals>.cleanup_processes (/home/lc/omni_infer/tools/scripts/start_api_servers.py:154)"},{"pid":131246,"tid":131246,"ts":1234109011477.627,"ph":"X","cat":"fee","dur":21.531,"name":"finalize.__call__ (/home/ma-user/anaconda3/envs/py311/lib/python3.11/weakref.py:585)"},{"pid":131246,"tid":131246,"ts":1234109011504.168,"ph":"X","cat":"fee","dur":0.51,"name":"gc.enable"},{"pid":131246,"tid":131246,"ts":1234109011444.087,"ph":"X","cat":"fee","dur":60.681,"name":"finalize._exitfunc (/home/ma-user/anaconda3/envs/py311/lib/python3.11/weakref.py:641)"},{"pid":131246,"tid":131246,"ts":1234109011518.378,"ph":"X","cat":"fee","dur":1.55,"name":"_thread.RLock.acquire"},{"pid":131246,"tid":131246,"ts":1234109011516.168,"ph":"X","cat":"fee","dur":8.83,"name":"Handler.acquire (/home/ma-user/anaconda3/envs/py311/lib/python3.11/logging/__init__.py:922)"},{"pid":131246,"tid":131246,"ts":1234109011528.368,"ph":"X","cat":"fee","dur":0.2,"name":"_thread.RLock.acquire"},{"pid":131246,"tid":131246,"ts":1234109011528.098,"ph":"X","cat":"fee","dur":0.59,"name":"Handler.acquire (/home/ma-user/anaconda3/envs/py311/lib/python3.11/logging/__init__.py:922)"},{"pid":131246,"tid":131246,"ts":1234109011530.488,"ph":"X","cat":"fee","dur":0.76,"name":"_StderrHandler.stream (/home/ma-user/anaconda3/envs/py311/lib/python3.11/logging/__init__.py:1249)"},{"pid":131246,"tid":131246,"ts":1234109011531.778,"ph":"X","cat":"fee","dur":0.16,"name":"_StderrHandler.stream (/home/ma-user/anaconda3/envs/py311/lib/python3.11/logging/__init__.py:1249)"},{"pid":131246,"tid":131246,"ts":1234109011532.098,"ph":"X","cat":"fee","dur":1.2,"name":"builtins.hasattr"},{"pid":131246,"tid":131246,"ts":1234109011533.588,"ph":"X","cat":"fee","dur":0.12,"name":"_StderrHandler.stream (/home/ma-user/anaconda3/envs/py311/lib/python3.11/logging/__init__.py:1249)"},{"pid":131246,"tid":131246,"ts":1234109011533.918,"ph":"X","cat":"fee","dur":0.69,"name":"_io.TextIOWrapper.flush"},{"pid":131246,"tid":131246,"ts":1234109011536.448,"ph":"X","cat":"fee","dur":0.54,"name":"_thread.RLock.release"},{"pid":131246,"tid":131246,"ts":1234109011535.898,"ph":"X","cat":"fee","dur":1.27,"name":"Handler.release (/home/ma-user/anaconda3/envs/py311/lib/python3.11/logging/__init__.py:929)"},{"pid":131246,"tid":131246,"ts":1234109011527.678,"ph":"X","cat":"fee","dur":9.61,"name":"StreamHandler.flush (/home/ma-user/anaconda3/envs/py311/lib/python3.11/logging/__init__.py:1087)"},{"pid":131246,"tid":131246,"ts":1234109011541.498,"ph":"X","cat":"fee","dur":0.42,"name":"_thread.RLock.acquire"},{"pid":131246,"tid":131246,"ts":1234109011540.638,"ph":"X","cat":"fee","dur":1.6,"name":"_acquireLock (/home/ma-user/anaconda3/envs/py311/lib/python3.11/logging/__init__.py:228)"},{"pid":131246,"tid":131246,"ts":1234109011544.428,"ph":"X","cat":"fee","dur":0.09,"name":"_thread.RLock.release"},{"pid":131246,"tid":131246,"ts":1234109011544.098,"ph":"X","cat":"fee","dur":0.59,"name":"_releaseLock (/home/ma-user/anaconda3/envs/py311/lib/python3.11/logging/__init__.py:237)"},{"pid":131246,"tid":131246,"ts":1234109011539.588,"ph":"X","cat":"fee","dur":5.23,"name":"Handler.close (/home/ma-user/anaconda3/envs/py311/lib/python3.11/logging/__init__.py:998)"},{"pid":131246,"tid":131246,"ts":1234109011545.368,"ph":"X","cat":"fee","dur":0.06,"name":"_thread.RLock.release"},{"pid":131246,"tid":131246,"ts":1234109011545.188,"ph":"X","cat":"fee","dur":0.33,"name":"Handler.release (/home/ma-user/anaconda3/envs/py311/lib/python3.11/logging/__init__.py:929)"},{"pid":131246,"tid":131246,"ts":1234109011508.638,"ph":"X","cat":"fee","dur":37.47,"name":"shutdown (/home/ma-user/anaconda3/envs/py311/lib/python3.11/logging/__init__.py:2177)"},{"pid":131246,"tid":131246,"ts":1234109011552.098,"ph":"X","cat":"fee","dur":0.6,"name":"info (/home/ma-user/anaconda3/envs/py311/lib/python3.11/multiprocessing/util.py:52)"},{"pid":131246,"tid":131246,"ts":1234109011553.568,"ph":"X","cat":"fee","dur":0.18,"name":"debug (/home/ma-user/anaconda3/envs/py311/lib/python3.11/multiprocessing/util.py:48)"},{"pid":131246,"tid":131246,"ts":1234109011562.818,"ph":"X","cat":"fee","dur":0.46,"name":"_run_finalizers.<locals>.<lambda> (/home/ma-user/anaconda3/envs/py311/lib/python3.11/multiprocessing/util.py:284)"},{"pid":131246,"tid":131246,"ts":1234109011561.888,"ph":"X","cat":"fee","dur":1.63,"name":"_run_finalizers.<locals>.<listcomp> (/home/ma-user/anaconda3/envs/py311/lib/python3.11/multiprocessing/util.py:291)"},{"pid":131246,"tid":131246,"ts":1234109011564.058,"ph":"X","cat":"fee","dur":0.79,"name":"list.sort"},{"pid":131246,"tid":131246,"ts":1234109011557.348,"ph":"X","cat":"fee","dur":7.95,"name":"_run_finalizers (/home/ma-user/anaconda3/envs/py311/lib/python3.11/multiprocessing/util.py:268)"},{"pid":131246,"tid":131246,"ts":1234109011566.818,"ph":"X","cat":"fee","dur":0.6,"name":"current_process (/home/ma-user/anaconda3/envs/py311/lib/python3.11/multiprocessing/process.py:37)"},{"pid":131246,"tid":131246,"ts":1234109011570.088,"ph":"X","cat":"fee","dur":2.39,"name":"_cleanup (/home/ma-user/anaconda3/envs/py311/lib/python3.11/multiprocessing/process.py:61)"},{"pid":131246,"tid":131246,"ts":1234109011568.308,"ph":"X","cat":"fee","dur":4.63,"name":"active_children (/home/ma-user/anaconda3/envs/py311/lib/python3.11/multiprocessing/process.py:43)"},{"pid":131246,"tid":131246,"ts":1234109011573.498,"ph":"X","cat":"fee","dur":0.37,"name":"_cleanup (/home/ma-user/anaconda3/envs/py311/lib/python3.11/multiprocessing/process.py:61)"},{"pid":131246,"tid":131246,"ts":1234109011573.328,"ph":"X","cat":"fee","dur":0.84,"name":"active_children (/home/ma-user/anaconda3/envs/py311/lib/python3.11/multiprocessing/process.py:43)"},{"pid":131246,"tid":131246,"ts":1234109011574.628,"ph":"X","cat":"fee","dur":0.12,"name":"debug (/home/ma-user/anaconda3/envs/py311/lib/python3.11/multiprocessing/util.py:48)"},{"pid":131246,"tid":131246,"ts":1234109011577.008,"ph":"X","cat":"fee","dur":0.15,"name":"_run_finalizers.<locals>.<lambda> (/home/ma-user/anaconda3/envs/py311/lib/python3.11/multiprocessing/util.py:282)"},{"pid":131246,"tid":131246,"ts":1234109011576.368,"ph":"X","cat":"fee","dur":1.06,"name":"_run_finalizers.<locals>.<listcomp> (/home/ma-user/anaconda3/envs/py311/lib/python3.11/multiprocessing/util.py:291)"},{"pid":131246,"tid":131246,"ts":1234109011577.738,"ph":"X","cat":"fee","dur":0.42,"name":"list.sort"},{"pid":131246,"tid":131246,"ts":1234109011578.668,"ph":"X","cat":"fee","dur":0.93,"name":"dict.get"},{"pid":131246,"tid":131246,"ts":1234109011581.198,"ph":"X","cat":"fee","dur":0.19,"name":"sub_debug (/home/ma-user/anaconda3/envs/py311/lib/python3.11/multiprocessing/util.py:44)"},{"pid":131246,"tid":131246,"ts":1234109011587.718,"ph":"X","cat":"fee","dur":1.2,"name":"posix.getpid"},{"pid":131246,"tid":131246,"ts":1234109011590.368,"ph":"X","cat":"fee","dur":0.09,"name":"sub_debug (/home/ma-user/anaconda3/envs/py311/lib/python3.11/multiprocessing/util.py:44)"},{"pid":131246,"tid":131246,"ts":1234109011586.448,"ph":"X","cat":"fee","dur":45.611,"name":"Finalize.__call__ (/home/ma-user/anaconda3/envs/py311/lib/python3.11/multiprocessing/util.py:205)"},{"pid":131246,"tid":131246,"ts":1234109011575.078,"ph":"X","cat":"fee","dur":57.031,"name":"_run_finalizers (/home/ma-user/anaconda3/envs/py311/lib/python3.11/multiprocessing/util.py:268)"},{"pid":131246,"tid":131246,"ts":1234109011550.168,"ph":"X","cat":"fee","dur":81.981,"name":"_exit_function (/home/ma-user/anaconda3/envs/py311/lib/python3.11/multiprocessing/util.py:320)"},{"pid":131246,"tid":131246,"ts":1234109011437.547,"ph":"X","cat":"fee","dur":194.642,"name":"atexit._run_exitfuncs"},{"ph":"M","pid":131247,"tid":131247,"name":"process_name","args":{"name":"vllm"}},{"ph":"M","pid":131247,"tid":131247,"name":"thread_name","args":{"name":"MainThread"}},{"pid":131247,"tid":131247,"ts":1234080263129.811,"ph":"X","cat":"fee","dur":23562395.755,"name":"<module> (/home/ma-user/anaconda3/envs/py311/bin/vllm:1)"},{"pid":131247,"tid":131247,"ts":1234080263126.841,"ph":"X","cat":"fee","dur":23562399.105,"name":"builtins.exec"},{"ph":"M","pid":131586,"tid":131586,"name":"process_name","args":{"name":"vllm.model_executor.models.registry"}},{"ph":"M","pid":131586,"tid":131586,"name":"thread_name","args":{"name":"MainThread"}},{"pid":131586,"tid":131586,"ts":1234093801502.308,"ph":"X","cat":"fee","dur":8771022.039,"name":"<module> (<string>:1)"},{"pid":131586,"tid":131586,"ts":1234093801446.107,"ph":"X","cat":"fee","dur":8771078.63,"name":"builtins.exec"}],"viztracer_metadata":{"overflow":false,"version":"1.0.4"},"file_info":{"files":{"/home/ma-user/anaconda3/envs/py311/lib/python3.11/shutil.py":["\"\"\"Utility functions for copying and archiving files and directory trees.\n\nXXX The functions here don't copy the resource fork or other metadata on Mac.\n\n\"\"\"\n\nimport os\nimport sys\nimport stat\nimport fnmatch\nimport collections\nimport errno\n\ntry:\n    import zlib\n    del zlib\n    _ZLIB_SUPPORTED = True\nexcept ImportError:\n    _ZLIB_SUPPORTED = False\n\ntry:\n    import bz2\n    del bz2\n    _BZ2_SUPPORTED = True\nexcept ImportError:\n    _BZ2_SUPPORTED = False\n\ntry:\n    import lzma\n    del lzma\n    _LZMA_SUPPORTED = True\nexcept ImportError:\n    _LZMA_SUPPORTED = False\n\n_WINDOWS = os.name == 'nt'\nposix = nt = None\nif os.name == 'posix':\n    import posix\nelif _WINDOWS:\n    import nt\n\nCOPY_BUFSIZE = 1024 * 1024 if _WINDOWS else 64 * 1024\n# This should never be removed, see rationale in:\n# https://bugs.python.org/issue43743#msg393429\n_USE_CP_SENDFILE = hasattr(os, \"sendfile\") and sys.platform.startswith(\"linux\")\n_HAS_FCOPYFILE = posix and hasattr(posix, \"_fcopyfile\")  # macOS\n\n# CMD defaults in Windows 10\n_WIN_DEFAULT_PATHEXT = \".COM;.EXE;.BAT;.CMD;.VBS;.JS;.WS;.MSC\"\n\n__all__ = [\"copyfileobj\", \"copyfile\", \"copymode\", \"copystat\", \"copy\", \"copy2\",\n           \"copytree\", \"move\", \"rmtree\", \"Error\", \"SpecialFileError\",\n           \"ExecError\", \"make_archive\", \"get_archive_formats\",\n           \"register_archive_format\", \"unregister_archive_format\",\n           \"get_unpack_formats\", \"register_unpack_format\",\n           \"unregister_unpack_format\", \"unpack_archive\",\n           \"ignore_patterns\", \"chown\", \"which\", \"get_terminal_size\",\n           \"SameFileError\"]\n           # disk_usage is added later, if available on the platform\n\nclass Error(OSError):\n    pass\n\nclass SameFileError(Error):\n    \"\"\"Raised when source and destination are the same file.\"\"\"\n\nclass SpecialFileError(OSError):\n    \"\"\"Raised when trying to do a kind of operation (e.g. copying) which is\n    not supported on a special file (e.g. a named pipe)\"\"\"\n\nclass ExecError(OSError):\n    \"\"\"Raised when a command could not be executed\"\"\"\n\nclass ReadError(OSError):\n    \"\"\"Raised when an archive cannot be read\"\"\"\n\nclass RegistryError(Exception):\n    \"\"\"Raised when a registry operation with the archiving\n    and unpacking registries fails\"\"\"\n\nclass _GiveupOnFastCopy(Exception):\n    \"\"\"Raised as a signal to fallback on using raw read()/write()\n    file copy when fast-copy functions fail to do so.\n    \"\"\"\n\ndef _fastcopy_fcopyfile(fsrc, fdst, flags):\n    \"\"\"Copy a regular file content or metadata by using high-performance\n    fcopyfile(3) syscall (macOS).\n    \"\"\"\n    try:\n        infd = fsrc.fileno()\n        outfd = fdst.fileno()\n    except Exception as err:\n        raise _GiveupOnFastCopy(err)  # not a regular file\n\n    try:\n        posix._fcopyfile(infd, outfd, flags)\n    except OSError as err:\n        err.filename = fsrc.name\n        err.filename2 = fdst.name\n        if err.errno in {errno.EINVAL, errno.ENOTSUP}:\n            raise _GiveupOnFastCopy(err)\n        else:\n            raise err from None\n\ndef _fastcopy_sendfile(fsrc, fdst):\n    \"\"\"Copy data from one regular mmap-like fd to another by using\n    high-performance sendfile(2) syscall.\n    This should work on Linux >= 2.6.33 only.\n    \"\"\"\n    # Note: copyfileobj() is left alone in order to not introduce any\n    # unexpected breakage. Possible risks by using zero-copy calls\n    # in copyfileobj() are:\n    # - fdst cannot be open in \"a\"(ppend) mode\n    # - fsrc and fdst may be open in \"t\"(ext) mode\n    # - fsrc may be a BufferedReader (which hides unread data in a buffer),\n    #   GzipFile (which decompresses data), HTTPResponse (which decodes\n    #   chunks).\n    # - possibly others (e.g. encrypted fs/partition?)\n    global _USE_CP_SENDFILE\n    try:\n        infd = fsrc.fileno()\n        outfd = fdst.fileno()\n    except Exception as err:\n        raise _GiveupOnFastCopy(err)  # not a regular file\n\n    # Hopefully the whole file will be copied in a single call.\n    # sendfile() is called in a loop 'till EOF is reached (0 return)\n    # so a bufsize smaller or bigger than the actual file size\n    # should not make any difference, also in case the file content\n    # changes while being copied.\n    try:\n        blocksize = max(os.fstat(infd).st_size, 2 ** 23)  # min 8MiB\n    except OSError:\n        blocksize = 2 ** 27  # 128MiB\n    # On 32-bit architectures truncate to 1GiB to avoid OverflowError,\n    # see bpo-38319.\n    if sys.maxsize < 2 ** 32:\n        blocksize = min(blocksize, 2 ** 30)\n\n    offset = 0\n    while True:\n        try:\n            sent = os.sendfile(outfd, infd, offset, blocksize)\n        except OSError as err:\n            # ...in oder to have a more informative exception.\n            err.filename = fsrc.name\n            err.filename2 = fdst.name\n\n            if err.errno == errno.ENOTSOCK:\n                # sendfile() on this platform (probably Linux < 2.6.33)\n                # does not support copies between regular files (only\n                # sockets).\n                _USE_CP_SENDFILE = False\n                raise _GiveupOnFastCopy(err)\n\n            if err.errno == errno.ENOSPC:  # filesystem is full\n                raise err from None\n\n            # Give up on first call and if no data was copied.\n            if offset == 0 and os.lseek(outfd, 0, os.SEEK_CUR) == 0:\n                raise _GiveupOnFastCopy(err)\n\n            raise err\n        else:\n            if sent == 0:\n                break  # EOF\n            offset += sent\n\ndef _copyfileobj_readinto(fsrc, fdst, length=COPY_BUFSIZE):\n    \"\"\"readinto()/memoryview() based variant of copyfileobj().\n    *fsrc* must support readinto() method and both files must be\n    open in binary mode.\n    \"\"\"\n    # Localize variable access to minimize overhead.\n    fsrc_readinto = fsrc.readinto\n    fdst_write = fdst.write\n    with memoryview(bytearray(length)) as mv:\n        while True:\n            n = fsrc_readinto(mv)\n            if not n:\n                break\n            elif n < length:\n                with mv[:n] as smv:\n                    fdst.write(smv)\n            else:\n                fdst_write(mv)\n\ndef copyfileobj(fsrc, fdst, length=0):\n    \"\"\"copy data from file-like object fsrc to file-like object fdst\"\"\"\n    if not length:\n        length = COPY_BUFSIZE\n    # Localize variable access to minimize overhead.\n    fsrc_read = fsrc.read\n    fdst_write = fdst.write\n    while True:\n        buf = fsrc_read(length)\n        if not buf:\n            break\n        fdst_write(buf)\n\ndef _samefile(src, dst):\n    # Macintosh, Unix.\n    if isinstance(src, os.DirEntry) and hasattr(os.path, 'samestat'):\n        try:\n            return os.path.samestat(src.stat(), os.stat(dst))\n        except OSError:\n            return False\n\n    if hasattr(os.path, 'samefile'):\n        try:\n            return os.path.samefile(src, dst)\n        except OSError:\n            return False\n\n    # All other platforms: check for same pathname.\n    return (os.path.normcase(os.path.abspath(src)) ==\n            os.path.normcase(os.path.abspath(dst)))\n\ndef _stat(fn):\n    return fn.stat() if isinstance(fn, os.DirEntry) else os.stat(fn)\n\ndef _islink(fn):\n    return fn.is_symlink() if isinstance(fn, os.DirEntry) else os.path.islink(fn)\n\ndef copyfile(src, dst, *, follow_symlinks=True):\n    \"\"\"Copy data from src to dst in the most efficient way possible.\n\n    If follow_symlinks is not set and src is a symbolic link, a new\n    symlink will be created instead of copying the file it points to.\n\n    \"\"\"\n    sys.audit(\"shutil.copyfile\", src, dst)\n\n    if _samefile(src, dst):\n        raise SameFileError(\"{!r} and {!r} are the same file\".format(src, dst))\n\n    file_size = 0\n    for i, fn in enumerate([src, dst]):\n        try:\n            st = _stat(fn)\n        except OSError:\n            # File most likely does not exist\n            pass\n        else:\n            # XXX What about other special files? (sockets, devices...)\n            if stat.S_ISFIFO(st.st_mode):\n                fn = fn.path if isinstance(fn, os.DirEntry) else fn\n                raise SpecialFileError(\"`%s` is a named pipe\" % fn)\n            if _WINDOWS and i == 0:\n                file_size = st.st_size\n\n    if not follow_symlinks and _islink(src):\n        os.symlink(os.readlink(src), dst)\n    else:\n        with open(src, 'rb') as fsrc:\n            try:\n                with open(dst, 'wb') as fdst:\n                    # macOS\n                    if _HAS_FCOPYFILE:\n                        try:\n                            _fastcopy_fcopyfile(fsrc, fdst, posix._COPYFILE_DATA)\n                            return dst\n                        except _GiveupOnFastCopy:\n                            pass\n                    # Linux\n                    elif _USE_CP_SENDFILE:\n                        try:\n                            _fastcopy_sendfile(fsrc, fdst)\n                            return dst\n                        except _GiveupOnFastCopy:\n                            pass\n                    # Windows, see:\n                    # https://github.com/python/cpython/pull/7160#discussion_r195405230\n                    elif _WINDOWS and file_size > 0:\n                        _copyfileobj_readinto(fsrc, fdst, min(file_size, COPY_BUFSIZE))\n                        return dst\n\n                    copyfileobj(fsrc, fdst)\n\n            # Issue 43219, raise a less confusing exception\n            except IsADirectoryError as e:\n                if not os.path.exists(dst):\n                    raise FileNotFoundError(f'Directory does not exist: {dst}') from e\n                else:\n                    raise\n\n    return dst\n\ndef copymode(src, dst, *, follow_symlinks=True):\n    \"\"\"Copy mode bits from src to dst.\n\n    If follow_symlinks is not set, symlinks aren't followed if and only\n    if both `src` and `dst` are symlinks.  If `lchmod` isn't available\n    (e.g. Linux) this method does nothing.\n\n    \"\"\"\n    sys.audit(\"shutil.copymode\", src, dst)\n\n    if not follow_symlinks and _islink(src) and os.path.islink(dst):\n        if hasattr(os, 'lchmod'):\n            stat_func, chmod_func = os.lstat, os.lchmod\n        else:\n            return\n    else:\n        stat_func, chmod_func = _stat, os.chmod\n\n    st = stat_func(src)\n    chmod_func(dst, stat.S_IMODE(st.st_mode))\n\nif hasattr(os, 'listxattr'):\n    def _copyxattr(src, dst, *, follow_symlinks=True):\n        \"\"\"Copy extended filesystem attributes from `src` to `dst`.\n\n        Overwrite existing attributes.\n\n        If `follow_symlinks` is false, symlinks won't be followed.\n\n        \"\"\"\n\n        try:\n            names = os.listxattr(src, follow_symlinks=follow_symlinks)\n        except OSError as e:\n            if e.errno not in (errno.ENOTSUP, errno.ENODATA, errno.EINVAL):\n                raise\n            return\n        for name in names:\n            try:\n                value = os.getxattr(src, name, follow_symlinks=follow_symlinks)\n                os.setxattr(dst, name, value, follow_symlinks=follow_symlinks)\n            except OSError as e:\n                if e.errno not in (errno.EPERM, errno.ENOTSUP, errno.ENODATA,\n                                   errno.EINVAL):\n                    raise\nelse:\n    def _copyxattr(*args, **kwargs):\n        pass\n\ndef copystat(src, dst, *, follow_symlinks=True):\n    \"\"\"Copy file metadata\n\n    Copy the permission bits, last access time, last modification time, and\n    flags from `src` to `dst`. On Linux, copystat() also copies the \"extended\n    attributes\" where possible. The file contents, owner, and group are\n    unaffected. `src` and `dst` are path-like objects or path names given as\n    strings.\n\n    If the optional flag `follow_symlinks` is not set, symlinks aren't\n    followed if and only if both `src` and `dst` are symlinks.\n    \"\"\"\n    sys.audit(\"shutil.copystat\", src, dst)\n\n    def _nop(*args, ns=None, follow_symlinks=None):\n        pass\n\n    # follow symlinks (aka don't not follow symlinks)\n    follow = follow_symlinks or not (_islink(src) and os.path.islink(dst))\n    if follow:\n        # use the real function if it exists\n        def lookup(name):\n            return getattr(os, name, _nop)\n    else:\n        # use the real function only if it exists\n        # *and* it supports follow_symlinks\n        def lookup(name):\n            fn = getattr(os, name, _nop)\n            if fn in os.supports_follow_symlinks:\n                return fn\n            return _nop\n\n    if isinstance(src, os.DirEntry):\n        st = src.stat(follow_symlinks=follow)\n    else:\n        st = lookup(\"stat\")(src, follow_symlinks=follow)\n    mode = stat.S_IMODE(st.st_mode)\n    lookup(\"utime\")(dst, ns=(st.st_atime_ns, st.st_mtime_ns),\n        follow_symlinks=follow)\n    # We must copy extended attributes before the file is (potentially)\n    # chmod()'ed read-only, otherwise setxattr() will error with -EACCES.\n    _copyxattr(src, dst, follow_symlinks=follow)\n    try:\n        lookup(\"chmod\")(dst, mode, follow_symlinks=follow)\n    except NotImplementedError:\n        # if we got a NotImplementedError, it's because\n        #   * follow_symlinks=False,\n        #   * lchown() is unavailable, and\n        #   * either\n        #       * fchownat() is unavailable or\n        #       * fchownat() doesn't implement AT_SYMLINK_NOFOLLOW.\n        #         (it returned ENOSUP.)\n        # therefore we're out of options--we simply cannot chown the\n        # symlink.  give up, suppress the error.\n        # (which is what shutil always did in this circumstance.)\n        pass\n    if hasattr(st, 'st_flags'):\n        try:\n            lookup(\"chflags\")(dst, st.st_flags, follow_symlinks=follow)\n        except OSError as why:\n            for err in 'EOPNOTSUPP', 'ENOTSUP':\n                if hasattr(errno, err) and why.errno == getattr(errno, err):\n                    break\n            else:\n                raise\n\ndef copy(src, dst, *, follow_symlinks=True):\n    \"\"\"Copy data and mode bits (\"cp src dst\"). Return the file's destination.\n\n    The destination may be a directory.\n\n    If follow_symlinks is false, symlinks won't be followed. This\n    resembles GNU's \"cp -P src dst\".\n\n    If source and destination are the same file, a SameFileError will be\n    raised.\n\n    \"\"\"\n    if os.path.isdir(dst):\n        dst = os.path.join(dst, os.path.basename(src))\n    copyfile(src, dst, follow_symlinks=follow_symlinks)\n    copymode(src, dst, follow_symlinks=follow_symlinks)\n    return dst\n\ndef copy2(src, dst, *, follow_symlinks=True):\n    \"\"\"Copy data and metadata. Return the file's destination.\n\n    Metadata is copied with copystat(). Please see the copystat function\n    for more information.\n\n    The destination may be a directory.\n\n    If follow_symlinks is false, symlinks won't be followed. This\n    resembles GNU's \"cp -P src dst\".\n    \"\"\"\n    if os.path.isdir(dst):\n        dst = os.path.join(dst, os.path.basename(src))\n    copyfile(src, dst, follow_symlinks=follow_symlinks)\n    copystat(src, dst, follow_symlinks=follow_symlinks)\n    return dst\n\ndef ignore_patterns(*patterns):\n    \"\"\"Function that can be used as copytree() ignore parameter.\n\n    Patterns is a sequence of glob-style patterns\n    that are used to exclude files\"\"\"\n    def _ignore_patterns(path, names):\n        ignored_names = []\n        for pattern in patterns:\n            ignored_names.extend(fnmatch.filter(names, pattern))\n        return set(ignored_names)\n    return _ignore_patterns\n\ndef _copytree(entries, src, dst, symlinks, ignore, copy_function,\n              ignore_dangling_symlinks, dirs_exist_ok=False):\n    if ignore is not None:\n        ignored_names = ignore(os.fspath(src), [x.name for x in entries])\n    else:\n        ignored_names = set()\n\n    os.makedirs(dst, exist_ok=dirs_exist_ok)\n    errors = []\n    use_srcentry = copy_function is copy2 or copy_function is copy\n\n    for srcentry in entries:\n        if srcentry.name in ignored_names:\n            continue\n        srcname = os.path.join(src, srcentry.name)\n        dstname = os.path.join(dst, srcentry.name)\n        srcobj = srcentry if use_srcentry else srcname\n        try:\n            is_symlink = srcentry.is_symlink()\n            if is_symlink and os.name == 'nt':\n                # Special check for directory junctions, which appear as\n                # symlinks but we want to recurse.\n                lstat = srcentry.stat(follow_symlinks=False)\n                if lstat.st_reparse_tag == stat.IO_REPARSE_TAG_MOUNT_POINT:\n                    is_symlink = False\n            if is_symlink:\n                linkto = os.readlink(srcname)\n                if symlinks:\n                    # We can't just leave it to `copy_function` because legacy\n                    # code with a custom `copy_function` may rely on copytree\n                    # doing the right thing.\n                    os.symlink(linkto, dstname)\n                    copystat(srcobj, dstname, follow_symlinks=not symlinks)\n                else:\n                    # ignore dangling symlink if the flag is on\n                    if not os.path.exists(linkto) and ignore_dangling_symlinks:\n                        continue\n                    # otherwise let the copy occur. copy2 will raise an error\n                    if srcentry.is_dir():\n                        copytree(srcobj, dstname, symlinks, ignore,\n                                 copy_function, dirs_exist_ok=dirs_exist_ok)\n                    else:\n                        copy_function(srcobj, dstname)\n            elif srcentry.is_dir():\n                copytree(srcobj, dstname, symlinks, ignore, copy_function,\n                         dirs_exist_ok=dirs_exist_ok)\n            else:\n                # Will raise a SpecialFileError for unsupported file types\n                copy_function(srcobj, dstname)\n        # catch the Error from the recursive copytree so that we can\n        # continue with other files\n        except Error as err:\n            errors.extend(err.args[0])\n        except OSError as why:\n            errors.append((srcname, dstname, str(why)))\n    try:\n        copystat(src, dst)\n    except OSError as why:\n        # Copying file access times may fail on Windows\n        if getattr(why, 'winerror', None) is None:\n            errors.append((src, dst, str(why)))\n    if errors:\n        raise Error(errors)\n    return dst\n\ndef copytree(src, dst, symlinks=False, ignore=None, copy_function=copy2,\n             ignore_dangling_symlinks=False, dirs_exist_ok=False):\n    \"\"\"Recursively copy a directory tree and return the destination directory.\n\n    If exception(s) occur, an Error is raised with a list of reasons.\n\n    If the optional symlinks flag is true, symbolic links in the\n    source tree result in symbolic links in the destination tree; if\n    it is false, the contents of the files pointed to by symbolic\n    links are copied. If the file pointed by the symlink doesn't\n    exist, an exception will be added in the list of errors raised in\n    an Error exception at the end of the copy process.\n\n    You can set the optional ignore_dangling_symlinks flag to true if you\n    want to silence this exception. Notice that this has no effect on\n    platforms that don't support os.symlink.\n\n    The optional ignore argument is a callable. If given, it\n    is called with the `src` parameter, which is the directory\n    being visited by copytree(), and `names` which is the list of\n    `src` contents, as returned by os.listdir():\n\n        callable(src, names) -> ignored_names\n\n    Since copytree() is called recursively, the callable will be\n    called once for each directory that is copied. It returns a\n    list of names relative to the `src` directory that should\n    not be copied.\n\n    The optional copy_function argument is a callable that will be used\n    to copy each file. It will be called with the source path and the\n    destination path as arguments. By default, copy2() is used, but any\n    function that supports the same signature (like copy()) can be used.\n\n    If dirs_exist_ok is false (the default) and `dst` already exists, a\n    `FileExistsError` is raised. If `dirs_exist_ok` is true, the copying\n    operation will continue if it encounters existing directories, and files\n    within the `dst` tree will be overwritten by corresponding files from the\n    `src` tree.\n    \"\"\"\n    sys.audit(\"shutil.copytree\", src, dst)\n    with os.scandir(src) as itr:\n        entries = list(itr)\n    return _copytree(entries=entries, src=src, dst=dst, symlinks=symlinks,\n                     ignore=ignore, copy_function=copy_function,\n                     ignore_dangling_symlinks=ignore_dangling_symlinks,\n                     dirs_exist_ok=dirs_exist_ok)\n\nif hasattr(os.stat_result, 'st_file_attributes'):\n    # Special handling for directory junctions to make them behave like\n    # symlinks for shutil.rmtree, since in general they do not appear as\n    # regular links.\n    def _rmtree_isdir(entry):\n        try:\n            st = entry.stat(follow_symlinks=False)\n            return (stat.S_ISDIR(st.st_mode) and not\n                (st.st_file_attributes & stat.FILE_ATTRIBUTE_REPARSE_POINT\n                 and st.st_reparse_tag == stat.IO_REPARSE_TAG_MOUNT_POINT))\n        except OSError:\n            return False\n\n    def _rmtree_islink(path):\n        try:\n            st = os.lstat(path)\n            return (stat.S_ISLNK(st.st_mode) or\n                (st.st_file_attributes & stat.FILE_ATTRIBUTE_REPARSE_POINT\n                 and st.st_reparse_tag == stat.IO_REPARSE_TAG_MOUNT_POINT))\n        except OSError:\n            return False\nelse:\n    def _rmtree_isdir(entry):\n        try:\n            return entry.is_dir(follow_symlinks=False)\n        except OSError:\n            return False\n\n    def _rmtree_islink(path):\n        return os.path.islink(path)\n\n# version vulnerable to race conditions\ndef _rmtree_unsafe(path, onerror):\n    try:\n        with os.scandir(path) as scandir_it:\n            entries = list(scandir_it)\n    except OSError:\n        onerror(os.scandir, path, sys.exc_info())\n        entries = []\n    for entry in entries:\n        fullname = entry.path\n        if _rmtree_isdir(entry):\n            try:\n                if entry.is_symlink():\n                    # This can only happen if someone replaces\n                    # a directory with a symlink after the call to\n                    # os.scandir or entry.is_dir above.\n                    raise OSError(\"Cannot call rmtree on a symbolic link\")\n            except OSError:\n                onerror(os.path.islink, fullname, sys.exc_info())\n                continue\n            _rmtree_unsafe(fullname, onerror)\n        else:\n            try:\n                os.unlink(fullname)\n            except OSError:\n                onerror(os.unlink, fullname, sys.exc_info())\n    try:\n        os.rmdir(path)\n    except OSError:\n        onerror(os.rmdir, path, sys.exc_info())\n\n# Version using fd-based APIs to protect against races\ndef _rmtree_safe_fd(topfd, path, onerror):\n    try:\n        with os.scandir(topfd) as scandir_it:\n            entries = list(scandir_it)\n    except OSError as err:\n        err.filename = path\n        onerror(os.scandir, path, sys.exc_info())\n        return\n    for entry in entries:\n        fullname = os.path.join(path, entry.name)\n        try:\n            is_dir = entry.is_dir(follow_symlinks=False)\n        except OSError:\n            is_dir = False\n        else:\n            if is_dir:\n                try:\n                    orig_st = entry.stat(follow_symlinks=False)\n                    is_dir = stat.S_ISDIR(orig_st.st_mode)\n                except OSError:\n                    onerror(os.lstat, fullname, sys.exc_info())\n                    continue\n        if is_dir:\n            try:\n                dirfd = os.open(entry.name, os.O_RDONLY, dir_fd=topfd)\n                dirfd_closed = False\n            except OSError:\n                onerror(os.open, fullname, sys.exc_info())\n            else:\n                try:\n                    if os.path.samestat(orig_st, os.fstat(dirfd)):\n                        _rmtree_safe_fd(dirfd, fullname, onerror)\n                        try:\n                            os.close(dirfd)\n                            dirfd_closed = True\n                            os.rmdir(entry.name, dir_fd=topfd)\n                        except OSError:\n                            onerror(os.rmdir, fullname, sys.exc_info())\n                    else:\n                        try:\n                            # This can only happen if someone replaces\n                            # a directory with a symlink after the call to\n                            # os.scandir or stat.S_ISDIR above.\n                            raise OSError(\"Cannot call rmtree on a symbolic \"\n                                          \"link\")\n                        except OSError:\n                            onerror(os.path.islink, fullname, sys.exc_info())\n                finally:\n                    if not dirfd_closed:\n                        os.close(dirfd)\n        else:\n            try:\n                os.unlink(entry.name, dir_fd=topfd)\n            except OSError:\n                onerror(os.unlink, fullname, sys.exc_info())\n\n_use_fd_functions = ({os.open, os.stat, os.unlink, os.rmdir} <=\n                     os.supports_dir_fd and\n                     os.scandir in os.supports_fd and\n                     os.stat in os.supports_follow_symlinks)\n\ndef rmtree(path, ignore_errors=False, onerror=None, *, dir_fd=None):\n    \"\"\"Recursively delete a directory tree.\n\n    If dir_fd is not None, it should be a file descriptor open to a directory;\n    path will then be relative to that directory.\n    dir_fd may not be implemented on your platform.\n    If it is unavailable, using it will raise a NotImplementedError.\n\n    If ignore_errors is set, errors are ignored; otherwise, if onerror\n    is set, it is called to handle the error with arguments (func,\n    path, exc_info) where func is platform and implementation dependent;\n    path is the argument to that function that caused it to fail; and\n    exc_info is a tuple returned by sys.exc_info().  If ignore_errors\n    is false and onerror is None, an exception is raised.\n\n    \"\"\"\n    sys.audit(\"shutil.rmtree\", path, dir_fd)\n    if ignore_errors:\n        def onerror(*args):\n            pass\n    elif onerror is None:\n        def onerror(*args):\n            raise\n    if _use_fd_functions:\n        # While the unsafe rmtree works fine on bytes, the fd based does not.\n        if isinstance(path, bytes):\n            path = os.fsdecode(path)\n        # Note: To guard against symlink races, we use the standard\n        # lstat()/open()/fstat() trick.\n        try:\n            orig_st = os.lstat(path, dir_fd=dir_fd)\n        except Exception:\n            onerror(os.lstat, path, sys.exc_info())\n            return\n        try:\n            fd = os.open(path, os.O_RDONLY, dir_fd=dir_fd)\n            fd_closed = False\n        except Exception:\n            onerror(os.open, path, sys.exc_info())\n            return\n        try:\n            if os.path.samestat(orig_st, os.fstat(fd)):\n                _rmtree_safe_fd(fd, path, onerror)\n                try:\n                    os.close(fd)\n                    fd_closed = True\n                    os.rmdir(path, dir_fd=dir_fd)\n                except OSError:\n                    onerror(os.rmdir, path, sys.exc_info())\n            else:\n                try:\n                    # symlinks to directories are forbidden, see bug #1669\n                    raise OSError(\"Cannot call rmtree on a symbolic link\")\n                except OSError:\n                    onerror(os.path.islink, path, sys.exc_info())\n        finally:\n            if not fd_closed:\n                os.close(fd)\n    else:\n        if dir_fd is not None:\n            raise NotImplementedError(\"dir_fd unavailable on this platform\")\n        try:\n            if _rmtree_islink(path):\n                # symlinks to directories are forbidden, see bug #1669\n                raise OSError(\"Cannot call rmtree on a symbolic link\")\n        except OSError:\n            onerror(os.path.islink, path, sys.exc_info())\n            # can't continue even if onerror hook returns\n            return\n        return _rmtree_unsafe(path, onerror)\n\n# Allow introspection of whether or not the hardening against symlink\n# attacks is supported on the current platform\nrmtree.avoids_symlink_attacks = _use_fd_functions\n\ndef _basename(path):\n    \"\"\"A basename() variant which first strips the trailing slash, if present.\n    Thus we always get the last component of the path, even for directories.\n\n    path: Union[PathLike, str]\n\n    e.g.\n    >>> os.path.basename('/bar/foo')\n    'foo'\n    >>> os.path.basename('/bar/foo/')\n    ''\n    >>> _basename('/bar/foo/')\n    'foo'\n    \"\"\"\n    path = os.fspath(path)\n    sep = os.path.sep + (os.path.altsep or '')\n    return os.path.basename(path.rstrip(sep))\n\ndef move(src, dst, copy_function=copy2):\n    \"\"\"Recursively move a file or directory to another location. This is\n    similar to the Unix \"mv\" command. Return the file or directory's\n    destination.\n\n    If the destination is a directory or a symlink to a directory, the source\n    is moved inside the directory. The destination path must not already\n    exist.\n\n    If the destination already exists but is not a directory, it may be\n    overwritten depending on os.rename() semantics.\n\n    If the destination is on our current filesystem, then rename() is used.\n    Otherwise, src is copied to the destination and then removed. Symlinks are\n    recreated under the new name if os.rename() fails because of cross\n    filesystem renames.\n\n    The optional `copy_function` argument is a callable that will be used\n    to copy the source or it will be delegated to `copytree`.\n    By default, copy2() is used, but any function that supports the same\n    signature (like copy()) can be used.\n\n    A lot more could be done here...  A look at a mv.c shows a lot of\n    the issues this implementation glosses over.\n\n    \"\"\"\n    sys.audit(\"shutil.move\", src, dst)\n    real_dst = dst\n    if os.path.isdir(dst):\n        if _samefile(src, dst):\n            # We might be on a case insensitive filesystem,\n            # perform the rename anyway.\n            os.rename(src, dst)\n            return\n\n        # Using _basename instead of os.path.basename is important, as we must\n        # ignore any trailing slash to avoid the basename returning ''\n        real_dst = os.path.join(dst, _basename(src))\n\n        if os.path.exists(real_dst):\n            raise Error(\"Destination path '%s' already exists\" % real_dst)\n    try:\n        os.rename(src, real_dst)\n    except OSError:\n        if os.path.islink(src):\n            linkto = os.readlink(src)\n            os.symlink(linkto, real_dst)\n            os.unlink(src)\n        elif os.path.isdir(src):\n            if _destinsrc(src, dst):\n                raise Error(\"Cannot move a directory '%s' into itself\"\n                            \" '%s'.\" % (src, dst))\n            if (_is_immutable(src)\n                    or (not os.access(src, os.W_OK) and os.listdir(src)\n                        and sys.platform == 'darwin')):\n                raise PermissionError(\"Cannot move the non-empty directory \"\n                                      \"'%s': Lacking write permission to '%s'.\"\n                                      % (src, src))\n            copytree(src, real_dst, copy_function=copy_function,\n                     symlinks=True)\n            rmtree(src)\n        else:\n            copy_function(src, real_dst)\n            os.unlink(src)\n    return real_dst\n\ndef _destinsrc(src, dst):\n    src = os.path.abspath(src)\n    dst = os.path.abspath(dst)\n    if not src.endswith(os.path.sep):\n        src += os.path.sep\n    if not dst.endswith(os.path.sep):\n        dst += os.path.sep\n    return dst.startswith(src)\n\ndef _is_immutable(src):\n    st = _stat(src)\n    immutable_states = [stat.UF_IMMUTABLE, stat.SF_IMMUTABLE]\n    return hasattr(st, 'st_flags') and st.st_flags in immutable_states\n\ndef _get_gid(name):\n    \"\"\"Returns a gid, given a group name.\"\"\"\n    if name is None:\n        return None\n\n    try:\n        from grp import getgrnam\n    except ImportError:\n        return None\n\n    try:\n        result = getgrnam(name)\n    except KeyError:\n        result = None\n    if result is not None:\n        return result[2]\n    return None\n\ndef _get_uid(name):\n    \"\"\"Returns an uid, given a user name.\"\"\"\n    if name is None:\n        return None\n\n    try:\n        from pwd import getpwnam\n    except ImportError:\n        return None\n\n    try:\n        result = getpwnam(name)\n    except KeyError:\n        result = None\n    if result is not None:\n        return result[2]\n    return None\n\ndef _make_tarball(base_name, base_dir, compress=\"gzip\", verbose=0, dry_run=0,\n                  owner=None, group=None, logger=None, root_dir=None):\n    \"\"\"Create a (possibly compressed) tar file from all the files under\n    'base_dir'.\n\n    'compress' must be \"gzip\" (the default), \"bzip2\", \"xz\", or None.\n\n    'owner' and 'group' can be used to define an owner and a group for the\n    archive that is being built. If not provided, the current owner and group\n    will be used.\n\n    The output tar file will be named 'base_name' +  \".tar\", possibly plus\n    the appropriate compression extension (\".gz\", \".bz2\", or \".xz\").\n\n    Returns the output filename.\n    \"\"\"\n    if compress is None:\n        tar_compression = ''\n    elif _ZLIB_SUPPORTED and compress == 'gzip':\n        tar_compression = 'gz'\n    elif _BZ2_SUPPORTED and compress == 'bzip2':\n        tar_compression = 'bz2'\n    elif _LZMA_SUPPORTED and compress == 'xz':\n        tar_compression = 'xz'\n    else:\n        raise ValueError(\"bad value for 'compress', or compression format not \"\n                         \"supported : {0}\".format(compress))\n\n    import tarfile  # late import for breaking circular dependency\n\n    compress_ext = '.' + tar_compression if compress else ''\n    archive_name = base_name + '.tar' + compress_ext\n    archive_dir = os.path.dirname(archive_name)\n\n    if archive_dir and not os.path.exists(archive_dir):\n        if logger is not None:\n            logger.info(\"creating %s\", archive_dir)\n        if not dry_run:\n            os.makedirs(archive_dir)\n\n    # creating the tarball\n    if logger is not None:\n        logger.info('Creating tar archive')\n\n    uid = _get_uid(owner)\n    gid = _get_gid(group)\n\n    def _set_uid_gid(tarinfo):\n        if gid is not None:\n            tarinfo.gid = gid\n            tarinfo.gname = group\n        if uid is not None:\n            tarinfo.uid = uid\n            tarinfo.uname = owner\n        return tarinfo\n\n    if not dry_run:\n        tar = tarfile.open(archive_name, 'w|%s' % tar_compression)\n        arcname = base_dir\n        if root_dir is not None:\n            base_dir = os.path.join(root_dir, base_dir)\n        try:\n            tar.add(base_dir, arcname, filter=_set_uid_gid)\n        finally:\n            tar.close()\n\n    if root_dir is not None:\n        archive_name = os.path.abspath(archive_name)\n    return archive_name\n\ndef _make_zipfile(base_name, base_dir, verbose=0, dry_run=0,\n                  logger=None, owner=None, group=None, root_dir=None):\n    \"\"\"Create a zip file from all the files under 'base_dir'.\n\n    The output zip file will be named 'base_name' + \".zip\".  Returns the\n    name of the output zip file.\n    \"\"\"\n    import zipfile  # late import for breaking circular dependency\n\n    zip_filename = base_name + \".zip\"\n    archive_dir = os.path.dirname(base_name)\n\n    if archive_dir and not os.path.exists(archive_dir):\n        if logger is not None:\n            logger.info(\"creating %s\", archive_dir)\n        if not dry_run:\n            os.makedirs(archive_dir)\n\n    if logger is not None:\n        logger.info(\"creating '%s' and adding '%s' to it\",\n                    zip_filename, base_dir)\n\n    if not dry_run:\n        with zipfile.ZipFile(zip_filename, \"w\",\n                             compression=zipfile.ZIP_DEFLATED) as zf:\n            arcname = os.path.normpath(base_dir)\n            if root_dir is not None:\n                base_dir = os.path.join(root_dir, base_dir)\n            base_dir = os.path.normpath(base_dir)\n            if arcname != os.curdir:\n                zf.write(base_dir, arcname)\n                if logger is not None:\n                    logger.info(\"adding '%s'\", base_dir)\n            for dirpath, dirnames, filenames in os.walk(base_dir):\n                arcdirpath = dirpath\n                if root_dir is not None:\n                    arcdirpath = os.path.relpath(arcdirpath, root_dir)\n                arcdirpath = os.path.normpath(arcdirpath)\n                for name in sorted(dirnames):\n                    path = os.path.join(dirpath, name)\n                    arcname = os.path.join(arcdirpath, name)\n                    zf.write(path, arcname)\n                    if logger is not None:\n                        logger.info(\"adding '%s'\", path)\n                for name in filenames:\n                    path = os.path.join(dirpath, name)\n                    path = os.path.normpath(path)\n                    if os.path.isfile(path):\n                        arcname = os.path.join(arcdirpath, name)\n                        zf.write(path, arcname)\n                        if logger is not None:\n                            logger.info(\"adding '%s'\", path)\n\n    if root_dir is not None:\n        zip_filename = os.path.abspath(zip_filename)\n    return zip_filename\n\n# Maps the name of the archive format to a tuple containing:\n# * the archiving function\n# * extra keyword arguments\n# * description\n# * does it support the root_dir argument?\n_ARCHIVE_FORMATS = {\n    'tar':   (_make_tarball, [('compress', None)],\n              \"uncompressed tar file\", True),\n}\n\nif _ZLIB_SUPPORTED:\n    _ARCHIVE_FORMATS['gztar'] = (_make_tarball, [('compress', 'gzip')],\n                                \"gzip'ed tar-file\", True)\n    _ARCHIVE_FORMATS['zip'] = (_make_zipfile, [], \"ZIP file\", True)\n\nif _BZ2_SUPPORTED:\n    _ARCHIVE_FORMATS['bztar'] = (_make_tarball, [('compress', 'bzip2')],\n                                \"bzip2'ed tar-file\", True)\n\nif _LZMA_SUPPORTED:\n    _ARCHIVE_FORMATS['xztar'] = (_make_tarball, [('compress', 'xz')],\n                                \"xz'ed tar-file\", True)\n\ndef get_archive_formats():\n    \"\"\"Returns a list of supported formats for archiving and unarchiving.\n\n    Each element of the returned sequence is a tuple (name, description)\n    \"\"\"\n    formats = [(name, registry[2]) for name, registry in\n               _ARCHIVE_FORMATS.items()]\n    formats.sort()\n    return formats\n\ndef register_archive_format(name, function, extra_args=None, description=''):\n    \"\"\"Registers an archive format.\n\n    name is the name of the format. function is the callable that will be\n    used to create archives. If provided, extra_args is a sequence of\n    (name, value) tuples that will be passed as arguments to the callable.\n    description can be provided to describe the format, and will be returned\n    by the get_archive_formats() function.\n    \"\"\"\n    if extra_args is None:\n        extra_args = []\n    if not callable(function):\n        raise TypeError('The %s object is not callable' % function)\n    if not isinstance(extra_args, (tuple, list)):\n        raise TypeError('extra_args needs to be a sequence')\n    for element in extra_args:\n        if not isinstance(element, (tuple, list)) or len(element) !=2:\n            raise TypeError('extra_args elements are : (arg_name, value)')\n\n    _ARCHIVE_FORMATS[name] = (function, extra_args, description, False)\n\ndef unregister_archive_format(name):\n    del _ARCHIVE_FORMATS[name]\n\ndef make_archive(base_name, format, root_dir=None, base_dir=None, verbose=0,\n                 dry_run=0, owner=None, group=None, logger=None):\n    \"\"\"Create an archive file (eg. zip or tar).\n\n    'base_name' is the name of the file to create, minus any format-specific\n    extension; 'format' is the archive format: one of \"zip\", \"tar\", \"gztar\",\n    \"bztar\", or \"xztar\".  Or any other registered format.\n\n    'root_dir' is a directory that will be the root directory of the\n    archive; ie. we typically chdir into 'root_dir' before creating the\n    archive.  'base_dir' is the directory where we start archiving from;\n    ie. 'base_dir' will be the common prefix of all files and\n    directories in the archive.  'root_dir' and 'base_dir' both default\n    to the current directory.  Returns the name of the archive file.\n\n    'owner' and 'group' are used when creating a tar archive. By default,\n    uses the current owner and group.\n    \"\"\"\n    sys.audit(\"shutil.make_archive\", base_name, format, root_dir, base_dir)\n    try:\n        format_info = _ARCHIVE_FORMATS[format]\n    except KeyError:\n        raise ValueError(\"unknown archive format '%s'\" % format) from None\n\n    kwargs = {'dry_run': dry_run, 'logger': logger,\n              'owner': owner, 'group': group}\n\n    func = format_info[0]\n    for arg, val in format_info[1]:\n        kwargs[arg] = val\n\n    if base_dir is None:\n        base_dir = os.curdir\n\n    support_root_dir = format_info[3]\n    save_cwd = None\n    if root_dir is not None:\n        if support_root_dir:\n            # Support path-like base_name here for backwards-compatibility.\n            base_name = os.fspath(base_name)\n            kwargs['root_dir'] = root_dir\n        else:\n            save_cwd = os.getcwd()\n            if logger is not None:\n                logger.debug(\"changing into '%s'\", root_dir)\n            base_name = os.path.abspath(base_name)\n            if not dry_run:\n                os.chdir(root_dir)\n\n    try:\n        filename = func(base_name, base_dir, **kwargs)\n    finally:\n        if save_cwd is not None:\n            if logger is not None:\n                logger.debug(\"changing back to '%s'\", save_cwd)\n            os.chdir(save_cwd)\n\n    return filename\n\n\ndef get_unpack_formats():\n    \"\"\"Returns a list of supported formats for unpacking.\n\n    Each element of the returned sequence is a tuple\n    (name, extensions, description)\n    \"\"\"\n    formats = [(name, info[0], info[3]) for name, info in\n               _UNPACK_FORMATS.items()]\n    formats.sort()\n    return formats\n\ndef _check_unpack_options(extensions, function, extra_args):\n    \"\"\"Checks what gets registered as an unpacker.\"\"\"\n    # first make sure no other unpacker is registered for this extension\n    existing_extensions = {}\n    for name, info in _UNPACK_FORMATS.items():\n        for ext in info[0]:\n            existing_extensions[ext] = name\n\n    for extension in extensions:\n        if extension in existing_extensions:\n            msg = '%s is already registered for \"%s\"'\n            raise RegistryError(msg % (extension,\n                                       existing_extensions[extension]))\n\n    if not callable(function):\n        raise TypeError('The registered function must be a callable')\n\n\ndef register_unpack_format(name, extensions, function, extra_args=None,\n                           description=''):\n    \"\"\"Registers an unpack format.\n\n    `name` is the name of the format. `extensions` is a list of extensions\n    corresponding to the format.\n\n    `function` is the callable that will be\n    used to unpack archives. The callable will receive archives to unpack.\n    If it's unable to handle an archive, it needs to raise a ReadError\n    exception.\n\n    If provided, `extra_args` is a sequence of\n    (name, value) tuples that will be passed as arguments to the callable.\n    description can be provided to describe the format, and will be returned\n    by the get_unpack_formats() function.\n    \"\"\"\n    if extra_args is None:\n        extra_args = []\n    _check_unpack_options(extensions, function, extra_args)\n    _UNPACK_FORMATS[name] = extensions, function, extra_args, description\n\ndef unregister_unpack_format(name):\n    \"\"\"Removes the pack format from the registry.\"\"\"\n    del _UNPACK_FORMATS[name]\n\ndef _ensure_directory(path):\n    \"\"\"Ensure that the parent directory of `path` exists\"\"\"\n    dirname = os.path.dirname(path)\n    if not os.path.isdir(dirname):\n        os.makedirs(dirname)\n\ndef _unpack_zipfile(filename, extract_dir):\n    \"\"\"Unpack zip `filename` to `extract_dir`\n    \"\"\"\n    import zipfile  # late import for breaking circular dependency\n\n    if not zipfile.is_zipfile(filename):\n        raise ReadError(\"%s is not a zip file\" % filename)\n\n    zip = zipfile.ZipFile(filename)\n    try:\n        for info in zip.infolist():\n            name = info.filename\n\n            # don't extract absolute paths or ones with .. in them\n            if name.startswith('/') or '..' in name:\n                continue\n\n            targetpath = os.path.join(extract_dir, *name.split('/'))\n            if not targetpath:\n                continue\n\n            _ensure_directory(targetpath)\n            if not name.endswith('/'):\n                # file\n                with zip.open(name, 'r') as source, \\\n                        open(targetpath, 'wb') as target:\n                    copyfileobj(source, target)\n    finally:\n        zip.close()\n\ndef _unpack_tarfile(filename, extract_dir):\n    \"\"\"Unpack tar/tar.gz/tar.bz2/tar.xz `filename` to `extract_dir`\n    \"\"\"\n    import tarfile  # late import for breaking circular dependency\n    try:\n        tarobj = tarfile.open(filename)\n    except tarfile.TarError:\n        raise ReadError(\n            \"%s is not a compressed or uncompressed tar file\" % filename)\n    try:\n        tarobj.extractall(extract_dir)\n    finally:\n        tarobj.close()\n\n# Maps the name of the unpack format to a tuple containing:\n# * extensions\n# * the unpacking function\n# * extra keyword arguments\n# * description\n_UNPACK_FORMATS = {\n    'tar':   (['.tar'], _unpack_tarfile, [], \"uncompressed tar file\"),\n    'zip':   (['.zip'], _unpack_zipfile, [], \"ZIP file\"),\n}\n\nif _ZLIB_SUPPORTED:\n    _UNPACK_FORMATS['gztar'] = (['.tar.gz', '.tgz'], _unpack_tarfile, [],\n                                \"gzip'ed tar-file\")\n\nif _BZ2_SUPPORTED:\n    _UNPACK_FORMATS['bztar'] = (['.tar.bz2', '.tbz2'], _unpack_tarfile, [],\n                                \"bzip2'ed tar-file\")\n\nif _LZMA_SUPPORTED:\n    _UNPACK_FORMATS['xztar'] = (['.tar.xz', '.txz'], _unpack_tarfile, [],\n                                \"xz'ed tar-file\")\n\ndef _find_unpack_format(filename):\n    for name, info in _UNPACK_FORMATS.items():\n        for extension in info[0]:\n            if filename.endswith(extension):\n                return name\n    return None\n\ndef unpack_archive(filename, extract_dir=None, format=None):\n    \"\"\"Unpack an archive.\n\n    `filename` is the name of the archive.\n\n    `extract_dir` is the name of the target directory, where the archive\n    is unpacked. If not provided, the current working directory is used.\n\n    `format` is the archive format: one of \"zip\", \"tar\", \"gztar\", \"bztar\",\n    or \"xztar\".  Or any other registered format.  If not provided,\n    unpack_archive will use the filename extension and see if an unpacker\n    was registered for that extension.\n\n    In case none is found, a ValueError is raised.\n    \"\"\"\n    sys.audit(\"shutil.unpack_archive\", filename, extract_dir, format)\n\n    if extract_dir is None:\n        extract_dir = os.getcwd()\n\n    extract_dir = os.fspath(extract_dir)\n    filename = os.fspath(filename)\n\n    if format is not None:\n        try:\n            format_info = _UNPACK_FORMATS[format]\n        except KeyError:\n            raise ValueError(\"Unknown unpack format '{0}'\".format(format)) from None\n\n        func = format_info[1]\n        func(filename, extract_dir, **dict(format_info[2]))\n    else:\n        # we need to look at the registered unpackers supported extensions\n        format = _find_unpack_format(filename)\n        if format is None:\n            raise ReadError(\"Unknown archive format '{0}'\".format(filename))\n\n        func = _UNPACK_FORMATS[format][1]\n        kwargs = dict(_UNPACK_FORMATS[format][2])\n        func(filename, extract_dir, **kwargs)\n\n\nif hasattr(os, 'statvfs'):\n\n    __all__.append('disk_usage')\n    _ntuple_diskusage = collections.namedtuple('usage', 'total used free')\n    _ntuple_diskusage.total.__doc__ = 'Total space in bytes'\n    _ntuple_diskusage.used.__doc__ = 'Used space in bytes'\n    _ntuple_diskusage.free.__doc__ = 'Free space in bytes'\n\n    def disk_usage(path):\n        \"\"\"Return disk usage statistics about the given path.\n\n        Returned value is a named tuple with attributes 'total', 'used' and\n        'free', which are the amount of total, used and free space, in bytes.\n        \"\"\"\n        st = os.statvfs(path)\n        free = st.f_bavail * st.f_frsize\n        total = st.f_blocks * st.f_frsize\n        used = (st.f_blocks - st.f_bfree) * st.f_frsize\n        return _ntuple_diskusage(total, used, free)\n\nelif _WINDOWS:\n\n    __all__.append('disk_usage')\n    _ntuple_diskusage = collections.namedtuple('usage', 'total used free')\n\n    def disk_usage(path):\n        \"\"\"Return disk usage statistics about the given path.\n\n        Returned values is a named tuple with attributes 'total', 'used' and\n        'free', which are the amount of total, used and free space, in bytes.\n        \"\"\"\n        total, free = nt._getdiskusage(path)\n        used = total - free\n        return _ntuple_diskusage(total, used, free)\n\n\ndef chown(path, user=None, group=None):\n    \"\"\"Change owner user and group of the given path.\n\n    user and group can be the uid/gid or the user/group names, and in that case,\n    they are converted to their respective uid/gid.\n    \"\"\"\n    sys.audit('shutil.chown', path, user, group)\n\n    if user is None and group is None:\n        raise ValueError(\"user and/or group must be set\")\n\n    _user = user\n    _group = group\n\n    # -1 means don't change it\n    if user is None:\n        _user = -1\n    # user can either be an int (the uid) or a string (the system username)\n    elif isinstance(user, str):\n        _user = _get_uid(user)\n        if _user is None:\n            raise LookupError(\"no such user: {!r}\".format(user))\n\n    if group is None:\n        _group = -1\n    elif not isinstance(group, int):\n        _group = _get_gid(group)\n        if _group is None:\n            raise LookupError(\"no such group: {!r}\".format(group))\n\n    os.chown(path, _user, _group)\n\ndef get_terminal_size(fallback=(80, 24)):\n    \"\"\"Get the size of the terminal window.\n\n    For each of the two dimensions, the environment variable, COLUMNS\n    and LINES respectively, is checked. If the variable is defined and\n    the value is a positive integer, it is used.\n\n    When COLUMNS or LINES is not defined, which is the common case,\n    the terminal connected to sys.__stdout__ is queried\n    by invoking os.get_terminal_size.\n\n    If the terminal size cannot be successfully queried, either because\n    the system doesn't support querying, or because we are not\n    connected to a terminal, the value given in fallback parameter\n    is used. Fallback defaults to (80, 24) which is the default\n    size used by many terminal emulators.\n\n    The value returned is a named tuple of type os.terminal_size.\n    \"\"\"\n    # columns, lines are the working values\n    try:\n        columns = int(os.environ['COLUMNS'])\n    except (KeyError, ValueError):\n        columns = 0\n\n    try:\n        lines = int(os.environ['LINES'])\n    except (KeyError, ValueError):\n        lines = 0\n\n    # only query if necessary\n    if columns <= 0 or lines <= 0:\n        try:\n            size = os.get_terminal_size(sys.__stdout__.fileno())\n        except (AttributeError, ValueError, OSError):\n            # stdout is None, closed, detached, or not a terminal, or\n            # os.get_terminal_size() is unsupported\n            size = os.terminal_size(fallback)\n        if columns <= 0:\n            columns = size.columns or fallback[0]\n        if lines <= 0:\n            lines = size.lines or fallback[1]\n\n    return os.terminal_size((columns, lines))\n\n\n# Check that a given file can be accessed with the correct mode.\n# Additionally check that `file` is not a directory, as on Windows\n# directories pass the os.access check.\ndef _access_check(fn, mode):\n    return (os.path.exists(fn) and os.access(fn, mode)\n            and not os.path.isdir(fn))\n\n\ndef which(cmd, mode=os.F_OK | os.X_OK, path=None):\n    \"\"\"Given a command, mode, and a PATH string, return the path which\n    conforms to the given mode on the PATH, or None if there is no such\n    file.\n\n    `mode` defaults to os.F_OK | os.X_OK. `path` defaults to the result\n    of os.environ.get(\"PATH\"), or can be overridden with a custom search\n    path.\n\n    \"\"\"\n    # If we're given a path with a directory part, look it up directly rather\n    # than referring to PATH directories. This includes checking relative to the\n    # current directory, e.g. ./script\n    if os.path.dirname(cmd):\n        if _access_check(cmd, mode):\n            return cmd\n        return None\n\n    use_bytes = isinstance(cmd, bytes)\n\n    if path is None:\n        path = os.environ.get(\"PATH\", None)\n        if path is None:\n            try:\n                path = os.confstr(\"CS_PATH\")\n            except (AttributeError, ValueError):\n                # os.confstr() or CS_PATH is not available\n                path = os.defpath\n        # bpo-35755: Don't use os.defpath if the PATH environment variable is\n        # set to an empty string\n\n    # PATH='' doesn't match, whereas PATH=':' looks in the current directory\n    if not path:\n        return None\n\n    if use_bytes:\n        path = os.fsencode(path)\n        path = path.split(os.fsencode(os.pathsep))\n    else:\n        path = os.fsdecode(path)\n        path = path.split(os.pathsep)\n\n    if sys.platform == \"win32\":\n        # The current directory takes precedence on Windows.\n        curdir = os.curdir\n        if use_bytes:\n            curdir = os.fsencode(curdir)\n        if curdir not in path:\n            path.insert(0, curdir)\n\n        # PATHEXT is necessary to check on Windows.\n        pathext_source = os.getenv(\"PATHEXT\") or _WIN_DEFAULT_PATHEXT\n        pathext = [ext for ext in pathext_source.split(os.pathsep) if ext]\n\n        if use_bytes:\n            pathext = [os.fsencode(ext) for ext in pathext]\n        # See if the given file matches any of the expected path extensions.\n        # This will allow us to short circuit when given \"python.exe\".\n        # If it does match, only test that one, otherwise we have to try\n        # others.\n        if any(cmd.lower().endswith(ext.lower()) for ext in pathext):\n            files = [cmd]\n        else:\n            files = [cmd + ext for ext in pathext]\n    else:\n        # On other platforms you don't have things like PATHEXT to tell you\n        # what file suffixes are executable, so just pass on cmd as-is.\n        files = [cmd]\n\n    seen = set()\n    for dir in path:\n        normdir = os.path.normcase(dir)\n        if not normdir in seen:\n            seen.add(normdir)\n            for thefile in files:\n                name = os.path.join(dir, thefile)\n                if _access_check(name, mode):\n                    return name\n    return None\n",1518],"/home/lc/omni_infer/tools/scripts/start_api_servers.py":["#!/usr/bin/env python\n# -*- coding: utf-8 -*-\n#\n# Copyright 2025 Huawei Technologies Co., Ltd\n#\n# Licensed under the Apache License, Version 2.0 (the \"License\");\n# you may not use this file except in compliance with the License.\n# You may obtain a copy of the License at\n#\n# http://www.apache.org/licenses/LICENSE-2.0\n#\n# Unless required by applicable law or agreed to in writing, software\n# distributed under the License is distributed on an \"AS IS\" BASIS,\n# WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n# See the License for the specific language governing permissions and\n# limitations under the License.\n# ============================================================================\n\nimport os\nimport subprocess\nimport argparse\nimport weakref\nimport time\nimport signal\nimport sys\nimport socket\nimport json\nimport shutil\n\n# Get the terminal width\nterminal_width = shutil.get_terminal_size().columns\n\n\ndef is_port_available(port, host=\"0.0.0.0\"):\n    \"\"\"Check if a port is available on the specified host.\"\"\"\n    with socket.socket(socket.AF_INET, socket.SOCK_STREAM) as s:\n        try:\n            s.bind((host, port))\n            return True\n        except socket.error:\n            return False\n\n\ndef find_available_port(base_port, max_attempts=10, host=\"0.0.0.0\"):\n    \"\"\"Find the next available port starting from base_port.\"\"\"\n    for offset in range(max_attempts):\n        port = base_port + offset\n        if is_port_available(port, host):\n            return port\n    raise RuntimeError(f\"No available port found between {base_port} and {base_port + max_attempts - 1}\")\n\n\nclass ProcessManager:\n    \"\"\"Class to hold processes and enable weakref.finalize.\"\"\"\n    def __init__(self, processes):\n        self.processes = processes\n\n\ndef start_single_node_api_servers(\n    num_servers,\n    model_path,\n    base_api_port,\n    master_ip,\n    master_port,\n    total_dp_size,\n    gpu_util,\n    block_size,\n    tp,\n    served_model_name,\n    server_offset=0,\n    kv_transfer_config=None,\n    log_dir=\"logs\",\n    max_port_attempts=10,\n    max_tokens=4096,\n    extra_args=None,\n    additional_config=None\n):\n    \"\"\"Start multiple VLLM API servers with specified configurations.\"\"\"\n\n    # Hard code dp=1, cuz current we want one api server one DP\n    dp_per_server = 1\n\n    if additional_config:\n        try:\n            json.loads(additional_config)\n        except json.JSONDecodeError as e:\n            raise ValueError(\n                \"additional_config must be a valid JSON string, e.g., '{\\\"key\\\":\\\"value\\\"}'\"\n            ) from e\n\n    os.makedirs(log_dir, exist_ok=True)\n    processes = []\n\n    start_port = find_available_port(base_api_port, max_attempts=max_port_attempts)\n    for rank in range(num_servers):\n        # Set environment variables for each server\n        env = os.environ.copy()\n        env[\"VLLM_DP_SIZE\"] = str(total_dp_size)\n        env[\"VLLM_DP_RANK\"] = str(rank + server_offset)\n        env[\"VLLM_DP_RANK_LOCAL\"] = str(rank + server_offset)\n        env[\"VLLM_DP_MASTER_IP\"] = master_ip\n        env[\"VLLM_DP_MASTER_PORT\"] = str(master_port)\n\n        # Find an available port\n        try:\n            port = find_available_port(start_port + rank, max_attempts=max_port_attempts)\n        except RuntimeError as e:\n            print(f\"Error: {e}\")\n            cleanup_processes(processes)\n            sys.exit(1)\n\n        # Construct the vllm serve command\n        cmd = [\n            \"vllm\", \"serve\", model_path,\n            \"--trust-remote-code\",\n            \"--gpu-memory-utilization\", str(gpu_util),\n            \"--block_size\", str(block_size),\n            \"--tensor-parallel-size\", str(tp),\n            \"--data-parallel-size\", str(dp_per_server),   # one engine core for one dp\n            \"--data-parallel-size-local\", \"1\",            # 'Number of data parallel replicas '\n            \"--data-parallel-address\", master_ip,         # 'Address of data parallel cluster '\n            \"--data-parallel-rpc-port\", str(master_port), # 'Port for data parallel RPC '\n            \"--port\", str(port),\n            \"--served-model-name\", served_model_name,\n            \"--max-model-len\", str(max_tokens)\n        ]\n\n        if kv_transfer_config:\n            cmd.extend([\"--kv-transfer-config\", str(kv_transfer_config)])\n        if extra_args:\n            cmd.extend(extra_args.split())\n        if additional_config:\n            cmd.extend([\"--additional-config\", additional_config])\n\n        # Open a single log file for combined stdout and stderr\n        log_file = open(os.path.join(log_dir, f\"server_{rank}.log\"), \"w\")\n\n        # Start the server process in the background with combined log redirection\n        print('=' * terminal_width)\n        print(f\"Starting API server {rank} on port {port}, logging to {log_dir}/server_{rank}.log\")\n        print('=' * terminal_width)\n        print(f\"Server {rank}>>>{' '.join(cmd)}\")\n        process = subprocess.Popen(\n            cmd,\n            env=env,\n            stdout=log_file,\n            stderr=subprocess.STDOUT  # Redirect stderr to stdout (same log file)\n        )\n        processes.append((process, log_file))\n\n    process_manager = ProcessManager(processes)\n\n    # Define cleanup function for weakref.finalize\n    def cleanup_processes():\n        for i, (proc, log) in enumerate(process_manager.processes):\n            if proc.poll() is None:  # Process is still running\n                print(f\"Cleaning up: Terminating server {i} (PID: {proc.pid})\")\n                proc.terminate()\n                try:\n                    proc.wait(timeout=5)  # Wait up to 5 seconds for clean exit\n                except subprocess.TimeoutExpired:\n                    proc.kill()  # Force kill if timeout occurs\n                    print(f\"API Server {i} did not terminate gracefully, killed\")\n            log.close()\n            print(f\"Closed log file for server {i}\")\n\n    # Set up finalizer for garbage collection\n    weakref.finalize(process_manager, cleanup_processes)\n\n    # Provide feedback on how to monitor logs\n    print('-' * terminal_width)\n    print(f\"Started {num_servers} servers. Logs are in {log_dir}/\")\n    print(f\"Run 'tail -f {log_dir}/server_*.log' to monitor logs in real-time.\")\n    return processes, process_manager\n\n\ndef signal_handler(sig, frame):\n    \"\"\"Handle SIGINT (Ctrl+C) to cleanly exit.\"\"\"\n    print(\"\\nReceived SIGINT, shutting down servers...\")\n    for i, (proc, log) in enumerate(process_manager.processes):\n        if proc.poll() is None:\n            print(f\"Terminating API server {i} (PID: {proc.pid})\")\n            proc.terminate()\n            try:\n                proc.wait(timeout=5)\n            except subprocess.TimeoutExpired:\n                proc.kill()\n                print(f\"API Server {i} did not terminate gracefully, killed\")\n        log.close()\n        print(f\"Closed log file for server {i}\")\n    sys.exit(0)\n\nif __name__ == \"__main__\":\n    parser = argparse.ArgumentParser(\n    description=(\n        \"Start multiple VLLM API servers with combined \"\n        \"logging, cleanup, and port checking.\"\n    ))\n    parser.add_argument(\"--num-servers\", type=int, default=2, help=\"Number of API servers to start\")\n    parser.add_argument(\"--num-dp\", type=int, default=None, help=\"Number of data parallel size.\")\n    parser.add_argument(\"--server-offset\", type=int, default=0, help=\"Server offset for multi-nodes\")\n    parser.add_argument(\"--model-path\", type=str, required=True, help=\"Path to the model\")\n    parser.add_argument(\"--base-api-port\", type=int, default=9000, help=\"Base port for the first API server\")\n    parser.add_argument(\"--master-ip\", type=str, required=True, help=\"Master IP for data parallelism\")\n    parser.add_argument(\"--master-port\", type=int, default=8000, help=\"Master port for data parallelism\")\n    parser.add_argument(\"--gpu-util\", type=float, default=0.9, help=\"GPU memory utilization\")\n    parser.add_argument(\"--block-size\", type=int, default=128, help=\"Block size for VLLM\")\n    parser.add_argument(\"--tp\", type=int, default=1, help=\"Tensor parallelism size\")\n    parser.add_argument(\"--served-model-name\", type=str, required=True, help=\"Name of the served model\")\n    parser.add_argument(\"--max-model-len\", default=16384, type=int, help=\"max number of tokens\")\n    parser.add_argument(\"--max-port-attempts\", type=int, default=20, help=\"Max attempts to find an available port\")\n    parser.add_argument(\"--kv-transfer-config\", type=str, default=\"\", help=\"kv transfer config for VLLM\")\n    parser.add_argument(\n        \"--extra-args\", \n        type=str, \n        default=\"\", \n        help=\"Additional VLLM arguments (space-separated, e.g., '--enable-expert-parallel')\")\n    parser.add_argument(\n        \"--additional-config\", \n        type=str, \n        default=\"\", \n        help=\"JSON-formatted additional platform-specific config, e.g., '{\\\"key\\\":\\\"value\\\"}'\")\n    parser.add_argument(\"--log-dir\", type=str, default=\"logs\", help=\"Directory to store log files\")\n\n    args = parser.parse_args()\n    if not args.num_dp:\n        args.num_dp = args.num_servers\n    if args.num_dp < args.num_servers:\n        raise ValueError(\n            \"Number of DP should be larger or eaqual to number of API servers.\"\n        )\n\n    processes, process_manager = start_single_node_api_servers(\n        num_servers=args.num_servers,\n        model_path=args.model_path,\n        base_api_port=args.base_api_port,\n        master_ip=args.master_ip,\n        master_port=args.master_port,\n        total_dp_size=args.num_dp,\n        server_offset=args.server_offset,\n        gpu_util=args.gpu_util,\n        block_size=args.block_size,\n        tp=args.tp,\n        served_model_name=args.served_model_name,\n        log_dir=args.log_dir,\n        max_port_attempts=args.max_port_attempts,\n        kv_transfer_config=args.kv_transfer_config,\n        max_tokens=args.max_model_len, \n        extra_args=args.extra_args,\n        additional_config=args.additional_config\n    )\n\n    # Register SIGINT handler for Ctrl+C\n    signal.signal(signal.SIGINT, signal_handler)\n\n    # Keep the script running to allow servers to operate\n    print(f\"{args.num_servers} API servers are running. Press Ctrl+C to stop.\")\n    try:\n        while True:\n            time.sleep(1)  # Keep script alive, check processes periodically\n            for i, (proc, _) in enumerate(processes):\n                if proc.poll() is not None:\n                    print(\n                        f\"API Server {i} (PID: {proc.pid}) stopped with exit code {proc.returncode}. \"\n                        f\"Check {args.log_dir}/server_{i}.log for details.\"\n                    )\n    except KeyboardInterrupt:\n        signal_handler(signal.SIGINT, None)",267],"/home/ma-user/anaconda3/envs/py311/lib/python3.11/argparse.py":["# Author: Steven J. Bethard <steven.bethard@gmail.com>.\n# New maintainer as of 29 August 2019:  Raymond Hettinger <raymond.hettinger@gmail.com>\n\n\"\"\"Command-line parsing library\n\nThis module is an optparse-inspired command-line parsing library that:\n\n    - handles both optional and positional arguments\n    - produces highly informative usage messages\n    - supports parsers that dispatch to sub-parsers\n\nThe following is a simple usage example that sums integers from the\ncommand-line and writes the result to a file::\n\n    parser = argparse.ArgumentParser(\n        description='sum the integers at the command line')\n    parser.add_argument(\n        'integers', metavar='int', nargs='+', type=int,\n        help='an integer to be summed')\n    parser.add_argument(\n        '--log', default=sys.stdout, type=argparse.FileType('w'),\n        help='the file where the sum should be written')\n    args = parser.parse_args()\n    args.log.write('%s' % sum(args.integers))\n    args.log.close()\n\nThe module contains the following public classes:\n\n    - ArgumentParser -- The main entry point for command-line parsing. As the\n        example above shows, the add_argument() method is used to populate\n        the parser with actions for optional and positional arguments. Then\n        the parse_args() method is invoked to convert the args at the\n        command-line into an object with attributes.\n\n    - ArgumentError -- The exception raised by ArgumentParser objects when\n        there are errors with the parser's actions. Errors raised while\n        parsing the command-line are caught by ArgumentParser and emitted\n        as command-line messages.\n\n    - FileType -- A factory for defining types of files to be created. As the\n        example above shows, instances of FileType are typically passed as\n        the type= argument of add_argument() calls.\n\n    - Action -- The base class for parser actions. Typically actions are\n        selected by passing strings like 'store_true' or 'append_const' to\n        the action= argument of add_argument(). However, for greater\n        customization of ArgumentParser actions, subclasses of Action may\n        be defined and passed as the action= argument.\n\n    - HelpFormatter, RawDescriptionHelpFormatter, RawTextHelpFormatter,\n        ArgumentDefaultsHelpFormatter -- Formatter classes which\n        may be passed as the formatter_class= argument to the\n        ArgumentParser constructor. HelpFormatter is the default,\n        RawDescriptionHelpFormatter and RawTextHelpFormatter tell the parser\n        not to change the formatting for help text, and\n        ArgumentDefaultsHelpFormatter adds information about argument defaults\n        to the help.\n\nAll other classes in this module are considered implementation details.\n(Also note that HelpFormatter and RawDescriptionHelpFormatter are only\nconsidered public as object names -- the API of the formatter objects is\nstill considered an implementation detail.)\n\"\"\"\n\n__version__ = '1.1'\n__all__ = [\n    'ArgumentParser',\n    'ArgumentError',\n    'ArgumentTypeError',\n    'BooleanOptionalAction',\n    'FileType',\n    'HelpFormatter',\n    'ArgumentDefaultsHelpFormatter',\n    'RawDescriptionHelpFormatter',\n    'RawTextHelpFormatter',\n    'MetavarTypeHelpFormatter',\n    'Namespace',\n    'Action',\n    'ONE_OR_MORE',\n    'OPTIONAL',\n    'PARSER',\n    'REMAINDER',\n    'SUPPRESS',\n    'ZERO_OR_MORE',\n]\n\n\nimport os as _os\nimport re as _re\nimport sys as _sys\n\nimport warnings\n\nfrom gettext import gettext as _, ngettext\n\nSUPPRESS = '==SUPPRESS=='\n\nOPTIONAL = '?'\nZERO_OR_MORE = '*'\nONE_OR_MORE = '+'\nPARSER = 'A...'\nREMAINDER = '...'\n_UNRECOGNIZED_ARGS_ATTR = '_unrecognized_args'\n\n# =============================\n# Utility functions and classes\n# =============================\n\nclass _AttributeHolder(object):\n    \"\"\"Abstract base class that provides __repr__.\n\n    The __repr__ method returns a string in the format::\n        ClassName(attr=name, attr=name, ...)\n    The attributes are determined either by a class-level attribute,\n    '_kwarg_names', or by inspecting the instance __dict__.\n    \"\"\"\n\n    def __repr__(self):\n        type_name = type(self).__name__\n        arg_strings = []\n        star_args = {}\n        for arg in self._get_args():\n            arg_strings.append(repr(arg))\n        for name, value in self._get_kwargs():\n            if name.isidentifier():\n                arg_strings.append('%s=%r' % (name, value))\n            else:\n                star_args[name] = value\n        if star_args:\n            arg_strings.append('**%s' % repr(star_args))\n        return '%s(%s)' % (type_name, ', '.join(arg_strings))\n\n    def _get_kwargs(self):\n        return list(self.__dict__.items())\n\n    def _get_args(self):\n        return []\n\n\ndef _copy_items(items):\n    if items is None:\n        return []\n    # The copy module is used only in the 'append' and 'append_const'\n    # actions, and it is needed only when the default value isn't a list.\n    # Delay its import for speeding up the common case.\n    if type(items) is list:\n        return items[:]\n    import copy\n    return copy.copy(items)\n\n\n# ===============\n# Formatting Help\n# ===============\n\n\nclass HelpFormatter(object):\n    \"\"\"Formatter for generating usage messages and argument help strings.\n\n    Only the name of this class is considered a public API. All the methods\n    provided by the class are considered an implementation detail.\n    \"\"\"\n\n    def __init__(self,\n                 prog,\n                 indent_increment=2,\n                 max_help_position=24,\n                 width=None):\n\n        # default setting for width\n        if width is None:\n            import shutil\n            width = shutil.get_terminal_size().columns\n            width -= 2\n\n        self._prog = prog\n        self._indent_increment = indent_increment\n        self._max_help_position = min(max_help_position,\n                                      max(width - 20, indent_increment * 2))\n        self._width = width\n\n        self._current_indent = 0\n        self._level = 0\n        self._action_max_length = 0\n\n        self._root_section = self._Section(self, None)\n        self._current_section = self._root_section\n\n        self._whitespace_matcher = _re.compile(r'\\s+', _re.ASCII)\n        self._long_break_matcher = _re.compile(r'\\n\\n\\n+')\n\n    # ===============================\n    # Section and indentation methods\n    # ===============================\n    def _indent(self):\n        self._current_indent += self._indent_increment\n        self._level += 1\n\n    def _dedent(self):\n        self._current_indent -= self._indent_increment\n        assert self._current_indent >= 0, 'Indent decreased below 0.'\n        self._level -= 1\n\n    class _Section(object):\n\n        def __init__(self, formatter, parent, heading=None):\n            self.formatter = formatter\n            self.parent = parent\n            self.heading = heading\n            self.items = []\n\n        def format_help(self):\n            # format the indented section\n            if self.parent is not None:\n                self.formatter._indent()\n            join = self.formatter._join_parts\n            item_help = join([func(*args) for func, args in self.items])\n            if self.parent is not None:\n                self.formatter._dedent()\n\n            # return nothing if the section was empty\n            if not item_help:\n                return ''\n\n            # add the heading if the section was non-empty\n            if self.heading is not SUPPRESS and self.heading is not None:\n                current_indent = self.formatter._current_indent\n                heading = '%*s%s:\\n' % (current_indent, '', self.heading)\n            else:\n                heading = ''\n\n            # join the section-initial newline, the heading and the help\n            return join(['\\n', heading, item_help, '\\n'])\n\n    def _add_item(self, func, args):\n        self._current_section.items.append((func, args))\n\n    # ========================\n    # Message building methods\n    # ========================\n    def start_section(self, heading):\n        self._indent()\n        section = self._Section(self, self._current_section, heading)\n        self._add_item(section.format_help, [])\n        self._current_section = section\n\n    def end_section(self):\n        self._current_section = self._current_section.parent\n        self._dedent()\n\n    def add_text(self, text):\n        if text is not SUPPRESS and text is not None:\n            self._add_item(self._format_text, [text])\n\n    def add_usage(self, usage, actions, groups, prefix=None):\n        if usage is not SUPPRESS:\n            args = usage, actions, groups, prefix\n            self._add_item(self._format_usage, args)\n\n    def add_argument(self, action):\n        if action.help is not SUPPRESS:\n\n            # find all invocations\n            get_invocation = self._format_action_invocation\n            invocations = [get_invocation(action)]\n            for subaction in self._iter_indented_subactions(action):\n                invocations.append(get_invocation(subaction))\n\n            # update the maximum item length\n            invocation_length = max(map(len, invocations))\n            action_length = invocation_length + self._current_indent\n            self._action_max_length = max(self._action_max_length,\n                                          action_length)\n\n            # add the item to the list\n            self._add_item(self._format_action, [action])\n\n    def add_arguments(self, actions):\n        for action in actions:\n            self.add_argument(action)\n\n    # =======================\n    # Help-formatting methods\n    # =======================\n    def format_help(self):\n        help = self._root_section.format_help()\n        if help:\n            help = self._long_break_matcher.sub('\\n\\n', help)\n            help = help.strip('\\n') + '\\n'\n        return help\n\n    def _join_parts(self, part_strings):\n        return ''.join([part\n                        for part in part_strings\n                        if part and part is not SUPPRESS])\n\n    def _format_usage(self, usage, actions, groups, prefix):\n        if prefix is None:\n            prefix = _('usage: ')\n\n        # if usage is specified, use that\n        if usage is not None:\n            usage = usage % dict(prog=self._prog)\n\n        # if no optionals or positionals are available, usage is just prog\n        elif usage is None and not actions:\n            usage = '%(prog)s' % dict(prog=self._prog)\n\n        # if optionals and positionals are available, calculate usage\n        elif usage is None:\n            prog = '%(prog)s' % dict(prog=self._prog)\n\n            # split optionals from positionals\n            optionals = []\n            positionals = []\n            for action in actions:\n                if action.option_strings:\n                    optionals.append(action)\n                else:\n                    positionals.append(action)\n\n            # build full usage string\n            format = self._format_actions_usage\n            action_usage = format(optionals + positionals, groups)\n            usage = ' '.join([s for s in [prog, action_usage] if s])\n\n            # wrap the usage parts if it's too long\n            text_width = self._width - self._current_indent\n            if len(prefix) + len(usage) > text_width:\n\n                # break usage into wrappable parts\n                part_regexp = (\n                    r'\\(.*?\\)+(?=\\s|$)|'\n                    r'\\[.*?\\]+(?=\\s|$)|'\n                    r'\\S+'\n                )\n                opt_usage = format(optionals, groups)\n                pos_usage = format(positionals, groups)\n                opt_parts = _re.findall(part_regexp, opt_usage)\n                pos_parts = _re.findall(part_regexp, pos_usage)\n                assert ' '.join(opt_parts) == opt_usage\n                assert ' '.join(pos_parts) == pos_usage\n\n                # helper for wrapping lines\n                def get_lines(parts, indent, prefix=None):\n                    lines = []\n                    line = []\n                    if prefix is not None:\n                        line_len = len(prefix) - 1\n                    else:\n                        line_len = len(indent) - 1\n                    for part in parts:\n                        if line_len + 1 + len(part) > text_width and line:\n                            lines.append(indent + ' '.join(line))\n                            line = []\n                            line_len = len(indent) - 1\n                        line.append(part)\n                        line_len += len(part) + 1\n                    if line:\n                        lines.append(indent + ' '.join(line))\n                    if prefix is not None:\n                        lines[0] = lines[0][len(indent):]\n                    return lines\n\n                # if prog is short, follow it with optionals or positionals\n                if len(prefix) + len(prog) <= 0.75 * text_width:\n                    indent = ' ' * (len(prefix) + len(prog) + 1)\n                    if opt_parts:\n                        lines = get_lines([prog] + opt_parts, indent, prefix)\n                        lines.extend(get_lines(pos_parts, indent))\n                    elif pos_parts:\n                        lines = get_lines([prog] + pos_parts, indent, prefix)\n                    else:\n                        lines = [prog]\n\n                # if prog is long, put it on its own line\n                else:\n                    indent = ' ' * len(prefix)\n                    parts = opt_parts + pos_parts\n                    lines = get_lines(parts, indent)\n                    if len(lines) > 1:\n                        lines = []\n                        lines.extend(get_lines(opt_parts, indent))\n                        lines.extend(get_lines(pos_parts, indent))\n                    lines = [prog] + lines\n\n                # join lines into usage\n                usage = '\\n'.join(lines)\n\n        # prefix with 'usage:'\n        return '%s%s\\n\\n' % (prefix, usage)\n\n    def _format_actions_usage(self, actions, groups):\n        # find group indices and identify actions in groups\n        group_actions = set()\n        inserts = {}\n        for group in groups:\n            if not group._group_actions:\n                raise ValueError(f'empty group {group}')\n\n            try:\n                start = actions.index(group._group_actions[0])\n            except ValueError:\n                continue\n            else:\n                end = start + len(group._group_actions)\n                if actions[start:end] == group._group_actions:\n                    for action in group._group_actions:\n                        group_actions.add(action)\n                    if not group.required:\n                        if start in inserts:\n                            inserts[start] += ' ['\n                        else:\n                            inserts[start] = '['\n                        if end in inserts:\n                            inserts[end] += ']'\n                        else:\n                            inserts[end] = ']'\n                    else:\n                        if start in inserts:\n                            inserts[start] += ' ('\n                        else:\n                            inserts[start] = '('\n                        if end in inserts:\n                            inserts[end] += ')'\n                        else:\n                            inserts[end] = ')'\n                    for i in range(start + 1, end):\n                        inserts[i] = '|'\n\n        # collect all actions format strings\n        parts = []\n        for i, action in enumerate(actions):\n\n            # suppressed arguments are marked with None\n            # remove | separators for suppressed arguments\n            if action.help is SUPPRESS:\n                parts.append(None)\n                if inserts.get(i) == '|':\n                    inserts.pop(i)\n                elif inserts.get(i + 1) == '|':\n                    inserts.pop(i + 1)\n\n            # produce all arg strings\n            elif not action.option_strings:\n                default = self._get_default_metavar_for_positional(action)\n                part = self._format_args(action, default)\n\n                # if it's in a group, strip the outer []\n                if action in group_actions:\n                    if part[0] == '[' and part[-1] == ']':\n                        part = part[1:-1]\n\n                # add the action string to the list\n                parts.append(part)\n\n            # produce the first way to invoke the option in brackets\n            else:\n                option_string = action.option_strings[0]\n\n                # if the Optional doesn't take a value, format is:\n                #    -s or --long\n                if action.nargs == 0:\n                    part = action.format_usage()\n\n                # if the Optional takes a value, format is:\n                #    -s ARGS or --long ARGS\n                else:\n                    default = self._get_default_metavar_for_optional(action)\n                    args_string = self._format_args(action, default)\n                    part = '%s %s' % (option_string, args_string)\n\n                # make it look optional if it's not required or in a group\n                if not action.required and action not in group_actions:\n                    part = '[%s]' % part\n\n                # add the action string to the list\n                parts.append(part)\n\n        # insert things at the necessary indices\n        for i in sorted(inserts, reverse=True):\n            parts[i:i] = [inserts[i]]\n\n        # join all the action items with spaces\n        text = ' '.join([item for item in parts if item is not None])\n\n        # clean up separators for mutually exclusive groups\n        open = r'[\\[(]'\n        close = r'[\\])]'\n        text = _re.sub(r'(%s) ' % open, r'\\1', text)\n        text = _re.sub(r' (%s)' % close, r'\\1', text)\n        text = _re.sub(r'%s *%s' % (open, close), r'', text)\n        text = _re.sub(r'\\(([^|]*)\\)', r'\\1', text)\n        text = text.strip()\n\n        # return the text\n        return text\n\n    def _format_text(self, text):\n        if '%(prog)' in text:\n            text = text % dict(prog=self._prog)\n        text_width = max(self._width - self._current_indent, 11)\n        indent = ' ' * self._current_indent\n        return self._fill_text(text, text_width, indent) + '\\n\\n'\n\n    def _format_action(self, action):\n        # determine the required width and the entry label\n        help_position = min(self._action_max_length + 2,\n                            self._max_help_position)\n        help_width = max(self._width - help_position, 11)\n        action_width = help_position - self._current_indent - 2\n        action_header = self._format_action_invocation(action)\n\n        # no help; start on same line and add a final newline\n        if not action.help:\n            tup = self._current_indent, '', action_header\n            action_header = '%*s%s\\n' % tup\n\n        # short action name; start on the same line and pad two spaces\n        elif len(action_header) <= action_width:\n            tup = self._current_indent, '', action_width, action_header\n            action_header = '%*s%-*s  ' % tup\n            indent_first = 0\n\n        # long action name; start on the next line\n        else:\n            tup = self._current_indent, '', action_header\n            action_header = '%*s%s\\n' % tup\n            indent_first = help_position\n\n        # collect the pieces of the action help\n        parts = [action_header]\n\n        # if there was help for the action, add lines of help text\n        if action.help and action.help.strip():\n            help_text = self._expand_help(action)\n            if help_text:\n                help_lines = self._split_lines(help_text, help_width)\n                parts.append('%*s%s\\n' % (indent_first, '', help_lines[0]))\n                for line in help_lines[1:]:\n                    parts.append('%*s%s\\n' % (help_position, '', line))\n\n        # or add a newline if the description doesn't end with one\n        elif not action_header.endswith('\\n'):\n            parts.append('\\n')\n\n        # if there are any sub-actions, add their help as well\n        for subaction in self._iter_indented_subactions(action):\n            parts.append(self._format_action(subaction))\n\n        # return a single string\n        return self._join_parts(parts)\n\n    def _format_action_invocation(self, action):\n        if not action.option_strings:\n            default = self._get_default_metavar_for_positional(action)\n            metavar, = self._metavar_formatter(action, default)(1)\n            return metavar\n\n        else:\n            parts = []\n\n            # if the Optional doesn't take a value, format is:\n            #    -s, --long\n            if action.nargs == 0:\n                parts.extend(action.option_strings)\n\n            # if the Optional takes a value, format is:\n            #    -s ARGS, --long ARGS\n            else:\n                default = self._get_default_metavar_for_optional(action)\n                args_string = self._format_args(action, default)\n                for option_string in action.option_strings:\n                    parts.append('%s %s' % (option_string, args_string))\n\n            return ', '.join(parts)\n\n    def _metavar_formatter(self, action, default_metavar):\n        if action.metavar is not None:\n            result = action.metavar\n        elif action.choices is not None:\n            choice_strs = [str(choice) for choice in action.choices]\n            result = '{%s}' % ','.join(choice_strs)\n        else:\n            result = default_metavar\n\n        def format(tuple_size):\n            if isinstance(result, tuple):\n                return result\n            else:\n                return (result, ) * tuple_size\n        return format\n\n    def _format_args(self, action, default_metavar):\n        get_metavar = self._metavar_formatter(action, default_metavar)\n        if action.nargs is None:\n            result = '%s' % get_metavar(1)\n        elif action.nargs == OPTIONAL:\n            result = '[%s]' % get_metavar(1)\n        elif action.nargs == ZERO_OR_MORE:\n            metavar = get_metavar(1)\n            if len(metavar) == 2:\n                result = '[%s [%s ...]]' % metavar\n            else:\n                result = '[%s ...]' % metavar\n        elif action.nargs == ONE_OR_MORE:\n            result = '%s [%s ...]' % get_metavar(2)\n        elif action.nargs == REMAINDER:\n            result = '...'\n        elif action.nargs == PARSER:\n            result = '%s ...' % get_metavar(1)\n        elif action.nargs == SUPPRESS:\n            result = ''\n        else:\n            try:\n                formats = ['%s' for _ in range(action.nargs)]\n            except TypeError:\n                raise ValueError(\"invalid nargs value\") from None\n            result = ' '.join(formats) % get_metavar(action.nargs)\n        return result\n\n    def _expand_help(self, action):\n        params = dict(vars(action), prog=self._prog)\n        for name in list(params):\n            if params[name] is SUPPRESS:\n                del params[name]\n        for name in list(params):\n            if hasattr(params[name], '__name__'):\n                params[name] = params[name].__name__\n        if params.get('choices') is not None:\n            choices_str = ', '.join([str(c) for c in params['choices']])\n            params['choices'] = choices_str\n        return self._get_help_string(action) % params\n\n    def _iter_indented_subactions(self, action):\n        try:\n            get_subactions = action._get_subactions\n        except AttributeError:\n            pass\n        else:\n            self._indent()\n            yield from get_subactions()\n            self._dedent()\n\n    def _split_lines(self, text, width):\n        text = self._whitespace_matcher.sub(' ', text).strip()\n        # The textwrap module is used only for formatting help.\n        # Delay its import for speeding up the common usage of argparse.\n        import textwrap\n        return textwrap.wrap(text, width)\n\n    def _fill_text(self, text, width, indent):\n        text = self._whitespace_matcher.sub(' ', text).strip()\n        import textwrap\n        return textwrap.fill(text, width,\n                             initial_indent=indent,\n                             subsequent_indent=indent)\n\n    def _get_help_string(self, action):\n        return action.help\n\n    def _get_default_metavar_for_optional(self, action):\n        return action.dest.upper()\n\n    def _get_default_metavar_for_positional(self, action):\n        return action.dest\n\n\nclass RawDescriptionHelpFormatter(HelpFormatter):\n    \"\"\"Help message formatter which retains any formatting in descriptions.\n\n    Only the name of this class is considered a public API. All the methods\n    provided by the class are considered an implementation detail.\n    \"\"\"\n\n    def _fill_text(self, text, width, indent):\n        return ''.join(indent + line for line in text.splitlines(keepends=True))\n\n\nclass RawTextHelpFormatter(RawDescriptionHelpFormatter):\n    \"\"\"Help message formatter which retains formatting of all help text.\n\n    Only the name of this class is considered a public API. All the methods\n    provided by the class are considered an implementation detail.\n    \"\"\"\n\n    def _split_lines(self, text, width):\n        return text.splitlines()\n\n\nclass ArgumentDefaultsHelpFormatter(HelpFormatter):\n    \"\"\"Help message formatter which adds default values to argument help.\n\n    Only the name of this class is considered a public API. All the methods\n    provided by the class are considered an implementation detail.\n    \"\"\"\n\n    def _get_help_string(self, action):\n        \"\"\"\n        Add the default value to the option help message.\n\n        ArgumentDefaultsHelpFormatter and BooleanOptionalAction when it isn't\n        already present. This code will do that, detecting cornercases to\n        prevent duplicates or cases where it wouldn't make sense to the end\n        user.\n        \"\"\"\n        help = action.help\n        if help is None:\n            help = ''\n\n        if '%(default)' not in help:\n            if action.default is not SUPPRESS:\n                defaulting_nargs = [OPTIONAL, ZERO_OR_MORE]\n                if action.option_strings or action.nargs in defaulting_nargs:\n                    help += ' (default: %(default)s)'\n        return help\n\n\n\nclass MetavarTypeHelpFormatter(HelpFormatter):\n    \"\"\"Help message formatter which uses the argument 'type' as the default\n    metavar value (instead of the argument 'dest')\n\n    Only the name of this class is considered a public API. All the methods\n    provided by the class are considered an implementation detail.\n    \"\"\"\n\n    def _get_default_metavar_for_optional(self, action):\n        return action.type.__name__\n\n    def _get_default_metavar_for_positional(self, action):\n        return action.type.__name__\n\n\n# =====================\n# Options and Arguments\n# =====================\n\ndef _get_action_name(argument):\n    if argument is None:\n        return None\n    elif argument.option_strings:\n        return '/'.join(argument.option_strings)\n    elif argument.metavar not in (None, SUPPRESS):\n        return argument.metavar\n    elif argument.dest not in (None, SUPPRESS):\n        return argument.dest\n    elif argument.choices:\n        return '{' + ','.join(argument.choices) + '}'\n    else:\n        return None\n\n\nclass ArgumentError(Exception):\n    \"\"\"An error from creating or using an argument (optional or positional).\n\n    The string value of this exception is the message, augmented with\n    information about the argument that caused it.\n    \"\"\"\n\n    def __init__(self, argument, message):\n        self.argument_name = _get_action_name(argument)\n        self.message = message\n\n    def __str__(self):\n        if self.argument_name is None:\n            format = '%(message)s'\n        else:\n            format = _('argument %(argument_name)s: %(message)s')\n        return format % dict(message=self.message,\n                             argument_name=self.argument_name)\n\n\nclass ArgumentTypeError(Exception):\n    \"\"\"An error from trying to convert a command line string to a type.\"\"\"\n    pass\n\n\n# ==============\n# Action classes\n# ==============\n\nclass Action(_AttributeHolder):\n    \"\"\"Information about how to convert command line strings to Python objects.\n\n    Action objects are used by an ArgumentParser to represent the information\n    needed to parse a single argument from one or more strings from the\n    command line. The keyword arguments to the Action constructor are also\n    all attributes of Action instances.\n\n    Keyword Arguments:\n\n        - option_strings -- A list of command-line option strings which\n            should be associated with this action.\n\n        - dest -- The name of the attribute to hold the created object(s)\n\n        - nargs -- The number of command-line arguments that should be\n            consumed. By default, one argument will be consumed and a single\n            value will be produced.  Other values include:\n                - N (an integer) consumes N arguments (and produces a list)\n                - '?' consumes zero or one arguments\n                - '*' consumes zero or more arguments (and produces a list)\n                - '+' consumes one or more arguments (and produces a list)\n            Note that the difference between the default and nargs=1 is that\n            with the default, a single value will be produced, while with\n            nargs=1, a list containing a single value will be produced.\n\n        - const -- The value to be produced if the option is specified and the\n            option uses an action that takes no values.\n\n        - default -- The value to be produced if the option is not specified.\n\n        - type -- A callable that accepts a single string argument, and\n            returns the converted value.  The standard Python types str, int,\n            float, and complex are useful examples of such callables.  If None,\n            str is used.\n\n        - choices -- A container of values that should be allowed. If not None,\n            after a command-line argument has been converted to the appropriate\n            type, an exception will be raised if it is not a member of this\n            collection.\n\n        - required -- True if the action must always be specified at the\n            command line. This is only meaningful for optional command-line\n            arguments.\n\n        - help -- The help string describing the argument.\n\n        - metavar -- The name to be used for the option's argument with the\n            help string. If None, the 'dest' value will be used as the name.\n    \"\"\"\n\n    def __init__(self,\n                 option_strings,\n                 dest,\n                 nargs=None,\n                 const=None,\n                 default=None,\n                 type=None,\n                 choices=None,\n                 required=False,\n                 help=None,\n                 metavar=None):\n        self.option_strings = option_strings\n        self.dest = dest\n        self.nargs = nargs\n        self.const = const\n        self.default = default\n        self.type = type\n        self.choices = choices\n        self.required = required\n        self.help = help\n        self.metavar = metavar\n\n    def _get_kwargs(self):\n        names = [\n            'option_strings',\n            'dest',\n            'nargs',\n            'const',\n            'default',\n            'type',\n            'choices',\n            'required',\n            'help',\n            'metavar',\n        ]\n        return [(name, getattr(self, name)) for name in names]\n\n    def format_usage(self):\n        return self.option_strings[0]\n\n    def __call__(self, parser, namespace, values, option_string=None):\n        raise NotImplementedError(_('.__call__() not defined'))\n\n\nclass BooleanOptionalAction(Action):\n    def __init__(self,\n                 option_strings,\n                 dest,\n                 default=None,\n                 type=None,\n                 choices=None,\n                 required=False,\n                 help=None,\n                 metavar=None):\n\n        _option_strings = []\n        for option_string in option_strings:\n            _option_strings.append(option_string)\n\n            if option_string.startswith('--'):\n                option_string = '--no-' + option_string[2:]\n                _option_strings.append(option_string)\n\n        super().__init__(\n            option_strings=_option_strings,\n            dest=dest,\n            nargs=0,\n            default=default,\n            type=type,\n            choices=choices,\n            required=required,\n            help=help,\n            metavar=metavar)\n\n\n    def __call__(self, parser, namespace, values, option_string=None):\n        if option_string in self.option_strings:\n            setattr(namespace, self.dest, not option_string.startswith('--no-'))\n\n    def format_usage(self):\n        return ' | '.join(self.option_strings)\n\n\nclass _StoreAction(Action):\n\n    def __init__(self,\n                 option_strings,\n                 dest,\n                 nargs=None,\n                 const=None,\n                 default=None,\n                 type=None,\n                 choices=None,\n                 required=False,\n                 help=None,\n                 metavar=None):\n        if nargs == 0:\n            raise ValueError('nargs for store actions must be != 0; if you '\n                             'have nothing to store, actions such as store '\n                             'true or store const may be more appropriate')\n        if const is not None and nargs != OPTIONAL:\n            raise ValueError('nargs must be %r to supply const' % OPTIONAL)\n        super(_StoreAction, self).__init__(\n            option_strings=option_strings,\n            dest=dest,\n            nargs=nargs,\n            const=const,\n            default=default,\n            type=type,\n            choices=choices,\n            required=required,\n            help=help,\n            metavar=metavar)\n\n    def __call__(self, parser, namespace, values, option_string=None):\n        setattr(namespace, self.dest, values)\n\n\nclass _StoreConstAction(Action):\n\n    def __init__(self,\n                 option_strings,\n                 dest,\n                 const=None,\n                 default=None,\n                 required=False,\n                 help=None,\n                 metavar=None):\n        super(_StoreConstAction, self).__init__(\n            option_strings=option_strings,\n            dest=dest,\n            nargs=0,\n            const=const,\n            default=default,\n            required=required,\n            help=help)\n\n    def __call__(self, parser, namespace, values, option_string=None):\n        setattr(namespace, self.dest, self.const)\n\n\nclass _StoreTrueAction(_StoreConstAction):\n\n    def __init__(self,\n                 option_strings,\n                 dest,\n                 default=False,\n                 required=False,\n                 help=None):\n        super(_StoreTrueAction, self).__init__(\n            option_strings=option_strings,\n            dest=dest,\n            const=True,\n            default=default,\n            required=required,\n            help=help)\n\n\nclass _StoreFalseAction(_StoreConstAction):\n\n    def __init__(self,\n                 option_strings,\n                 dest,\n                 default=True,\n                 required=False,\n                 help=None):\n        super(_StoreFalseAction, self).__init__(\n            option_strings=option_strings,\n            dest=dest,\n            const=False,\n            default=default,\n            required=required,\n            help=help)\n\n\nclass _AppendAction(Action):\n\n    def __init__(self,\n                 option_strings,\n                 dest,\n                 nargs=None,\n                 const=None,\n                 default=None,\n                 type=None,\n                 choices=None,\n                 required=False,\n                 help=None,\n                 metavar=None):\n        if nargs == 0:\n            raise ValueError('nargs for append actions must be != 0; if arg '\n                             'strings are not supplying the value to append, '\n                             'the append const action may be more appropriate')\n        if const is not None and nargs != OPTIONAL:\n            raise ValueError('nargs must be %r to supply const' % OPTIONAL)\n        super(_AppendAction, self).__init__(\n            option_strings=option_strings,\n            dest=dest,\n            nargs=nargs,\n            const=const,\n            default=default,\n            type=type,\n            choices=choices,\n            required=required,\n            help=help,\n            metavar=metavar)\n\n    def __call__(self, parser, namespace, values, option_string=None):\n        items = getattr(namespace, self.dest, None)\n        items = _copy_items(items)\n        items.append(values)\n        setattr(namespace, self.dest, items)\n\n\nclass _AppendConstAction(Action):\n\n    def __init__(self,\n                 option_strings,\n                 dest,\n                 const=None,\n                 default=None,\n                 required=False,\n                 help=None,\n                 metavar=None):\n        super(_AppendConstAction, self).__init__(\n            option_strings=option_strings,\n            dest=dest,\n            nargs=0,\n            const=const,\n            default=default,\n            required=required,\n            help=help,\n            metavar=metavar)\n\n    def __call__(self, parser, namespace, values, option_string=None):\n        items = getattr(namespace, self.dest, None)\n        items = _copy_items(items)\n        items.append(self.const)\n        setattr(namespace, self.dest, items)\n\n\nclass _CountAction(Action):\n\n    def __init__(self,\n                 option_strings,\n                 dest,\n                 default=None,\n                 required=False,\n                 help=None):\n        super(_CountAction, self).__init__(\n            option_strings=option_strings,\n            dest=dest,\n            nargs=0,\n            default=default,\n            required=required,\n            help=help)\n\n    def __call__(self, parser, namespace, values, option_string=None):\n        count = getattr(namespace, self.dest, None)\n        if count is None:\n            count = 0\n        setattr(namespace, self.dest, count + 1)\n\n\nclass _HelpAction(Action):\n\n    def __init__(self,\n                 option_strings,\n                 dest=SUPPRESS,\n                 default=SUPPRESS,\n                 help=None):\n        super(_HelpAction, self).__init__(\n            option_strings=option_strings,\n            dest=dest,\n            default=default,\n            nargs=0,\n            help=help)\n\n    def __call__(self, parser, namespace, values, option_string=None):\n        parser.print_help()\n        parser.exit()\n\n\nclass _VersionAction(Action):\n\n    def __init__(self,\n                 option_strings,\n                 version=None,\n                 dest=SUPPRESS,\n                 default=SUPPRESS,\n                 help=\"show program's version number and exit\"):\n        super(_VersionAction, self).__init__(\n            option_strings=option_strings,\n            dest=dest,\n            default=default,\n            nargs=0,\n            help=help)\n        self.version = version\n\n    def __call__(self, parser, namespace, values, option_string=None):\n        version = self.version\n        if version is None:\n            version = parser.version\n        formatter = parser._get_formatter()\n        formatter.add_text(version)\n        parser._print_message(formatter.format_help(), _sys.stdout)\n        parser.exit()\n\n\nclass _SubParsersAction(Action):\n\n    class _ChoicesPseudoAction(Action):\n\n        def __init__(self, name, aliases, help):\n            metavar = dest = name\n            if aliases:\n                metavar += ' (%s)' % ', '.join(aliases)\n            sup = super(_SubParsersAction._ChoicesPseudoAction, self)\n            sup.__init__(option_strings=[], dest=dest, help=help,\n                         metavar=metavar)\n\n    def __init__(self,\n                 option_strings,\n                 prog,\n                 parser_class,\n                 dest=SUPPRESS,\n                 required=False,\n                 help=None,\n                 metavar=None):\n\n        self._prog_prefix = prog\n        self._parser_class = parser_class\n        self._name_parser_map = {}\n        self._choices_actions = []\n\n        super(_SubParsersAction, self).__init__(\n            option_strings=option_strings,\n            dest=dest,\n            nargs=PARSER,\n            choices=self._name_parser_map,\n            required=required,\n            help=help,\n            metavar=metavar)\n\n    def add_parser(self, name, **kwargs):\n        # set prog from the existing prefix\n        if kwargs.get('prog') is None:\n            kwargs['prog'] = '%s %s' % (self._prog_prefix, name)\n\n        aliases = kwargs.pop('aliases', ())\n\n        if name in self._name_parser_map:\n            raise ArgumentError(self, _('conflicting subparser: %s') % name)\n        for alias in aliases:\n            if alias in self._name_parser_map:\n                raise ArgumentError(\n                    self, _('conflicting subparser alias: %s') % alias)\n\n        # create a pseudo-action to hold the choice help\n        if 'help' in kwargs:\n            help = kwargs.pop('help')\n            choice_action = self._ChoicesPseudoAction(name, aliases, help)\n            self._choices_actions.append(choice_action)\n\n        # create the parser and add it to the map\n        parser = self._parser_class(**kwargs)\n        self._name_parser_map[name] = parser\n\n        # make parser available under aliases also\n        for alias in aliases:\n            self._name_parser_map[alias] = parser\n\n        return parser\n\n    def _get_subactions(self):\n        return self._choices_actions\n\n    def __call__(self, parser, namespace, values, option_string=None):\n        parser_name = values[0]\n        arg_strings = values[1:]\n\n        # set the parser name if requested\n        if self.dest is not SUPPRESS:\n            setattr(namespace, self.dest, parser_name)\n\n        # select the parser\n        try:\n            parser = self._name_parser_map[parser_name]\n        except KeyError:\n            args = {'parser_name': parser_name,\n                    'choices': ', '.join(self._name_parser_map)}\n            msg = _('unknown parser %(parser_name)r (choices: %(choices)s)') % args\n            raise ArgumentError(self, msg)\n\n        # parse all the remaining options into the namespace\n        # store any unrecognized options on the object, so that the top\n        # level parser can decide what to do with them\n\n        # In case this subparser defines new defaults, we parse them\n        # in a new namespace object and then update the original\n        # namespace for the relevant parts.\n        subnamespace, arg_strings = parser.parse_known_args(arg_strings, None)\n        for key, value in vars(subnamespace).items():\n            setattr(namespace, key, value)\n\n        if arg_strings:\n            vars(namespace).setdefault(_UNRECOGNIZED_ARGS_ATTR, [])\n            getattr(namespace, _UNRECOGNIZED_ARGS_ATTR).extend(arg_strings)\n\nclass _ExtendAction(_AppendAction):\n    def __call__(self, parser, namespace, values, option_string=None):\n        items = getattr(namespace, self.dest, None)\n        items = _copy_items(items)\n        items.extend(values)\n        setattr(namespace, self.dest, items)\n\n# ==============\n# Type classes\n# ==============\n\nclass FileType(object):\n    \"\"\"Factory for creating file object types\n\n    Instances of FileType are typically passed as type= arguments to the\n    ArgumentParser add_argument() method.\n\n    Keyword Arguments:\n        - mode -- A string indicating how the file is to be opened. Accepts the\n            same values as the builtin open() function.\n        - bufsize -- The file's desired buffer size. Accepts the same values as\n            the builtin open() function.\n        - encoding -- The file's encoding. Accepts the same values as the\n            builtin open() function.\n        - errors -- A string indicating how encoding and decoding errors are to\n            be handled. Accepts the same value as the builtin open() function.\n    \"\"\"\n\n    def __init__(self, mode='r', bufsize=-1, encoding=None, errors=None):\n        self._mode = mode\n        self._bufsize = bufsize\n        self._encoding = encoding\n        self._errors = errors\n\n    def __call__(self, string):\n        # the special argument \"-\" means sys.std{in,out}\n        if string == '-':\n            if 'r' in self._mode:\n                return _sys.stdin.buffer if 'b' in self._mode else _sys.stdin\n            elif any(c in self._mode for c in 'wax'):\n                return _sys.stdout.buffer if 'b' in self._mode else _sys.stdout\n            else:\n                msg = _('argument \"-\" with mode %r') % self._mode\n                raise ValueError(msg)\n\n        # all other arguments are used as file names\n        try:\n            return open(string, self._mode, self._bufsize, self._encoding,\n                        self._errors)\n        except OSError as e:\n            args = {'filename': string, 'error': e}\n            message = _(\"can't open '%(filename)s': %(error)s\")\n            raise ArgumentTypeError(message % args)\n\n    def __repr__(self):\n        args = self._mode, self._bufsize\n        kwargs = [('encoding', self._encoding), ('errors', self._errors)]\n        args_str = ', '.join([repr(arg) for arg in args if arg != -1] +\n                             ['%s=%r' % (kw, arg) for kw, arg in kwargs\n                              if arg is not None])\n        return '%s(%s)' % (type(self).__name__, args_str)\n\n# ===========================\n# Optional and Positional Parsing\n# ===========================\n\nclass Namespace(_AttributeHolder):\n    \"\"\"Simple object for storing attributes.\n\n    Implements equality by attribute names and values, and provides a simple\n    string representation.\n    \"\"\"\n\n    def __init__(self, **kwargs):\n        for name in kwargs:\n            setattr(self, name, kwargs[name])\n\n    def __eq__(self, other):\n        if not isinstance(other, Namespace):\n            return NotImplemented\n        return vars(self) == vars(other)\n\n    def __contains__(self, key):\n        return key in self.__dict__\n\n\nclass _ActionsContainer(object):\n\n    def __init__(self,\n                 description,\n                 prefix_chars,\n                 argument_default,\n                 conflict_handler):\n        super(_ActionsContainer, self).__init__()\n\n        self.description = description\n        self.argument_default = argument_default\n        self.prefix_chars = prefix_chars\n        self.conflict_handler = conflict_handler\n\n        # set up registries\n        self._registries = {}\n\n        # register actions\n        self.register('action', None, _StoreAction)\n        self.register('action', 'store', _StoreAction)\n        self.register('action', 'store_const', _StoreConstAction)\n        self.register('action', 'store_true', _StoreTrueAction)\n        self.register('action', 'store_false', _StoreFalseAction)\n        self.register('action', 'append', _AppendAction)\n        self.register('action', 'append_const', _AppendConstAction)\n        self.register('action', 'count', _CountAction)\n        self.register('action', 'help', _HelpAction)\n        self.register('action', 'version', _VersionAction)\n        self.register('action', 'parsers', _SubParsersAction)\n        self.register('action', 'extend', _ExtendAction)\n\n        # raise an exception if the conflict handler is invalid\n        self._get_handler()\n\n        # action storage\n        self._actions = []\n        self._option_string_actions = {}\n\n        # groups\n        self._action_groups = []\n        self._mutually_exclusive_groups = []\n\n        # defaults storage\n        self._defaults = {}\n\n        # determines whether an \"option\" looks like a negative number\n        self._negative_number_matcher = _re.compile(r'^-\\d+$|^-\\d*\\.\\d+$')\n\n        # whether or not there are any optionals that look like negative\n        # numbers -- uses a list so it can be shared and edited\n        self._has_negative_number_optionals = []\n\n    # ====================\n    # Registration methods\n    # ====================\n    def register(self, registry_name, value, object):\n        registry = self._registries.setdefault(registry_name, {})\n        registry[value] = object\n\n    def _registry_get(self, registry_name, value, default=None):\n        return self._registries[registry_name].get(value, default)\n\n    # ==================================\n    # Namespace default accessor methods\n    # ==================================\n    def set_defaults(self, **kwargs):\n        self._defaults.update(kwargs)\n\n        # if these defaults match any existing arguments, replace\n        # the previous default on the object with the new one\n        for action in self._actions:\n            if action.dest in kwargs:\n                action.default = kwargs[action.dest]\n\n    def get_default(self, dest):\n        for action in self._actions:\n            if action.dest == dest and action.default is not None:\n                return action.default\n        return self._defaults.get(dest, None)\n\n\n    # =======================\n    # Adding argument actions\n    # =======================\n    def add_argument(self, *args, **kwargs):\n        \"\"\"\n        add_argument(dest, ..., name=value, ...)\n        add_argument(option_string, option_string, ..., name=value, ...)\n        \"\"\"\n\n        # if no positional args are supplied or only one is supplied and\n        # it doesn't look like an option string, parse a positional\n        # argument\n        chars = self.prefix_chars\n        if not args or len(args) == 1 and args[0][0] not in chars:\n            if args and 'dest' in kwargs:\n                raise ValueError('dest supplied twice for positional argument')\n            kwargs = self._get_positional_kwargs(*args, **kwargs)\n\n        # otherwise, we're adding an optional argument\n        else:\n            kwargs = self._get_optional_kwargs(*args, **kwargs)\n\n        # if no default was supplied, use the parser-level default\n        if 'default' not in kwargs:\n            dest = kwargs['dest']\n            if dest in self._defaults:\n                kwargs['default'] = self._defaults[dest]\n            elif self.argument_default is not None:\n                kwargs['default'] = self.argument_default\n\n        # create the action object, and add it to the parser\n        action_class = self._pop_action_class(kwargs)\n        if not callable(action_class):\n            raise ValueError('unknown action \"%s\"' % (action_class,))\n        action = action_class(**kwargs)\n\n        # raise an error if the action type is not callable\n        type_func = self._registry_get('type', action.type, action.type)\n        if not callable(type_func):\n            raise ValueError('%r is not callable' % (type_func,))\n\n        if type_func is FileType:\n            raise ValueError('%r is a FileType class object, instance of it'\n                             ' must be passed' % (type_func,))\n\n        # raise an error if the metavar does not match the type\n        if hasattr(self, \"_get_formatter\"):\n            try:\n                self._get_formatter()._format_args(action, None)\n            except TypeError:\n                raise ValueError(\"length of metavar tuple does not match nargs\")\n\n        return self._add_action(action)\n\n    def add_argument_group(self, *args, **kwargs):\n        group = _ArgumentGroup(self, *args, **kwargs)\n        self._action_groups.append(group)\n        return group\n\n    def add_mutually_exclusive_group(self, **kwargs):\n        group = _MutuallyExclusiveGroup(self, **kwargs)\n        self._mutually_exclusive_groups.append(group)\n        return group\n\n    def _add_action(self, action):\n        # resolve any conflicts\n        self._check_conflict(action)\n\n        # add to actions list\n        self._actions.append(action)\n        action.container = self\n\n        # index the action by any option strings it has\n        for option_string in action.option_strings:\n            self._option_string_actions[option_string] = action\n\n        # set the flag if any option strings look like negative numbers\n        for option_string in action.option_strings:\n            if self._negative_number_matcher.match(option_string):\n                if not self._has_negative_number_optionals:\n                    self._has_negative_number_optionals.append(True)\n\n        # return the created action\n        return action\n\n    def _remove_action(self, action):\n        self._actions.remove(action)\n\n    def _add_container_actions(self, container):\n        # collect groups by titles\n        title_group_map = {}\n        for group in self._action_groups:\n            if group.title in title_group_map:\n                msg = _('cannot merge actions - two groups are named %r')\n                raise ValueError(msg % (group.title))\n            title_group_map[group.title] = group\n\n        # map each action to its group\n        group_map = {}\n        for group in container._action_groups:\n\n            # if a group with the title exists, use that, otherwise\n            # create a new group matching the container's group\n            if group.title not in title_group_map:\n                title_group_map[group.title] = self.add_argument_group(\n                    title=group.title,\n                    description=group.description,\n                    conflict_handler=group.conflict_handler)\n\n            # map the actions to their new group\n            for action in group._group_actions:\n                group_map[action] = title_group_map[group.title]\n\n        # add container's mutually exclusive groups\n        # NOTE: if add_mutually_exclusive_group ever gains title= and\n        # description= then this code will need to be expanded as above\n        for group in container._mutually_exclusive_groups:\n            mutex_group = self.add_mutually_exclusive_group(\n                required=group.required)\n\n            # map the actions to their new mutex group\n            for action in group._group_actions:\n                group_map[action] = mutex_group\n\n        # add all actions to this container or their group\n        for action in container._actions:\n            group_map.get(action, self)._add_action(action)\n\n    def _get_positional_kwargs(self, dest, **kwargs):\n        # make sure required is not specified\n        if 'required' in kwargs:\n            msg = _(\"'required' is an invalid argument for positionals\")\n            raise TypeError(msg)\n\n        # mark positional arguments as required if at least one is\n        # always required\n        if kwargs.get('nargs') not in [OPTIONAL, ZERO_OR_MORE]:\n            kwargs['required'] = True\n        if kwargs.get('nargs') == ZERO_OR_MORE and 'default' not in kwargs:\n            kwargs['required'] = True\n\n        # return the keyword arguments with no option strings\n        return dict(kwargs, dest=dest, option_strings=[])\n\n    def _get_optional_kwargs(self, *args, **kwargs):\n        # determine short and long option strings\n        option_strings = []\n        long_option_strings = []\n        for option_string in args:\n            # error on strings that don't start with an appropriate prefix\n            if not option_string[0] in self.prefix_chars:\n                args = {'option': option_string,\n                        'prefix_chars': self.prefix_chars}\n                msg = _('invalid option string %(option)r: '\n                        'must start with a character %(prefix_chars)r')\n                raise ValueError(msg % args)\n\n            # strings starting with two prefix characters are long options\n            option_strings.append(option_string)\n            if len(option_string) > 1 and option_string[1] in self.prefix_chars:\n                long_option_strings.append(option_string)\n\n        # infer destination, '--foo-bar' -> 'foo_bar' and '-x' -> 'x'\n        dest = kwargs.pop('dest', None)\n        if dest is None:\n            if long_option_strings:\n                dest_option_string = long_option_strings[0]\n            else:\n                dest_option_string = option_strings[0]\n            dest = dest_option_string.lstrip(self.prefix_chars)\n            if not dest:\n                msg = _('dest= is required for options like %r')\n                raise ValueError(msg % option_string)\n            dest = dest.replace('-', '_')\n\n        # return the updated keyword arguments\n        return dict(kwargs, dest=dest, option_strings=option_strings)\n\n    def _pop_action_class(self, kwargs, default=None):\n        action = kwargs.pop('action', default)\n        return self._registry_get('action', action, action)\n\n    def _get_handler(self):\n        # determine function from conflict handler string\n        handler_func_name = '_handle_conflict_%s' % self.conflict_handler\n        try:\n            return getattr(self, handler_func_name)\n        except AttributeError:\n            msg = _('invalid conflict_resolution value: %r')\n            raise ValueError(msg % self.conflict_handler)\n\n    def _check_conflict(self, action):\n\n        # find all options that conflict with this option\n        confl_optionals = []\n        for option_string in action.option_strings:\n            if option_string in self._option_string_actions:\n                confl_optional = self._option_string_actions[option_string]\n                confl_optionals.append((option_string, confl_optional))\n\n        # resolve any conflicts\n        if confl_optionals:\n            conflict_handler = self._get_handler()\n            conflict_handler(action, confl_optionals)\n\n    def _handle_conflict_error(self, action, conflicting_actions):\n        message = ngettext('conflicting option string: %s',\n                           'conflicting option strings: %s',\n                           len(conflicting_actions))\n        conflict_string = ', '.join([option_string\n                                     for option_string, action\n                                     in conflicting_actions])\n        raise ArgumentError(action, message % conflict_string)\n\n    def _handle_conflict_resolve(self, action, conflicting_actions):\n\n        # remove all conflicting options\n        for option_string, action in conflicting_actions:\n\n            # remove the conflicting option\n            action.option_strings.remove(option_string)\n            self._option_string_actions.pop(option_string, None)\n\n            # if the option now has no option string, remove it from the\n            # container holding it\n            if not action.option_strings:\n                action.container._remove_action(action)\n\n\nclass _ArgumentGroup(_ActionsContainer):\n\n    def __init__(self, container, title=None, description=None, **kwargs):\n        # add any missing keyword arguments by checking the container\n        update = kwargs.setdefault\n        update('conflict_handler', container.conflict_handler)\n        update('prefix_chars', container.prefix_chars)\n        update('argument_default', container.argument_default)\n        super_init = super(_ArgumentGroup, self).__init__\n        super_init(description=description, **kwargs)\n\n        # group attributes\n        self.title = title\n        self._group_actions = []\n\n        # share most attributes with the container\n        self._registries = container._registries\n        self._actions = container._actions\n        self._option_string_actions = container._option_string_actions\n        self._defaults = container._defaults\n        self._has_negative_number_optionals = \\\n            container._has_negative_number_optionals\n        self._mutually_exclusive_groups = container._mutually_exclusive_groups\n\n    def _add_action(self, action):\n        action = super(_ArgumentGroup, self)._add_action(action)\n        self._group_actions.append(action)\n        return action\n\n    def _remove_action(self, action):\n        super(_ArgumentGroup, self)._remove_action(action)\n        self._group_actions.remove(action)\n\n    def add_argument_group(self, *args, **kwargs):\n        warnings.warn(\n            \"Nesting argument groups is deprecated.\",\n            category=DeprecationWarning,\n            stacklevel=2\n        )\n        return super().add_argument_group(*args, **kwargs)\n\n\nclass _MutuallyExclusiveGroup(_ArgumentGroup):\n\n    def __init__(self, container, required=False):\n        super(_MutuallyExclusiveGroup, self).__init__(container)\n        self.required = required\n        self._container = container\n\n    def _add_action(self, action):\n        if action.required:\n            msg = _('mutually exclusive arguments must be optional')\n            raise ValueError(msg)\n        action = self._container._add_action(action)\n        self._group_actions.append(action)\n        return action\n\n    def _remove_action(self, action):\n        self._container._remove_action(action)\n        self._group_actions.remove(action)\n\n    def add_mutually_exclusive_group(self, *args, **kwargs):\n        warnings.warn(\n            \"Nesting mutually exclusive groups is deprecated.\",\n            category=DeprecationWarning,\n            stacklevel=2\n        )\n        return super().add_mutually_exclusive_group(*args, **kwargs)\n\n\nclass ArgumentParser(_AttributeHolder, _ActionsContainer):\n    \"\"\"Object for parsing command line strings into Python objects.\n\n    Keyword Arguments:\n        - prog -- The name of the program (default:\n            ``os.path.basename(sys.argv[0])``)\n        - usage -- A usage message (default: auto-generated from arguments)\n        - description -- A description of what the program does\n        - epilog -- Text following the argument descriptions\n        - parents -- Parsers whose arguments should be copied into this one\n        - formatter_class -- HelpFormatter class for printing help messages\n        - prefix_chars -- Characters that prefix optional arguments\n        - fromfile_prefix_chars -- Characters that prefix files containing\n            additional arguments\n        - argument_default -- The default value for all arguments\n        - conflict_handler -- String indicating how to handle conflicts\n        - add_help -- Add a -h/-help option\n        - allow_abbrev -- Allow long options to be abbreviated unambiguously\n        - exit_on_error -- Determines whether or not ArgumentParser exits with\n            error info when an error occurs\n    \"\"\"\n\n    def __init__(self,\n                 prog=None,\n                 usage=None,\n                 description=None,\n                 epilog=None,\n                 parents=[],\n                 formatter_class=HelpFormatter,\n                 prefix_chars='-',\n                 fromfile_prefix_chars=None,\n                 argument_default=None,\n                 conflict_handler='error',\n                 add_help=True,\n                 allow_abbrev=True,\n                 exit_on_error=True):\n\n        superinit = super(ArgumentParser, self).__init__\n        superinit(description=description,\n                  prefix_chars=prefix_chars,\n                  argument_default=argument_default,\n                  conflict_handler=conflict_handler)\n\n        # default setting for prog\n        if prog is None:\n            prog = _os.path.basename(_sys.argv[0])\n\n        self.prog = prog\n        self.usage = usage\n        self.epilog = epilog\n        self.formatter_class = formatter_class\n        self.fromfile_prefix_chars = fromfile_prefix_chars\n        self.add_help = add_help\n        self.allow_abbrev = allow_abbrev\n        self.exit_on_error = exit_on_error\n\n        add_group = self.add_argument_group\n        self._positionals = add_group(_('positional arguments'))\n        self._optionals = add_group(_('options'))\n        self._subparsers = None\n\n        # register types\n        def identity(string):\n            return string\n        self.register('type', None, identity)\n\n        # add help argument if necessary\n        # (using explicit default to override global argument_default)\n        default_prefix = '-' if '-' in prefix_chars else prefix_chars[0]\n        if self.add_help:\n            self.add_argument(\n                default_prefix+'h', default_prefix*2+'help',\n                action='help', default=SUPPRESS,\n                help=_('show this help message and exit'))\n\n        # add parent arguments and defaults\n        for parent in parents:\n            self._add_container_actions(parent)\n            try:\n                defaults = parent._defaults\n            except AttributeError:\n                pass\n            else:\n                self._defaults.update(defaults)\n\n    # =======================\n    # Pretty __repr__ methods\n    # =======================\n    def _get_kwargs(self):\n        names = [\n            'prog',\n            'usage',\n            'description',\n            'formatter_class',\n            'conflict_handler',\n            'add_help',\n        ]\n        return [(name, getattr(self, name)) for name in names]\n\n    # ==================================\n    # Optional/Positional adding methods\n    # ==================================\n    def add_subparsers(self, **kwargs):\n        if self._subparsers is not None:\n            self.error(_('cannot have multiple subparser arguments'))\n\n        # add the parser class to the arguments if it's not present\n        kwargs.setdefault('parser_class', type(self))\n\n        if 'title' in kwargs or 'description' in kwargs:\n            title = _(kwargs.pop('title', 'subcommands'))\n            description = _(kwargs.pop('description', None))\n            self._subparsers = self.add_argument_group(title, description)\n        else:\n            self._subparsers = self._positionals\n\n        # prog defaults to the usage message of this parser, skipping\n        # optional arguments and with no \"usage:\" prefix\n        if kwargs.get('prog') is None:\n            formatter = self._get_formatter()\n            positionals = self._get_positional_actions()\n            groups = self._mutually_exclusive_groups\n            formatter.add_usage(self.usage, positionals, groups, '')\n            kwargs['prog'] = formatter.format_help().strip()\n\n        # create the parsers action and add it to the positionals list\n        parsers_class = self._pop_action_class(kwargs, 'parsers')\n        action = parsers_class(option_strings=[], **kwargs)\n        self._subparsers._add_action(action)\n\n        # return the created parsers action\n        return action\n\n    def _add_action(self, action):\n        if action.option_strings:\n            self._optionals._add_action(action)\n        else:\n            self._positionals._add_action(action)\n        return action\n\n    def _get_optional_actions(self):\n        return [action\n                for action in self._actions\n                if action.option_strings]\n\n    def _get_positional_actions(self):\n        return [action\n                for action in self._actions\n                if not action.option_strings]\n\n    # =====================================\n    # Command line argument parsing methods\n    # =====================================\n    def parse_args(self, args=None, namespace=None):\n        args, argv = self.parse_known_args(args, namespace)\n        if argv:\n            msg = _('unrecognized arguments: %s')\n            self.error(msg % ' '.join(argv))\n        return args\n\n    def parse_known_args(self, args=None, namespace=None):\n        if args is None:\n            # args default to the system args\n            args = _sys.argv[1:]\n        else:\n            # make sure that args are mutable\n            args = list(args)\n\n        # default Namespace built from parser defaults\n        if namespace is None:\n            namespace = Namespace()\n\n        # add any action defaults that aren't present\n        for action in self._actions:\n            if action.dest is not SUPPRESS:\n                if not hasattr(namespace, action.dest):\n                    if action.default is not SUPPRESS:\n                        setattr(namespace, action.dest, action.default)\n\n        # add any parser defaults that aren't present\n        for dest in self._defaults:\n            if not hasattr(namespace, dest):\n                setattr(namespace, dest, self._defaults[dest])\n\n        # parse the arguments and exit if there are any errors\n        if self.exit_on_error:\n            try:\n                namespace, args = self._parse_known_args(args, namespace)\n            except ArgumentError as err:\n                self.error(str(err))\n        else:\n            namespace, args = self._parse_known_args(args, namespace)\n\n        if hasattr(namespace, _UNRECOGNIZED_ARGS_ATTR):\n            args.extend(getattr(namespace, _UNRECOGNIZED_ARGS_ATTR))\n            delattr(namespace, _UNRECOGNIZED_ARGS_ATTR)\n        return namespace, args\n\n    def _parse_known_args(self, arg_strings, namespace):\n        # replace arg strings that are file references\n        if self.fromfile_prefix_chars is not None:\n            arg_strings = self._read_args_from_files(arg_strings)\n\n        # map all mutually exclusive arguments to the other arguments\n        # they can't occur with\n        action_conflicts = {}\n        for mutex_group in self._mutually_exclusive_groups:\n            group_actions = mutex_group._group_actions\n            for i, mutex_action in enumerate(mutex_group._group_actions):\n                conflicts = action_conflicts.setdefault(mutex_action, [])\n                conflicts.extend(group_actions[:i])\n                conflicts.extend(group_actions[i + 1:])\n\n        # find all option indices, and determine the arg_string_pattern\n        # which has an 'O' if there is an option at an index,\n        # an 'A' if there is an argument, or a '-' if there is a '--'\n        option_string_indices = {}\n        arg_string_pattern_parts = []\n        arg_strings_iter = iter(arg_strings)\n        for i, arg_string in enumerate(arg_strings_iter):\n\n            # all args after -- are non-options\n            if arg_string == '--':\n                arg_string_pattern_parts.append('-')\n                for arg_string in arg_strings_iter:\n                    arg_string_pattern_parts.append('A')\n\n            # otherwise, add the arg to the arg strings\n            # and note the index if it was an option\n            else:\n                option_tuple = self._parse_optional(arg_string)\n                if option_tuple is None:\n                    pattern = 'A'\n                else:\n                    option_string_indices[i] = option_tuple\n                    pattern = 'O'\n                arg_string_pattern_parts.append(pattern)\n\n        # join the pieces together to form the pattern\n        arg_strings_pattern = ''.join(arg_string_pattern_parts)\n\n        # converts arg strings to the appropriate and then takes the action\n        seen_actions = set()\n        seen_non_default_actions = set()\n\n        def take_action(action, argument_strings, option_string=None):\n            seen_actions.add(action)\n            argument_values = self._get_values(action, argument_strings)\n\n            # error if this argument is not allowed with other previously\n            # seen arguments, assuming that actions that use the default\n            # value don't really count as \"present\"\n            if argument_values is not action.default:\n                seen_non_default_actions.add(action)\n                for conflict_action in action_conflicts.get(action, []):\n                    if conflict_action in seen_non_default_actions:\n                        msg = _('not allowed with argument %s')\n                        action_name = _get_action_name(conflict_action)\n                        raise ArgumentError(action, msg % action_name)\n\n            # take the action if we didn't receive a SUPPRESS value\n            # (e.g. from a default)\n            if argument_values is not SUPPRESS:\n                action(self, namespace, argument_values, option_string)\n\n        # function to convert arg_strings into an optional action\n        def consume_optional(start_index):\n\n            # get the optional identified at this index\n            option_tuple = option_string_indices[start_index]\n            action, option_string, explicit_arg = option_tuple\n\n            # identify additional optionals in the same arg string\n            # (e.g. -xyz is the same as -x -y -z if no args are required)\n            match_argument = self._match_argument\n            action_tuples = []\n            while True:\n\n                # if we found no optional action, skip it\n                if action is None:\n                    extras.append(arg_strings[start_index])\n                    return start_index + 1\n\n                # if there is an explicit argument, try to match the\n                # optional's string arguments to only this\n                if explicit_arg is not None:\n                    arg_count = match_argument(action, 'A')\n\n                    # if the action is a single-dash option and takes no\n                    # arguments, try to parse more single-dash options out\n                    # of the tail of the option string\n                    chars = self.prefix_chars\n                    if arg_count == 0 and option_string[1] not in chars:\n                        action_tuples.append((action, [], option_string))\n                        char = option_string[0]\n                        option_string = char + explicit_arg[0]\n                        new_explicit_arg = explicit_arg[1:] or None\n                        optionals_map = self._option_string_actions\n                        if option_string in optionals_map:\n                            action = optionals_map[option_string]\n                            explicit_arg = new_explicit_arg\n                        else:\n                            msg = _('ignored explicit argument %r')\n                            raise ArgumentError(action, msg % explicit_arg)\n\n                    # if the action expect exactly one argument, we've\n                    # successfully matched the option; exit the loop\n                    elif arg_count == 1:\n                        stop = start_index + 1\n                        args = [explicit_arg]\n                        action_tuples.append((action, args, option_string))\n                        break\n\n                    # error if a double-dash option did not use the\n                    # explicit argument\n                    else:\n                        msg = _('ignored explicit argument %r')\n                        raise ArgumentError(action, msg % explicit_arg)\n\n                # if there is no explicit argument, try to match the\n                # optional's string arguments with the following strings\n                # if successful, exit the loop\n                else:\n                    start = start_index + 1\n                    selected_patterns = arg_strings_pattern[start:]\n                    arg_count = match_argument(action, selected_patterns)\n                    stop = start + arg_count\n                    args = arg_strings[start:stop]\n                    action_tuples.append((action, args, option_string))\n                    break\n\n            # add the Optional to the list and return the index at which\n            # the Optional's string args stopped\n            assert action_tuples\n            for action, args, option_string in action_tuples:\n                take_action(action, args, option_string)\n            return stop\n\n        # the list of Positionals left to be parsed; this is modified\n        # by consume_positionals()\n        positionals = self._get_positional_actions()\n\n        # function to convert arg_strings into positional actions\n        def consume_positionals(start_index):\n            # match as many Positionals as possible\n            match_partial = self._match_arguments_partial\n            selected_pattern = arg_strings_pattern[start_index:]\n            arg_counts = match_partial(positionals, selected_pattern)\n\n            # slice off the appropriate arg strings for each Positional\n            # and add the Positional and its args to the list\n            for action, arg_count in zip(positionals, arg_counts):\n                args = arg_strings[start_index: start_index + arg_count]\n                start_index += arg_count\n                take_action(action, args)\n\n            # slice off the Positionals that we just parsed and return the\n            # index at which the Positionals' string args stopped\n            positionals[:] = positionals[len(arg_counts):]\n            return start_index\n\n        # consume Positionals and Optionals alternately, until we have\n        # passed the last option string\n        extras = []\n        start_index = 0\n        if option_string_indices:\n            max_option_string_index = max(option_string_indices)\n        else:\n            max_option_string_index = -1\n        while start_index <= max_option_string_index:\n\n            # consume any Positionals preceding the next option\n            next_option_string_index = min([\n                index\n                for index in option_string_indices\n                if index >= start_index])\n            if start_index != next_option_string_index:\n                positionals_end_index = consume_positionals(start_index)\n\n                # only try to parse the next optional if we didn't consume\n                # the option string during the positionals parsing\n                if positionals_end_index > start_index:\n                    start_index = positionals_end_index\n                    continue\n                else:\n                    start_index = positionals_end_index\n\n            # if we consumed all the positionals we could and we're not\n            # at the index of an option string, there were extra arguments\n            if start_index not in option_string_indices:\n                strings = arg_strings[start_index:next_option_string_index]\n                extras.extend(strings)\n                start_index = next_option_string_index\n\n            # consume the next optional and any arguments for it\n            start_index = consume_optional(start_index)\n\n        # consume any positionals following the last Optional\n        stop_index = consume_positionals(start_index)\n\n        # if we didn't consume all the argument strings, there were extras\n        extras.extend(arg_strings[stop_index:])\n\n        # make sure all required actions were present and also convert\n        # action defaults which were not given as arguments\n        required_actions = []\n        for action in self._actions:\n            if action not in seen_actions:\n                if action.required:\n                    required_actions.append(_get_action_name(action))\n                else:\n                    # Convert action default now instead of doing it before\n                    # parsing arguments to avoid calling convert functions\n                    # twice (which may fail) if the argument was given, but\n                    # only if it was defined already in the namespace\n                    if (action.default is not None and\n                        isinstance(action.default, str) and\n                        hasattr(namespace, action.dest) and\n                        action.default is getattr(namespace, action.dest)):\n                        setattr(namespace, action.dest,\n                                self._get_value(action, action.default))\n\n        if required_actions:\n            self.error(_('the following arguments are required: %s') %\n                       ', '.join(required_actions))\n\n        # make sure all required groups had one option present\n        for group in self._mutually_exclusive_groups:\n            if group.required:\n                for action in group._group_actions:\n                    if action in seen_non_default_actions:\n                        break\n\n                # if no actions were used, report the error\n                else:\n                    names = [_get_action_name(action)\n                             for action in group._group_actions\n                             if action.help is not SUPPRESS]\n                    msg = _('one of the arguments %s is required')\n                    self.error(msg % ' '.join(names))\n\n        # return the updated namespace and the extra arguments\n        return namespace, extras\n\n    def _read_args_from_files(self, arg_strings):\n        # expand arguments referencing files\n        new_arg_strings = []\n        for arg_string in arg_strings:\n\n            # for regular arguments, just add them back into the list\n            if not arg_string or arg_string[0] not in self.fromfile_prefix_chars:\n                new_arg_strings.append(arg_string)\n\n            # replace arguments referencing files with the file content\n            else:\n                try:\n                    with open(arg_string[1:]) as args_file:\n                        arg_strings = []\n                        for arg_line in args_file.read().splitlines():\n                            for arg in self.convert_arg_line_to_args(arg_line):\n                                arg_strings.append(arg)\n                        arg_strings = self._read_args_from_files(arg_strings)\n                        new_arg_strings.extend(arg_strings)\n                except OSError as err:\n                    self.error(str(err))\n\n        # return the modified argument list\n        return new_arg_strings\n\n    def convert_arg_line_to_args(self, arg_line):\n        return [arg_line]\n\n    def _match_argument(self, action, arg_strings_pattern):\n        # match the pattern for this action to the arg strings\n        nargs_pattern = self._get_nargs_pattern(action)\n        match = _re.match(nargs_pattern, arg_strings_pattern)\n\n        # raise an exception if we weren't able to find a match\n        if match is None:\n            nargs_errors = {\n                None: _('expected one argument'),\n                OPTIONAL: _('expected at most one argument'),\n                ONE_OR_MORE: _('expected at least one argument'),\n            }\n            msg = nargs_errors.get(action.nargs)\n            if msg is None:\n                msg = ngettext('expected %s argument',\n                               'expected %s arguments',\n                               action.nargs) % action.nargs\n            raise ArgumentError(action, msg)\n\n        # return the number of arguments matched\n        return len(match.group(1))\n\n    def _match_arguments_partial(self, actions, arg_strings_pattern):\n        # progressively shorten the actions list by slicing off the\n        # final actions until we find a match\n        result = []\n        for i in range(len(actions), 0, -1):\n            actions_slice = actions[:i]\n            pattern = ''.join([self._get_nargs_pattern(action)\n                               for action in actions_slice])\n            match = _re.match(pattern, arg_strings_pattern)\n            if match is not None:\n                result.extend([len(string) for string in match.groups()])\n                break\n\n        # return the list of arg string counts\n        return result\n\n    def _parse_optional(self, arg_string):\n        # if it's an empty string, it was meant to be a positional\n        if not arg_string:\n            return None\n\n        # if it doesn't start with a prefix, it was meant to be positional\n        if not arg_string[0] in self.prefix_chars:\n            return None\n\n        # if the option string is present in the parser, return the action\n        if arg_string in self._option_string_actions:\n            action = self._option_string_actions[arg_string]\n            return action, arg_string, None\n\n        # if it's just a single character, it was meant to be positional\n        if len(arg_string) == 1:\n            return None\n\n        # if the option string before the \"=\" is present, return the action\n        if '=' in arg_string:\n            option_string, explicit_arg = arg_string.split('=', 1)\n            if option_string in self._option_string_actions:\n                action = self._option_string_actions[option_string]\n                return action, option_string, explicit_arg\n\n        # search through all possible prefixes of the option string\n        # and all actions in the parser for possible interpretations\n        option_tuples = self._get_option_tuples(arg_string)\n\n        # if multiple actions match, the option string was ambiguous\n        if len(option_tuples) > 1:\n            options = ', '.join([option_string\n                for action, option_string, explicit_arg in option_tuples])\n            args = {'option': arg_string, 'matches': options}\n            msg = _('ambiguous option: %(option)s could match %(matches)s')\n            self.error(msg % args)\n\n        # if exactly one action matched, this segmentation is good,\n        # so return the parsed action\n        elif len(option_tuples) == 1:\n            option_tuple, = option_tuples\n            return option_tuple\n\n        # if it was not found as an option, but it looks like a negative\n        # number, it was meant to be positional\n        # unless there are negative-number-like options\n        if self._negative_number_matcher.match(arg_string):\n            if not self._has_negative_number_optionals:\n                return None\n\n        # if it contains a space, it was meant to be a positional\n        if ' ' in arg_string:\n            return None\n\n        # it was meant to be an optional but there is no such option\n        # in this parser (though it might be a valid option in a subparser)\n        return None, arg_string, None\n\n    def _get_option_tuples(self, option_string):\n        result = []\n\n        # option strings starting with two prefix characters are only\n        # split at the '='\n        chars = self.prefix_chars\n        if option_string[0] in chars and option_string[1] in chars:\n            if self.allow_abbrev:\n                if '=' in option_string:\n                    option_prefix, explicit_arg = option_string.split('=', 1)\n                else:\n                    option_prefix = option_string\n                    explicit_arg = None\n                for option_string in self._option_string_actions:\n                    if option_string.startswith(option_prefix):\n                        action = self._option_string_actions[option_string]\n                        tup = action, option_string, explicit_arg\n                        result.append(tup)\n\n        # single character options can be concatenated with their arguments\n        # but multiple character options always have to have their argument\n        # separate\n        elif option_string[0] in chars and option_string[1] not in chars:\n            option_prefix = option_string\n            explicit_arg = None\n            short_option_prefix = option_string[:2]\n            short_explicit_arg = option_string[2:]\n\n            for option_string in self._option_string_actions:\n                if option_string == short_option_prefix:\n                    action = self._option_string_actions[option_string]\n                    tup = action, option_string, short_explicit_arg\n                    result.append(tup)\n                elif option_string.startswith(option_prefix):\n                    action = self._option_string_actions[option_string]\n                    tup = action, option_string, explicit_arg\n                    result.append(tup)\n\n        # shouldn't ever get here\n        else:\n            self.error(_('unexpected option string: %s') % option_string)\n\n        # return the collected option tuples\n        return result\n\n    def _get_nargs_pattern(self, action):\n        # in all examples below, we have to allow for '--' args\n        # which are represented as '-' in the pattern\n        nargs = action.nargs\n\n        # the default (None) is assumed to be a single argument\n        if nargs is None:\n            nargs_pattern = '(-*A-*)'\n\n        # allow zero or one arguments\n        elif nargs == OPTIONAL:\n            nargs_pattern = '(-*A?-*)'\n\n        # allow zero or more arguments\n        elif nargs == ZERO_OR_MORE:\n            nargs_pattern = '(-*[A-]*)'\n\n        # allow one or more arguments\n        elif nargs == ONE_OR_MORE:\n            nargs_pattern = '(-*A[A-]*)'\n\n        # allow any number of options or arguments\n        elif nargs == REMAINDER:\n            nargs_pattern = '([-AO]*)'\n\n        # allow one argument followed by any number of options or arguments\n        elif nargs == PARSER:\n            nargs_pattern = '(-*A[-AO]*)'\n\n        # suppress action, like nargs=0\n        elif nargs == SUPPRESS:\n            nargs_pattern = '(-*-*)'\n\n        # all others should be integers\n        else:\n            nargs_pattern = '(-*%s-*)' % '-*'.join('A' * nargs)\n\n        # if this is an optional action, -- is not allowed\n        if action.option_strings:\n            nargs_pattern = nargs_pattern.replace('-*', '')\n            nargs_pattern = nargs_pattern.replace('-', '')\n\n        # return the pattern\n        return nargs_pattern\n\n    # ========================\n    # Alt command line argument parsing, allowing free intermix\n    # ========================\n\n    def parse_intermixed_args(self, args=None, namespace=None):\n        args, argv = self.parse_known_intermixed_args(args, namespace)\n        if argv:\n            msg = _('unrecognized arguments: %s')\n            self.error(msg % ' '.join(argv))\n        return args\n\n    def parse_known_intermixed_args(self, args=None, namespace=None):\n        # returns a namespace and list of extras\n        #\n        # positional can be freely intermixed with optionals.  optionals are\n        # first parsed with all positional arguments deactivated.  The 'extras'\n        # are then parsed.  If the parser definition is incompatible with the\n        # intermixed assumptions (e.g. use of REMAINDER, subparsers) a\n        # TypeError is raised.\n        #\n        # positionals are 'deactivated' by setting nargs and default to\n        # SUPPRESS.  This blocks the addition of that positional to the\n        # namespace\n\n        positionals = self._get_positional_actions()\n        a = [action for action in positionals\n             if action.nargs in [PARSER, REMAINDER]]\n        if a:\n            raise TypeError('parse_intermixed_args: positional arg'\n                            ' with nargs=%s'%a[0].nargs)\n\n        if [action.dest for group in self._mutually_exclusive_groups\n            for action in group._group_actions if action in positionals]:\n            raise TypeError('parse_intermixed_args: positional in'\n                            ' mutuallyExclusiveGroup')\n\n        try:\n            save_usage = self.usage\n            try:\n                if self.usage is None:\n                    # capture the full usage for use in error messages\n                    self.usage = self.format_usage()[7:]\n                for action in positionals:\n                    # deactivate positionals\n                    action.save_nargs = action.nargs\n                    # action.nargs = 0\n                    action.nargs = SUPPRESS\n                    action.save_default = action.default\n                    action.default = SUPPRESS\n                namespace, remaining_args = self.parse_known_args(args,\n                                                                  namespace)\n                for action in positionals:\n                    # remove the empty positional values from namespace\n                    if (hasattr(namespace, action.dest)\n                            and getattr(namespace, action.dest)==[]):\n                        from warnings import warn\n                        warn('Do not expect %s in %s' % (action.dest, namespace))\n                        delattr(namespace, action.dest)\n            finally:\n                # restore nargs and usage before exiting\n                for action in positionals:\n                    action.nargs = action.save_nargs\n                    action.default = action.save_default\n            optionals = self._get_optional_actions()\n            try:\n                # parse positionals.  optionals aren't normally required, but\n                # they could be, so make sure they aren't.\n                for action in optionals:\n                    action.save_required = action.required\n                    action.required = False\n                for group in self._mutually_exclusive_groups:\n                    group.save_required = group.required\n                    group.required = False\n                namespace, extras = self.parse_known_args(remaining_args,\n                                                          namespace)\n            finally:\n                # restore parser values before exiting\n                for action in optionals:\n                    action.required = action.save_required\n                for group in self._mutually_exclusive_groups:\n                    group.required = group.save_required\n        finally:\n            self.usage = save_usage\n        return namespace, extras\n\n    # ========================\n    # Value conversion methods\n    # ========================\n    def _get_values(self, action, arg_strings):\n        # for everything but PARSER, REMAINDER args, strip out first '--'\n        if action.nargs not in [PARSER, REMAINDER]:\n            try:\n                arg_strings.remove('--')\n            except ValueError:\n                pass\n\n        # optional argument produces a default when not present\n        if not arg_strings and action.nargs == OPTIONAL:\n            if action.option_strings:\n                value = action.const\n            else:\n                value = action.default\n            if isinstance(value, str):\n                value = self._get_value(action, value)\n                self._check_value(action, value)\n\n        # when nargs='*' on a positional, if there were no command-line\n        # args, use the default if it is anything other than None\n        elif (not arg_strings and action.nargs == ZERO_OR_MORE and\n              not action.option_strings):\n            if action.default is not None:\n                value = action.default\n            else:\n                value = arg_strings\n            self._check_value(action, value)\n\n        # single argument or optional argument produces a single value\n        elif len(arg_strings) == 1 and action.nargs in [None, OPTIONAL]:\n            arg_string, = arg_strings\n            value = self._get_value(action, arg_string)\n            self._check_value(action, value)\n\n        # REMAINDER arguments convert all values, checking none\n        elif action.nargs == REMAINDER:\n            value = [self._get_value(action, v) for v in arg_strings]\n\n        # PARSER arguments convert all values, but check only the first\n        elif action.nargs == PARSER:\n            value = [self._get_value(action, v) for v in arg_strings]\n            self._check_value(action, value[0])\n\n        # SUPPRESS argument does not put anything in the namespace\n        elif action.nargs == SUPPRESS:\n            value = SUPPRESS\n\n        # all other types of nargs produce a list\n        else:\n            value = [self._get_value(action, v) for v in arg_strings]\n            for v in value:\n                self._check_value(action, v)\n\n        # return the converted value\n        return value\n\n    def _get_value(self, action, arg_string):\n        type_func = self._registry_get('type', action.type, action.type)\n        if not callable(type_func):\n            msg = _('%r is not callable')\n            raise ArgumentError(action, msg % type_func)\n\n        # convert the value to the appropriate type\n        try:\n            result = type_func(arg_string)\n\n        # ArgumentTypeErrors indicate errors\n        except ArgumentTypeError as err:\n            name = getattr(action.type, '__name__', repr(action.type))\n            msg = str(err)\n            raise ArgumentError(action, msg)\n\n        # TypeErrors or ValueErrors also indicate errors\n        except (TypeError, ValueError):\n            name = getattr(action.type, '__name__', repr(action.type))\n            args = {'type': name, 'value': arg_string}\n            msg = _('invalid %(type)s value: %(value)r')\n            raise ArgumentError(action, msg % args)\n\n        # return the converted value\n        return result\n\n    def _check_value(self, action, value):\n        # converted value must be one of the choices (if specified)\n        if action.choices is not None and value not in action.choices:\n            args = {'value': value,\n                    'choices': ', '.join(map(repr, action.choices))}\n            msg = _('invalid choice: %(value)r (choose from %(choices)s)')\n            raise ArgumentError(action, msg % args)\n\n    # =======================\n    # Help-formatting methods\n    # =======================\n    def format_usage(self):\n        formatter = self._get_formatter()\n        formatter.add_usage(self.usage, self._actions,\n                            self._mutually_exclusive_groups)\n        return formatter.format_help()\n\n    def format_help(self):\n        formatter = self._get_formatter()\n\n        # usage\n        formatter.add_usage(self.usage, self._actions,\n                            self._mutually_exclusive_groups)\n\n        # description\n        formatter.add_text(self.description)\n\n        # positionals, optionals and user-defined groups\n        for action_group in self._action_groups:\n            formatter.start_section(action_group.title)\n            formatter.add_text(action_group.description)\n            formatter.add_arguments(action_group._group_actions)\n            formatter.end_section()\n\n        # epilog\n        formatter.add_text(self.epilog)\n\n        # determine help from format above\n        return formatter.format_help()\n\n    def _get_formatter(self):\n        return self.formatter_class(prog=self.prog)\n\n    # =====================\n    # Help-printing methods\n    # =====================\n    def print_usage(self, file=None):\n        if file is None:\n            file = _sys.stdout\n        self._print_message(self.format_usage(), file)\n\n    def print_help(self, file=None):\n        if file is None:\n            file = _sys.stdout\n        self._print_message(self.format_help(), file)\n\n    def _print_message(self, message, file=None):\n        if message:\n            if file is None:\n                file = _sys.stderr\n            file.write(message)\n\n    # ===============\n    # Exiting methods\n    # ===============\n    def exit(self, status=0, message=None):\n        if message:\n            self._print_message(message, _sys.stderr)\n        _sys.exit(status)\n\n    def error(self, message):\n        \"\"\"error(message: string)\n\n        Prints a usage message incorporating the message to stderr and\n        exits.\n\n        If you override this in a subclass, it should not return -- it\n        should either exit or raise an exception.\n        \"\"\"\n        self.print_usage(_sys.stderr)\n        args = {'prog': self.prog, 'message': message}\n        self.exit(2, _('%(prog)s: error: %(message)s\\n') % args)\n",2617],"/home/ma-user/anaconda3/envs/py311/lib/python3.11/re/__init__.py":["#\n# Secret Labs' Regular Expression Engine\n#\n# re-compatible interface for the sre matching engine\n#\n# Copyright (c) 1998-2001 by Secret Labs AB.  All rights reserved.\n#\n# This version of the SRE library can be redistributed under CNRI's\n# Python 1.6 license.  For any other use, please contact Secret Labs\n# AB (info@pythonware.com).\n#\n# Portions of this engine have been developed in cooperation with\n# CNRI.  Hewlett-Packard provided funding for 1.6 integration and\n# other compatibility work.\n#\n\nr\"\"\"Support for regular expressions (RE).\n\nThis module provides regular expression matching operations similar to\nthose found in Perl.  It supports both 8-bit and Unicode strings; both\nthe pattern and the strings being processed can contain null bytes and\ncharacters outside the US ASCII range.\n\nRegular expressions can contain both special and ordinary characters.\nMost ordinary characters, like \"A\", \"a\", or \"0\", are the simplest\nregular expressions; they simply match themselves.  You can\nconcatenate ordinary characters, so last matches the string 'last'.\n\nThe special characters are:\n    \".\"      Matches any character except a newline.\n    \"^\"      Matches the start of the string.\n    \"$\"      Matches the end of the string or just before the newline at\n             the end of the string.\n    \"*\"      Matches 0 or more (greedy) repetitions of the preceding RE.\n             Greedy means that it will match as many repetitions as possible.\n    \"+\"      Matches 1 or more (greedy) repetitions of the preceding RE.\n    \"?\"      Matches 0 or 1 (greedy) of the preceding RE.\n    *?,+?,?? Non-greedy versions of the previous three special characters.\n    {m,n}    Matches from m to n repetitions of the preceding RE.\n    {m,n}?   Non-greedy version of the above.\n    \"\\\\\"     Either escapes special characters or signals a special sequence.\n    []       Indicates a set of characters.\n             A \"^\" as the first character indicates a complementing set.\n    \"|\"      A|B, creates an RE that will match either A or B.\n    (...)    Matches the RE inside the parentheses.\n             The contents can be retrieved or matched later in the string.\n    (?aiLmsux) The letters set the corresponding flags defined below.\n    (?:...)  Non-grouping version of regular parentheses.\n    (?P<name>...) The substring matched by the group is accessible by name.\n    (?P=name)     Matches the text matched earlier by the group named name.\n    (?#...)  A comment; ignored.\n    (?=...)  Matches if ... matches next, but doesn't consume the string.\n    (?!...)  Matches if ... doesn't match next.\n    (?<=...) Matches if preceded by ... (must be fixed length).\n    (?<!...) Matches if not preceded by ... (must be fixed length).\n    (?(id/name)yes|no) Matches yes pattern if the group with id/name matched,\n                       the (optional) no pattern otherwise.\n\nThe special sequences consist of \"\\\\\" and a character from the list\nbelow.  If the ordinary character is not on the list, then the\nresulting RE will match the second character.\n    \\number  Matches the contents of the group of the same number.\n    \\A       Matches only at the start of the string.\n    \\Z       Matches only at the end of the string.\n    \\b       Matches the empty string, but only at the start or end of a word.\n    \\B       Matches the empty string, but not at the start or end of a word.\n    \\d       Matches any decimal digit; equivalent to the set [0-9] in\n             bytes patterns or string patterns with the ASCII flag.\n             In string patterns without the ASCII flag, it will match the whole\n             range of Unicode digits.\n    \\D       Matches any non-digit character; equivalent to [^\\d].\n    \\s       Matches any whitespace character; equivalent to [ \\t\\n\\r\\f\\v] in\n             bytes patterns or string patterns with the ASCII flag.\n             In string patterns without the ASCII flag, it will match the whole\n             range of Unicode whitespace characters.\n    \\S       Matches any non-whitespace character; equivalent to [^\\s].\n    \\w       Matches any alphanumeric character; equivalent to [a-zA-Z0-9_]\n             in bytes patterns or string patterns with the ASCII flag.\n             In string patterns without the ASCII flag, it will match the\n             range of Unicode alphanumeric characters (letters plus digits\n             plus underscore).\n             With LOCALE, it will match the set [0-9_] plus characters defined\n             as letters for the current locale.\n    \\W       Matches the complement of \\w.\n    \\\\       Matches a literal backslash.\n\nThis module exports the following functions:\n    match     Match a regular expression pattern to the beginning of a string.\n    fullmatch Match a regular expression pattern to all of a string.\n    search    Search a string for the presence of a pattern.\n    sub       Substitute occurrences of a pattern found in a string.\n    subn      Same as sub, but also return the number of substitutions made.\n    split     Split a string by the occurrences of a pattern.\n    findall   Find all occurrences of a pattern in a string.\n    finditer  Return an iterator yielding a Match object for each match.\n    compile   Compile a pattern into a Pattern object.\n    purge     Clear the regular expression cache.\n    escape    Backslash all non-alphanumerics in a string.\n\nEach function other than purge and escape can take an optional 'flags' argument\nconsisting of one or more of the following module constants, joined by \"|\".\nA, L, and U are mutually exclusive.\n    A  ASCII       For string patterns, make \\w, \\W, \\b, \\B, \\d, \\D\n                   match the corresponding ASCII character categories\n                   (rather than the whole Unicode categories, which is the\n                   default).\n                   For bytes patterns, this flag is the only available\n                   behaviour and needn't be specified.\n    I  IGNORECASE  Perform case-insensitive matching.\n    L  LOCALE      Make \\w, \\W, \\b, \\B, dependent on the current locale.\n    M  MULTILINE   \"^\" matches the beginning of lines (after a newline)\n                   as well as the string.\n                   \"$\" matches the end of lines (before a newline) as well\n                   as the end of the string.\n    S  DOTALL      \".\" matches any character at all, including the newline.\n    X  VERBOSE     Ignore whitespace and comments for nicer looking RE's.\n    U  UNICODE     For compatibility only. Ignored for string patterns (it\n                   is the default), and forbidden for bytes patterns.\n\nThis module also defines an exception 'error'.\n\n\"\"\"\n\nimport enum\nfrom . import _compiler, _parser\nimport functools\n\n\n# public symbols\n__all__ = [\n    \"match\", \"fullmatch\", \"search\", \"sub\", \"subn\", \"split\",\n    \"findall\", \"finditer\", \"compile\", \"purge\", \"template\", \"escape\",\n    \"error\", \"Pattern\", \"Match\", \"A\", \"I\", \"L\", \"M\", \"S\", \"X\", \"U\",\n    \"ASCII\", \"IGNORECASE\", \"LOCALE\", \"MULTILINE\", \"DOTALL\", \"VERBOSE\",\n    \"UNICODE\", \"NOFLAG\", \"RegexFlag\",\n]\n\n__version__ = \"2.2.1\"\n\n@enum.global_enum\n@enum._simple_enum(enum.IntFlag, boundary=enum.KEEP)\nclass RegexFlag:\n    NOFLAG = 0\n    ASCII = A = _compiler.SRE_FLAG_ASCII # assume ascii \"locale\"\n    IGNORECASE = I = _compiler.SRE_FLAG_IGNORECASE # ignore case\n    LOCALE = L = _compiler.SRE_FLAG_LOCALE # assume current 8-bit locale\n    UNICODE = U = _compiler.SRE_FLAG_UNICODE # assume unicode \"locale\"\n    MULTILINE = M = _compiler.SRE_FLAG_MULTILINE # make anchors look for newline\n    DOTALL = S = _compiler.SRE_FLAG_DOTALL # make dot match newline\n    VERBOSE = X = _compiler.SRE_FLAG_VERBOSE # ignore whitespace and comments\n    # sre extensions (experimental, don't rely on these)\n    TEMPLATE = T = _compiler.SRE_FLAG_TEMPLATE # unknown purpose, deprecated\n    DEBUG = _compiler.SRE_FLAG_DEBUG # dump pattern after compilation\n    __str__ = object.__str__\n    _numeric_repr_ = hex\n\n# sre exception\nerror = _compiler.error\n\n# --------------------------------------------------------------------\n# public interface\n\ndef match(pattern, string, flags=0):\n    \"\"\"Try to apply the pattern at the start of the string, returning\n    a Match object, or None if no match was found.\"\"\"\n    return _compile(pattern, flags).match(string)\n\ndef fullmatch(pattern, string, flags=0):\n    \"\"\"Try to apply the pattern to all of the string, returning\n    a Match object, or None if no match was found.\"\"\"\n    return _compile(pattern, flags).fullmatch(string)\n\ndef search(pattern, string, flags=0):\n    \"\"\"Scan through string looking for a match to the pattern, returning\n    a Match object, or None if no match was found.\"\"\"\n    return _compile(pattern, flags).search(string)\n\ndef sub(pattern, repl, string, count=0, flags=0):\n    \"\"\"Return the string obtained by replacing the leftmost\n    non-overlapping occurrences of the pattern in string by the\n    replacement repl.  repl can be either a string or a callable;\n    if a string, backslash escapes in it are processed.  If it is\n    a callable, it's passed the Match object and must return\n    a replacement string to be used.\"\"\"\n    return _compile(pattern, flags).sub(repl, string, count)\n\ndef subn(pattern, repl, string, count=0, flags=0):\n    \"\"\"Return a 2-tuple containing (new_string, number).\n    new_string is the string obtained by replacing the leftmost\n    non-overlapping occurrences of the pattern in the source\n    string by the replacement repl.  number is the number of\n    substitutions that were made. repl can be either a string or a\n    callable; if a string, backslash escapes in it are processed.\n    If it is a callable, it's passed the Match object and must\n    return a replacement string to be used.\"\"\"\n    return _compile(pattern, flags).subn(repl, string, count)\n\ndef split(pattern, string, maxsplit=0, flags=0):\n    \"\"\"Split the source string by the occurrences of the pattern,\n    returning a list containing the resulting substrings.  If\n    capturing parentheses are used in pattern, then the text of all\n    groups in the pattern are also returned as part of the resulting\n    list.  If maxsplit is nonzero, at most maxsplit splits occur,\n    and the remainder of the string is returned as the final element\n    of the list.\"\"\"\n    return _compile(pattern, flags).split(string, maxsplit)\n\ndef findall(pattern, string, flags=0):\n    \"\"\"Return a list of all non-overlapping matches in the string.\n\n    If one or more capturing groups are present in the pattern, return\n    a list of groups; this will be a list of tuples if the pattern\n    has more than one group.\n\n    Empty matches are included in the result.\"\"\"\n    return _compile(pattern, flags).findall(string)\n\ndef finditer(pattern, string, flags=0):\n    \"\"\"Return an iterator over all non-overlapping matches in the\n    string.  For each match, the iterator returns a Match object.\n\n    Empty matches are included in the result.\"\"\"\n    return _compile(pattern, flags).finditer(string)\n\ndef compile(pattern, flags=0):\n    \"Compile a regular expression pattern, returning a Pattern object.\"\n    return _compile(pattern, flags)\n\ndef purge():\n    \"Clear the regular expression caches\"\n    _cache.clear()\n    _compile_repl.cache_clear()\n\ndef template(pattern, flags=0):\n    \"Compile a template pattern, returning a Pattern object, deprecated\"\n    import warnings\n    warnings.warn(\"The re.template() function is deprecated \"\n                  \"as it is an undocumented function \"\n                  \"without an obvious purpose. \"\n                  \"Use re.compile() instead.\",\n                  DeprecationWarning)\n    with warnings.catch_warnings():\n        warnings.simplefilter(\"ignore\", DeprecationWarning)  # warn just once\n        return _compile(pattern, flags|T)\n\n# SPECIAL_CHARS\n# closing ')', '}' and ']'\n# '-' (a range in character set)\n# '&', '~', (extended character set operations)\n# '#' (comment) and WHITESPACE (ignored) in verbose mode\n_special_chars_map = {i: '\\\\' + chr(i) for i in b'()[]{}?*+-|^$\\\\.&~# \\t\\n\\r\\v\\f'}\n\ndef escape(pattern):\n    \"\"\"\n    Escape special characters in a string.\n    \"\"\"\n    if isinstance(pattern, str):\n        return pattern.translate(_special_chars_map)\n    else:\n        pattern = str(pattern, 'latin1')\n        return pattern.translate(_special_chars_map).encode('latin1')\n\nPattern = type(_compiler.compile('', 0))\nMatch = type(_compiler.compile('', 0).match(''))\n\n# --------------------------------------------------------------------\n# internals\n\n_cache = {}  # ordered!\n\n_MAXCACHE = 512\ndef _compile(pattern, flags):\n    # internal: compile pattern\n    if isinstance(flags, RegexFlag):\n        flags = flags.value\n    try:\n        return _cache[type(pattern), pattern, flags]\n    except KeyError:\n        pass\n    if isinstance(pattern, Pattern):\n        if flags:\n            raise ValueError(\n                \"cannot process flags argument with a compiled pattern\")\n        return pattern\n    if not _compiler.isstring(pattern):\n        raise TypeError(\"first argument must be string or compiled pattern\")\n    if flags & T:\n        import warnings\n        warnings.warn(\"The re.TEMPLATE/re.T flag is deprecated \"\n                  \"as it is an undocumented flag \"\n                  \"without an obvious purpose. \"\n                  \"Don't use it.\",\n                  DeprecationWarning)\n    p = _compiler.compile(pattern, flags)\n    if not (flags & DEBUG):\n        if len(_cache) >= _MAXCACHE:\n            # Drop the oldest item\n            try:\n                del _cache[next(iter(_cache))]\n            except (StopIteration, RuntimeError, KeyError):\n                pass\n        _cache[type(pattern), pattern, flags] = p\n    return p\n\n@functools.lru_cache(_MAXCACHE)\ndef _compile_repl(repl, pattern):\n    # internal: compile replacement pattern\n    return _parser.parse_template(repl, pattern)\n\ndef _expand(pattern, match, template):\n    # internal: Match.expand implementation hook\n    template = _parser.parse_template(template, pattern)\n    return _parser.expand_template(template, match)\n\ndef _subx(pattern, template):\n    # internal: Pattern.sub/subn implementation helper\n    template = _compile_repl(template, pattern)\n    if not template[0] and len(template[1]) == 1:\n        # literal replacement\n        return template[1][0]\n    def filter(match, template=template):\n        return _parser.expand_template(template, match)\n    return filter\n\n# register myself for pickling\n\nimport copyreg\n\ndef _pickle(p):\n    return _compile, (p.pattern, p.flags)\n\ncopyreg.pickle(Pattern, _pickle, _compile)\n\n# --------------------------------------------------------------------\n# experimental stuff (see python-dev discussions for details)\n\nclass Scanner:\n    def __init__(self, lexicon, flags=0):\n        from ._constants import BRANCH, SUBPATTERN\n        if isinstance(flags, RegexFlag):\n            flags = flags.value\n        self.lexicon = lexicon\n        # combine phrases into a compound pattern\n        p = []\n        s = _parser.State()\n        s.flags = flags\n        for phrase, action in lexicon:\n            gid = s.opengroup()\n            p.append(_parser.SubPattern(s, [\n                (SUBPATTERN, (gid, 0, 0, _parser.parse(phrase, flags))),\n                ]))\n            s.closegroup(gid, p[-1])\n        p = _parser.SubPattern(s, [(BRANCH, (None, p))])\n        self.scanner = _compiler.compile(p)\n    def scan(self, string):\n        result = []\n        append = result.append\n        match = self.scanner.scanner(string).match\n        i = 0\n        while True:\n            m = match()\n            if not m:\n                break\n            j = m.end()\n            if i == j:\n                break\n            action = self.lexicon[m.lastindex-1][1]\n            if callable(action):\n                self.match = m\n                action = action(self, m.group())\n            if action is not None:\n                append(action)\n            i = j\n        return result, string[i:]\n",374],"/home/ma-user/anaconda3/envs/py311/lib/python3.11/encodings/__init__.py":["\"\"\" Standard \"encodings\" Package\n\n    Standard Python encoding modules are stored in this package\n    directory.\n\n    Codec modules must have names corresponding to normalized encoding\n    names as defined in the normalize_encoding() function below, e.g.\n    'utf-8' must be implemented by the module 'utf_8.py'.\n\n    Each codec module must export the following interface:\n\n    * getregentry() -> codecs.CodecInfo object\n    The getregentry() API must return a CodecInfo object with encoder, decoder,\n    incrementalencoder, incrementaldecoder, streamwriter and streamreader\n    attributes which adhere to the Python Codec Interface Standard.\n\n    In addition, a module may optionally also define the following\n    APIs which are then used by the package's codec search function:\n\n    * getaliases() -> sequence of encoding name strings to use as aliases\n\n    Alias names returned by getaliases() must be normalized encoding\n    names as defined by normalize_encoding().\n\nWritten by Marc-Andre Lemburg (mal@lemburg.com).\n\n(c) Copyright CNRI, All Rights Reserved. NO WARRANTY.\n\n\"\"\"#\"\n\nimport codecs\nimport sys\nfrom . import aliases\n\n_cache = {}\n_unknown = '--unknown--'\n_import_tail = ['*']\n_aliases = aliases.aliases\n\nclass CodecRegistryError(LookupError, SystemError):\n    pass\n\ndef normalize_encoding(encoding):\n\n    \"\"\" Normalize an encoding name.\n\n        Normalization works as follows: all non-alphanumeric\n        characters except the dot used for Python package names are\n        collapsed and replaced with a single underscore, e.g. '  -;#'\n        becomes '_'. Leading and trailing underscores are removed.\n\n        Note that encoding names should be ASCII only.\n\n    \"\"\"\n    if isinstance(encoding, bytes):\n        encoding = str(encoding, \"ascii\")\n\n    chars = []\n    punct = False\n    for c in encoding:\n        if c.isalnum() or c == '.':\n            if punct and chars:\n                chars.append('_')\n            if c.isascii():\n                chars.append(c)\n            punct = False\n        else:\n            punct = True\n    return ''.join(chars)\n\ndef search_function(encoding):\n\n    # Cache lookup\n    entry = _cache.get(encoding, _unknown)\n    if entry is not _unknown:\n        return entry\n\n    # Import the module:\n    #\n    # First try to find an alias for the normalized encoding\n    # name and lookup the module using the aliased name, then try to\n    # lookup the module using the standard import scheme, i.e. first\n    # try in the encodings package, then at top-level.\n    #\n    norm_encoding = normalize_encoding(encoding)\n    aliased_encoding = _aliases.get(norm_encoding) or \\\n                       _aliases.get(norm_encoding.replace('.', '_'))\n    if aliased_encoding is not None:\n        modnames = [aliased_encoding,\n                    norm_encoding]\n    else:\n        modnames = [norm_encoding]\n    for modname in modnames:\n        if not modname or '.' in modname:\n            continue\n        try:\n            # Import is absolute to prevent the possibly malicious import of a\n            # module with side-effects that is not in the 'encodings' package.\n            mod = __import__('encodings.' + modname, fromlist=_import_tail,\n                             level=0)\n        except ImportError:\n            # ImportError may occur because 'encodings.(modname)' does not exist,\n            # or because it imports a name that does not exist (see mbcs and oem)\n            pass\n        else:\n            break\n    else:\n        mod = None\n\n    try:\n        getregentry = mod.getregentry\n    except AttributeError:\n        # Not a codec module\n        mod = None\n\n    if mod is None:\n        # Cache misses\n        _cache[encoding] = None\n        return None\n\n    # Now ask the module for the registry entry\n    entry = getregentry()\n    if not isinstance(entry, codecs.CodecInfo):\n        if not 4 <= len(entry) <= 7:\n            raise CodecRegistryError('module \"%s\" (%s) failed to register'\n                                     % (mod.__name__, mod.__file__))\n        if not callable(entry[0]) or not callable(entry[1]) or \\\n           (entry[2] is not None and not callable(entry[2])) or \\\n           (entry[3] is not None and not callable(entry[3])) or \\\n           (len(entry) > 4 and entry[4] is not None and not callable(entry[4])) or \\\n           (len(entry) > 5 and entry[5] is not None and not callable(entry[5])):\n            raise CodecRegistryError('incompatible codecs in module \"%s\" (%s)'\n                                     % (mod.__name__, mod.__file__))\n        if len(entry)<7 or entry[6] is None:\n            entry += (None,)*(6-len(entry)) + (mod.__name__.split(\".\", 1)[1],)\n        entry = codecs.CodecInfo(*entry)\n\n    # Cache the codec registry entry\n    _cache[encoding] = entry\n\n    # Register its aliases (without overwriting previously registered\n    # aliases)\n    try:\n        codecaliases = mod.getaliases()\n    except AttributeError:\n        pass\n    else:\n        for alias in codecaliases:\n            if alias not in _aliases:\n                _aliases[alias] = modname\n\n    # Return the registry entry\n    return entry\n\n# Register the search_function in the Python codec registry\ncodecs.register(search_function)\n\nif sys.platform == 'win32':\n    # bpo-671666, bpo-46668: If Python does not implement a codec for current\n    # Windows ANSI code page, use the \"mbcs\" codec instead:\n    # WideCharToMultiByte() and MultiByteToWideChar() functions with CP_ACP.\n    # Python does not support custom code pages.\n    def _alias_mbcs(encoding):\n        try:\n            import _winapi\n            ansi_code_page = \"cp%s\" % _winapi.GetACP()\n            if encoding == ansi_code_page:\n                import encodings.mbcs\n                return encodings.mbcs.getregentry()\n        except ImportError:\n            # Imports may fail while we are shutting down\n            pass\n\n    codecs.register(_alias_mbcs)\n",174],"/home/ma-user/anaconda3/envs/py311/lib/python3.11/locale.py":["\"\"\"Locale support module.\n\nThe module provides low-level access to the C lib's locale APIs and adds high\nlevel number formatting APIs as well as a locale aliasing engine to complement\nthese.\n\nThe aliasing engine includes support for many commonly used locale names and\nmaps them to values suitable for passing to the C lib's setlocale() function. It\nalso includes default encodings for all supported locale names.\n\n\"\"\"\n\nimport sys\nimport encodings\nimport encodings.aliases\nimport re\nimport _collections_abc\nfrom builtins import str as _builtin_str\nimport functools\n\n# Try importing the _locale module.\n#\n# If this fails, fall back on a basic 'C' locale emulation.\n\n# Yuck:  LC_MESSAGES is non-standard:  can't tell whether it exists before\n# trying the import.  So __all__ is also fiddled at the end of the file.\n__all__ = [\"getlocale\", \"getdefaultlocale\", \"getpreferredencoding\", \"Error\",\n           \"setlocale\", \"resetlocale\", \"localeconv\", \"strcoll\", \"strxfrm\",\n           \"str\", \"atof\", \"atoi\", \"format\", \"format_string\", \"currency\",\n           \"normalize\", \"LC_CTYPE\", \"LC_COLLATE\", \"LC_TIME\", \"LC_MONETARY\",\n           \"LC_NUMERIC\", \"LC_ALL\", \"CHAR_MAX\", \"getencoding\"]\n\ndef _strcoll(a,b):\n    \"\"\" strcoll(string,string) -> int.\n        Compares two strings according to the locale.\n    \"\"\"\n    return (a > b) - (a < b)\n\ndef _strxfrm(s):\n    \"\"\" strxfrm(string) -> string.\n        Returns a string that behaves for cmp locale-aware.\n    \"\"\"\n    return s\n\ntry:\n\n    from _locale import *\n\nexcept ImportError:\n\n    # Locale emulation\n\n    CHAR_MAX = 127\n    LC_ALL = 6\n    LC_COLLATE = 3\n    LC_CTYPE = 0\n    LC_MESSAGES = 5\n    LC_MONETARY = 4\n    LC_NUMERIC = 1\n    LC_TIME = 2\n    Error = ValueError\n\n    def localeconv():\n        \"\"\" localeconv() -> dict.\n            Returns numeric and monetary locale-specific parameters.\n        \"\"\"\n        # 'C' locale default values\n        return {'grouping': [127],\n                'currency_symbol': '',\n                'n_sign_posn': 127,\n                'p_cs_precedes': 127,\n                'n_cs_precedes': 127,\n                'mon_grouping': [],\n                'n_sep_by_space': 127,\n                'decimal_point': '.',\n                'negative_sign': '',\n                'positive_sign': '',\n                'p_sep_by_space': 127,\n                'int_curr_symbol': '',\n                'p_sign_posn': 127,\n                'thousands_sep': '',\n                'mon_thousands_sep': '',\n                'frac_digits': 127,\n                'mon_decimal_point': '',\n                'int_frac_digits': 127}\n\n    def setlocale(category, value=None):\n        \"\"\" setlocale(integer,string=None) -> string.\n            Activates/queries locale processing.\n        \"\"\"\n        if value not in (None, '', 'C'):\n            raise Error('_locale emulation only supports \"C\" locale')\n        return 'C'\n\n# These may or may not exist in _locale, so be sure to set them.\nif 'strxfrm' not in globals():\n    strxfrm = _strxfrm\nif 'strcoll' not in globals():\n    strcoll = _strcoll\n\n\n_localeconv = localeconv\n\n# With this dict, you can override some items of localeconv's return value.\n# This is useful for testing purposes.\n_override_localeconv = {}\n\n@functools.wraps(_localeconv)\ndef localeconv():\n    d = _localeconv()\n    if _override_localeconv:\n        d.update(_override_localeconv)\n    return d\n\n\n### Number formatting APIs\n\n# Author: Martin von Loewis\n# improved by Georg Brandl\n\n# Iterate over grouping intervals\ndef _grouping_intervals(grouping):\n    last_interval = None\n    for interval in grouping:\n        # if grouping is -1, we are done\n        if interval == CHAR_MAX:\n            return\n        # 0: re-use last group ad infinitum\n        if interval == 0:\n            if last_interval is None:\n                raise ValueError(\"invalid grouping\")\n            while True:\n                yield last_interval\n        yield interval\n        last_interval = interval\n\n#perform the grouping from right to left\ndef _group(s, monetary=False):\n    conv = localeconv()\n    thousands_sep = conv[monetary and 'mon_thousands_sep' or 'thousands_sep']\n    grouping = conv[monetary and 'mon_grouping' or 'grouping']\n    if not grouping:\n        return (s, 0)\n    if s[-1] == ' ':\n        stripped = s.rstrip()\n        right_spaces = s[len(stripped):]\n        s = stripped\n    else:\n        right_spaces = ''\n    left_spaces = ''\n    groups = []\n    for interval in _grouping_intervals(grouping):\n        if not s or s[-1] not in \"0123456789\":\n            # only non-digit characters remain (sign, spaces)\n            left_spaces = s\n            s = ''\n            break\n        groups.append(s[-interval:])\n        s = s[:-interval]\n    if s:\n        groups.append(s)\n    groups.reverse()\n    return (\n        left_spaces + thousands_sep.join(groups) + right_spaces,\n        len(thousands_sep) * (len(groups) - 1)\n    )\n\n# Strip a given amount of excess padding from the given string\ndef _strip_padding(s, amount):\n    lpos = 0\n    while amount and s[lpos] == ' ':\n        lpos += 1\n        amount -= 1\n    rpos = len(s) - 1\n    while amount and s[rpos] == ' ':\n        rpos -= 1\n        amount -= 1\n    return s[lpos:rpos+1]\n\n_percent_re = re.compile(r'%(?:\\((?P<key>.*?)\\))?'\n                         r'(?P<modifiers>[-#0-9 +*.hlL]*?)[eEfFgGdiouxXcrs%]')\n\ndef _format(percent, value, grouping=False, monetary=False, *additional):\n    if additional:\n        formatted = percent % ((value,) + additional)\n    else:\n        formatted = percent % value\n    if percent[-1] in 'eEfFgGdiu':\n        formatted = _localize(formatted, grouping, monetary)\n    return formatted\n\n# Transform formatted as locale number according to the locale settings\ndef _localize(formatted, grouping=False, monetary=False):\n    # floats and decimal ints need special action!\n    if '.' in formatted:\n        seps = 0\n        parts = formatted.split('.')\n        if grouping:\n            parts[0], seps = _group(parts[0], monetary=monetary)\n        decimal_point = localeconv()[monetary and 'mon_decimal_point'\n                                              or 'decimal_point']\n        formatted = decimal_point.join(parts)\n        if seps:\n            formatted = _strip_padding(formatted, seps)\n    else:\n        seps = 0\n        if grouping:\n            formatted, seps = _group(formatted, monetary=monetary)\n        if seps:\n            formatted = _strip_padding(formatted, seps)\n    return formatted\n\ndef format_string(f, val, grouping=False, monetary=False):\n    \"\"\"Formats a string in the same way that the % formatting would use,\n    but takes the current locale into account.\n\n    Grouping is applied if the third parameter is true.\n    Conversion uses monetary thousands separator and grouping strings if\n    forth parameter monetary is true.\"\"\"\n    percents = list(_percent_re.finditer(f))\n    new_f = _percent_re.sub('%s', f)\n\n    if isinstance(val, _collections_abc.Mapping):\n        new_val = []\n        for perc in percents:\n            if perc.group()[-1]=='%':\n                new_val.append('%')\n            else:\n                new_val.append(_format(perc.group(), val, grouping, monetary))\n    else:\n        if not isinstance(val, tuple):\n            val = (val,)\n        new_val = []\n        i = 0\n        for perc in percents:\n            if perc.group()[-1]=='%':\n                new_val.append('%')\n            else:\n                starcount = perc.group('modifiers').count('*')\n                new_val.append(_format(perc.group(),\n                                      val[i],\n                                      grouping,\n                                      monetary,\n                                      *val[i+1:i+1+starcount]))\n                i += (1 + starcount)\n    val = tuple(new_val)\n\n    return new_f % val\n\ndef format(percent, value, grouping=False, monetary=False, *additional):\n    \"\"\"Deprecated, use format_string instead.\"\"\"\n    import warnings\n    warnings.warn(\n        \"This method will be removed in a future version of Python. \"\n        \"Use 'locale.format_string()' instead.\",\n        DeprecationWarning, stacklevel=2\n    )\n\n    match = _percent_re.match(percent)\n    if not match or len(match.group())!= len(percent):\n        raise ValueError((\"format() must be given exactly one %%char \"\n                         \"format specifier, %s not valid\") % repr(percent))\n    return _format(percent, value, grouping, monetary, *additional)\n\ndef currency(val, symbol=True, grouping=False, international=False):\n    \"\"\"Formats val according to the currency settings\n    in the current locale.\"\"\"\n    conv = localeconv()\n\n    # check for illegal values\n    digits = conv[international and 'int_frac_digits' or 'frac_digits']\n    if digits == 127:\n        raise ValueError(\"Currency formatting is not possible using \"\n                         \"the 'C' locale.\")\n\n    s = _localize(f'{abs(val):.{digits}f}', grouping, monetary=True)\n    # '<' and '>' are markers if the sign must be inserted between symbol and value\n    s = '<' + s + '>'\n\n    if symbol:\n        smb = conv[international and 'int_curr_symbol' or 'currency_symbol']\n        precedes = conv[val<0 and 'n_cs_precedes' or 'p_cs_precedes']\n        separated = conv[val<0 and 'n_sep_by_space' or 'p_sep_by_space']\n\n        if precedes:\n            s = smb + (separated and ' ' or '') + s\n        else:\n            if international and smb[-1] == ' ':\n                smb = smb[:-1]\n            s = s + (separated and ' ' or '') + smb\n\n    sign_pos = conv[val<0 and 'n_sign_posn' or 'p_sign_posn']\n    sign = conv[val<0 and 'negative_sign' or 'positive_sign']\n\n    if sign_pos == 0:\n        s = '(' + s + ')'\n    elif sign_pos == 1:\n        s = sign + s\n    elif sign_pos == 2:\n        s = s + sign\n    elif sign_pos == 3:\n        s = s.replace('<', sign)\n    elif sign_pos == 4:\n        s = s.replace('>', sign)\n    else:\n        # the default if nothing specified;\n        # this should be the most fitting sign position\n        s = sign + s\n\n    return s.replace('<', '').replace('>', '')\n\ndef str(val):\n    \"\"\"Convert float to string, taking the locale into account.\"\"\"\n    return _format(\"%.12g\", val)\n\ndef delocalize(string):\n    \"Parses a string as a normalized number according to the locale settings.\"\n\n    conv = localeconv()\n\n    #First, get rid of the grouping\n    ts = conv['thousands_sep']\n    if ts:\n        string = string.replace(ts, '')\n\n    #next, replace the decimal point with a dot\n    dd = conv['decimal_point']\n    if dd:\n        string = string.replace(dd, '.')\n    return string\n\ndef localize(string, grouping=False, monetary=False):\n    \"\"\"Parses a string as locale number according to the locale settings.\"\"\"\n    return _localize(string, grouping, monetary)\n\ndef atof(string, func=float):\n    \"Parses a string as a float according to the locale settings.\"\n    return func(delocalize(string))\n\ndef atoi(string):\n    \"Converts a string to an integer according to the locale settings.\"\n    return int(delocalize(string))\n\ndef _test():\n    setlocale(LC_ALL, \"\")\n    #do grouping\n    s1 = format_string(\"%d\", 123456789,1)\n    print(s1, \"is\", atoi(s1))\n    #standard formatting\n    s1 = str(3.14)\n    print(s1, \"is\", atof(s1))\n\n### Locale name aliasing engine\n\n# Author: Marc-Andre Lemburg, mal@lemburg.com\n# Various tweaks by Fredrik Lundh <fredrik@pythonware.com>\n\n# store away the low-level version of setlocale (it's\n# overridden below)\n_setlocale = setlocale\n\ndef _replace_encoding(code, encoding):\n    if '.' in code:\n        langname = code[:code.index('.')]\n    else:\n        langname = code\n    # Convert the encoding to a C lib compatible encoding string\n    norm_encoding = encodings.normalize_encoding(encoding)\n    #print('norm encoding: %r' % norm_encoding)\n    norm_encoding = encodings.aliases.aliases.get(norm_encoding.lower(),\n                                                  norm_encoding)\n    #print('aliased encoding: %r' % norm_encoding)\n    encoding = norm_encoding\n    norm_encoding = norm_encoding.lower()\n    if norm_encoding in locale_encoding_alias:\n        encoding = locale_encoding_alias[norm_encoding]\n    else:\n        norm_encoding = norm_encoding.replace('_', '')\n        norm_encoding = norm_encoding.replace('-', '')\n        if norm_encoding in locale_encoding_alias:\n            encoding = locale_encoding_alias[norm_encoding]\n    #print('found encoding %r' % encoding)\n    return langname + '.' + encoding\n\ndef _append_modifier(code, modifier):\n    if modifier == 'euro':\n        if '.' not in code:\n            return code + '.ISO8859-15'\n        _, _, encoding = code.partition('.')\n        if encoding in ('ISO8859-15', 'UTF-8'):\n            return code\n        if encoding == 'ISO8859-1':\n            return _replace_encoding(code, 'ISO8859-15')\n    return code + '@' + modifier\n\ndef normalize(localename):\n\n    \"\"\" Returns a normalized locale code for the given locale\n        name.\n\n        The returned locale code is formatted for use with\n        setlocale().\n\n        If normalization fails, the original name is returned\n        unchanged.\n\n        If the given encoding is not known, the function defaults to\n        the default encoding for the locale code just like setlocale()\n        does.\n\n    \"\"\"\n    # Normalize the locale name and extract the encoding and modifier\n    code = localename.lower()\n    if ':' in code:\n        # ':' is sometimes used as encoding delimiter.\n        code = code.replace(':', '.')\n    if '@' in code:\n        code, modifier = code.split('@', 1)\n    else:\n        modifier = ''\n    if '.' in code:\n        langname, encoding = code.split('.')[:2]\n    else:\n        langname = code\n        encoding = ''\n\n    # First lookup: fullname (possibly with encoding and modifier)\n    lang_enc = langname\n    if encoding:\n        norm_encoding = encoding.replace('-', '')\n        norm_encoding = norm_encoding.replace('_', '')\n        lang_enc += '.' + norm_encoding\n    lookup_name = lang_enc\n    if modifier:\n        lookup_name += '@' + modifier\n    code = locale_alias.get(lookup_name, None)\n    if code is not None:\n        return code\n    #print('first lookup failed')\n\n    if modifier:\n        # Second try: fullname without modifier (possibly with encoding)\n        code = locale_alias.get(lang_enc, None)\n        if code is not None:\n            #print('lookup without modifier succeeded')\n            if '@' not in code:\n                return _append_modifier(code, modifier)\n            if code.split('@', 1)[1].lower() == modifier:\n                return code\n        #print('second lookup failed')\n\n    if encoding:\n        # Third try: langname (without encoding, possibly with modifier)\n        lookup_name = langname\n        if modifier:\n            lookup_name += '@' + modifier\n        code = locale_alias.get(lookup_name, None)\n        if code is not None:\n            #print('lookup without encoding succeeded')\n            if '@' not in code:\n                return _replace_encoding(code, encoding)\n            code, modifier = code.split('@', 1)\n            return _replace_encoding(code, encoding) + '@' + modifier\n\n        if modifier:\n            # Fourth try: langname (without encoding and modifier)\n            code = locale_alias.get(langname, None)\n            if code is not None:\n                #print('lookup without modifier and encoding succeeded')\n                if '@' not in code:\n                    code = _replace_encoding(code, encoding)\n                    return _append_modifier(code, modifier)\n                code, defmod = code.split('@', 1)\n                if defmod.lower() == modifier:\n                    return _replace_encoding(code, encoding) + '@' + defmod\n\n    return localename\n\ndef _parse_localename(localename):\n\n    \"\"\" Parses the locale code for localename and returns the\n        result as tuple (language code, encoding).\n\n        The localename is normalized and passed through the locale\n        alias engine. A ValueError is raised in case the locale name\n        cannot be parsed.\n\n        The language code corresponds to RFC 1766.  code and encoding\n        can be None in case the values cannot be determined or are\n        unknown to this implementation.\n\n    \"\"\"\n    code = normalize(localename)\n    if '@' in code:\n        # Deal with locale modifiers\n        code, modifier = code.split('@', 1)\n        if modifier == 'euro' and '.' not in code:\n            # Assume Latin-9 for @euro locales. This is bogus,\n            # since some systems may use other encodings for these\n            # locales. Also, we ignore other modifiers.\n            return code, 'iso-8859-15'\n\n    if '.' in code:\n        return tuple(code.split('.')[:2])\n    elif code == 'C':\n        return None, None\n    elif code == 'UTF-8':\n        # On macOS \"LC_CTYPE=UTF-8\" is a valid locale setting\n        # for getting UTF-8 handling for text.\n        return None, 'UTF-8'\n    raise ValueError('unknown locale: %s' % localename)\n\ndef _build_localename(localetuple):\n\n    \"\"\" Builds a locale code from the given tuple (language code,\n        encoding).\n\n        No aliasing or normalizing takes place.\n\n    \"\"\"\n    try:\n        language, encoding = localetuple\n\n        if language is None:\n            language = 'C'\n        if encoding is None:\n            return language\n        else:\n            return language + '.' + encoding\n    except (TypeError, ValueError):\n        raise TypeError('Locale must be None, a string, or an iterable of '\n                        'two strings -- language code, encoding.') from None\n\ndef getdefaultlocale(envvars=('LC_ALL', 'LC_CTYPE', 'LANG', 'LANGUAGE')):\n\n    \"\"\" Tries to determine the default locale settings and returns\n        them as tuple (language code, encoding).\n\n        According to POSIX, a program which has not called\n        setlocale(LC_ALL, \"\") runs using the portable 'C' locale.\n        Calling setlocale(LC_ALL, \"\") lets it use the default locale as\n        defined by the LANG variable. Since we don't want to interfere\n        with the current locale setting we thus emulate the behavior\n        in the way described above.\n\n        To maintain compatibility with other platforms, not only the\n        LANG variable is tested, but a list of variables given as\n        envvars parameter. The first found to be defined will be\n        used. envvars defaults to the search path used in GNU gettext;\n        it must always contain the variable name 'LANG'.\n\n        Except for the code 'C', the language code corresponds to RFC\n        1766.  code and encoding can be None in case the values cannot\n        be determined.\n\n    \"\"\"\n\n    import warnings\n    warnings.warn(\n        \"Use setlocale(), getencoding() and getlocale() instead\",\n        DeprecationWarning, stacklevel=2\n    )\n\n    try:\n        # check if it's supported by the _locale module\n        import _locale\n        code, encoding = _locale._getdefaultlocale()\n    except (ImportError, AttributeError):\n        pass\n    else:\n        # make sure the code/encoding values are valid\n        if sys.platform == \"win32\" and code and code[:2] == \"0x\":\n            # map windows language identifier to language name\n            code = windows_locale.get(int(code, 0))\n        # ...add other platform-specific processing here, if\n        # necessary...\n        return code, encoding\n\n    # fall back on POSIX behaviour\n    import os\n    lookup = os.environ.get\n    for variable in envvars:\n        localename = lookup(variable,None)\n        if localename:\n            if variable == 'LANGUAGE':\n                localename = localename.split(':')[0]\n            break\n    else:\n        localename = 'C'\n    return _parse_localename(localename)\n\n\ndef getlocale(category=LC_CTYPE):\n\n    \"\"\" Returns the current setting for the given locale category as\n        tuple (language code, encoding).\n\n        category may be one of the LC_* value except LC_ALL. It\n        defaults to LC_CTYPE.\n\n        Except for the code 'C', the language code corresponds to RFC\n        1766.  code and encoding can be None in case the values cannot\n        be determined.\n\n    \"\"\"\n    localename = _setlocale(category)\n    if category == LC_ALL and ';' in localename:\n        raise TypeError('category LC_ALL is not supported')\n    return _parse_localename(localename)\n\ndef setlocale(category, locale=None):\n\n    \"\"\" Set the locale for the given category.  The locale can be\n        a string, an iterable of two strings (language code and encoding),\n        or None.\n\n        Iterables are converted to strings using the locale aliasing\n        engine.  Locale strings are passed directly to the C lib.\n\n        category may be given as one of the LC_* values.\n\n    \"\"\"\n    if locale and not isinstance(locale, _builtin_str):\n        # convert to string\n        locale = normalize(_build_localename(locale))\n    return _setlocale(category, locale)\n\ndef resetlocale(category=LC_ALL):\n\n    \"\"\" Sets the locale for category to the default setting.\n\n        The default setting is determined by calling\n        getdefaultlocale(). category defaults to LC_ALL.\n\n    \"\"\"\n    import warnings\n    warnings.warn(\n        'Use locale.setlocale(locale.LC_ALL, \"\") instead',\n        DeprecationWarning, stacklevel=2\n    )\n\n    with warnings.catch_warnings():\n        warnings.simplefilter('ignore', category=DeprecationWarning)\n        loc = getdefaultlocale()\n\n    _setlocale(category, _build_localename(loc))\n\n\ntry:\n    from _locale import getencoding\nexcept ImportError:\n    def getencoding():\n        if hasattr(sys, 'getandroidapilevel'):\n            # On Android langinfo.h and CODESET are missing, and UTF-8 is\n            # always used in mbstowcs() and wcstombs().\n            return 'utf-8'\n        encoding = getdefaultlocale()[1]\n        if encoding is None:\n            # LANG not set, default to UTF-8\n            encoding = 'utf-8'\n        return encoding\n\ntry:\n    CODESET\nexcept NameError:\n    def getpreferredencoding(do_setlocale=True):\n        \"\"\"Return the charset that the user is likely using.\"\"\"\n        if sys.flags.warn_default_encoding:\n            import warnings\n            warnings.warn(\n                \"UTF-8 Mode affects locale.getpreferredencoding(). Consider locale.getencoding() instead.\",\n                EncodingWarning, 2)\n        if sys.flags.utf8_mode:\n            return 'utf-8'\n        return getencoding()\nelse:\n    # On Unix, if CODESET is available, use that.\n    def getpreferredencoding(do_setlocale=True):\n        \"\"\"Return the charset that the user is likely using,\n        according to the system configuration.\"\"\"\n\n        if sys.flags.warn_default_encoding:\n            import warnings\n            warnings.warn(\n                \"UTF-8 Mode affects locale.getpreferredencoding(). Consider locale.getencoding() instead.\",\n                EncodingWarning, 2)\n        if sys.flags.utf8_mode:\n            return 'utf-8'\n\n        if not do_setlocale:\n            return getencoding()\n\n        old_loc = setlocale(LC_CTYPE)\n        try:\n            try:\n                setlocale(LC_CTYPE, \"\")\n            except Error:\n                pass\n            return getencoding()\n        finally:\n            setlocale(LC_CTYPE, old_loc)\n\n\n### Database\n#\n# The following data was extracted from the locale.alias file which\n# comes with X11 and then hand edited removing the explicit encoding\n# definitions and adding some more aliases. The file is usually\n# available as /usr/lib/X11/locale/locale.alias.\n#\n\n#\n# The local_encoding_alias table maps lowercase encoding alias names\n# to C locale encoding names (case-sensitive). Note that normalize()\n# first looks up the encoding in the encodings.aliases dictionary and\n# then applies this mapping to find the correct C lib name for the\n# encoding.\n#\nlocale_encoding_alias = {\n\n    # Mappings for non-standard encoding names used in locale names\n    '437':                          'C',\n    'c':                            'C',\n    'en':                           'ISO8859-1',\n    'jis':                          'JIS7',\n    'jis7':                         'JIS7',\n    'ajec':                         'eucJP',\n    'koi8c':                        'KOI8-C',\n    'microsoftcp1251':              'CP1251',\n    'microsoftcp1255':              'CP1255',\n    'microsoftcp1256':              'CP1256',\n    '88591':                        'ISO8859-1',\n    '88592':                        'ISO8859-2',\n    '88595':                        'ISO8859-5',\n    '885915':                       'ISO8859-15',\n\n    # Mappings from Python codec names to C lib encoding names\n    'ascii':                        'ISO8859-1',\n    'latin_1':                      'ISO8859-1',\n    'iso8859_1':                    'ISO8859-1',\n    'iso8859_10':                   'ISO8859-10',\n    'iso8859_11':                   'ISO8859-11',\n    'iso8859_13':                   'ISO8859-13',\n    'iso8859_14':                   'ISO8859-14',\n    'iso8859_15':                   'ISO8859-15',\n    'iso8859_16':                   'ISO8859-16',\n    'iso8859_2':                    'ISO8859-2',\n    'iso8859_3':                    'ISO8859-3',\n    'iso8859_4':                    'ISO8859-4',\n    'iso8859_5':                    'ISO8859-5',\n    'iso8859_6':                    'ISO8859-6',\n    'iso8859_7':                    'ISO8859-7',\n    'iso8859_8':                    'ISO8859-8',\n    'iso8859_9':                    'ISO8859-9',\n    'iso2022_jp':                   'JIS7',\n    'shift_jis':                    'SJIS',\n    'tactis':                       'TACTIS',\n    'euc_jp':                       'eucJP',\n    'euc_kr':                       'eucKR',\n    'utf_8':                        'UTF-8',\n    'koi8_r':                       'KOI8-R',\n    'koi8_t':                       'KOI8-T',\n    'koi8_u':                       'KOI8-U',\n    'kz1048':                       'RK1048',\n    'cp1251':                       'CP1251',\n    'cp1255':                       'CP1255',\n    'cp1256':                       'CP1256',\n\n    # XXX This list is still incomplete. If you know more\n    # mappings, please file a bug report. Thanks.\n}\n\nfor k, v in sorted(locale_encoding_alias.items()):\n    k = k.replace('_', '')\n    locale_encoding_alias.setdefault(k, v)\ndel k, v\n\n#\n# The locale_alias table maps lowercase alias names to C locale names\n# (case-sensitive). Encodings are always separated from the locale\n# name using a dot ('.'); they should only be given in case the\n# language name is needed to interpret the given encoding alias\n# correctly (CJK codes often have this need).\n#\n# Note that the normalize() function which uses this tables\n# removes '_' and '-' characters from the encoding part of the\n# locale name before doing the lookup. This saves a lot of\n# space in the table.\n#\n# MAL 2004-12-10:\n# Updated alias mapping to most recent locale.alias file\n# from X.org distribution using makelocalealias.py.\n#\n# These are the differences compared to the old mapping (Python 2.4\n# and older):\n#\n#    updated 'bg' -> 'bg_BG.ISO8859-5' to 'bg_BG.CP1251'\n#    updated 'bg_bg' -> 'bg_BG.ISO8859-5' to 'bg_BG.CP1251'\n#    updated 'bulgarian' -> 'bg_BG.ISO8859-5' to 'bg_BG.CP1251'\n#    updated 'cz' -> 'cz_CZ.ISO8859-2' to 'cs_CZ.ISO8859-2'\n#    updated 'cz_cz' -> 'cz_CZ.ISO8859-2' to 'cs_CZ.ISO8859-2'\n#    updated 'czech' -> 'cs_CS.ISO8859-2' to 'cs_CZ.ISO8859-2'\n#    updated 'dutch' -> 'nl_BE.ISO8859-1' to 'nl_NL.ISO8859-1'\n#    updated 'et' -> 'et_EE.ISO8859-4' to 'et_EE.ISO8859-15'\n#    updated 'et_ee' -> 'et_EE.ISO8859-4' to 'et_EE.ISO8859-15'\n#    updated 'fi' -> 'fi_FI.ISO8859-1' to 'fi_FI.ISO8859-15'\n#    updated 'fi_fi' -> 'fi_FI.ISO8859-1' to 'fi_FI.ISO8859-15'\n#    updated 'iw' -> 'iw_IL.ISO8859-8' to 'he_IL.ISO8859-8'\n#    updated 'iw_il' -> 'iw_IL.ISO8859-8' to 'he_IL.ISO8859-8'\n#    updated 'japanese' -> 'ja_JP.SJIS' to 'ja_JP.eucJP'\n#    updated 'lt' -> 'lt_LT.ISO8859-4' to 'lt_LT.ISO8859-13'\n#    updated 'lv' -> 'lv_LV.ISO8859-4' to 'lv_LV.ISO8859-13'\n#    updated 'sl' -> 'sl_CS.ISO8859-2' to 'sl_SI.ISO8859-2'\n#    updated 'slovene' -> 'sl_CS.ISO8859-2' to 'sl_SI.ISO8859-2'\n#    updated 'th_th' -> 'th_TH.TACTIS' to 'th_TH.ISO8859-11'\n#    updated 'zh_cn' -> 'zh_CN.eucCN' to 'zh_CN.gb2312'\n#    updated 'zh_cn.big5' -> 'zh_TW.eucTW' to 'zh_TW.big5'\n#    updated 'zh_tw' -> 'zh_TW.eucTW' to 'zh_TW.big5'\n#\n# MAL 2008-05-30:\n# Updated alias mapping to most recent locale.alias file\n# from X.org distribution using makelocalealias.py.\n#\n# These are the differences compared to the old mapping (Python 2.5\n# and older):\n#\n#    updated 'cs_cs.iso88592' -> 'cs_CZ.ISO8859-2' to 'cs_CS.ISO8859-2'\n#    updated 'serbocroatian' -> 'sh_YU.ISO8859-2' to 'sr_CS.ISO8859-2'\n#    updated 'sh' -> 'sh_YU.ISO8859-2' to 'sr_CS.ISO8859-2'\n#    updated 'sh_hr.iso88592' -> 'sh_HR.ISO8859-2' to 'hr_HR.ISO8859-2'\n#    updated 'sh_sp' -> 'sh_YU.ISO8859-2' to 'sr_CS.ISO8859-2'\n#    updated 'sh_yu' -> 'sh_YU.ISO8859-2' to 'sr_CS.ISO8859-2'\n#    updated 'sp' -> 'sp_YU.ISO8859-5' to 'sr_CS.ISO8859-5'\n#    updated 'sp_yu' -> 'sp_YU.ISO8859-5' to 'sr_CS.ISO8859-5'\n#    updated 'sr' -> 'sr_YU.ISO8859-5' to 'sr_CS.ISO8859-5'\n#    updated 'sr@cyrillic' -> 'sr_YU.ISO8859-5' to 'sr_CS.ISO8859-5'\n#    updated 'sr_sp' -> 'sr_SP.ISO8859-2' to 'sr_CS.ISO8859-2'\n#    updated 'sr_yu' -> 'sr_YU.ISO8859-5' to 'sr_CS.ISO8859-5'\n#    updated 'sr_yu.cp1251@cyrillic' -> 'sr_YU.CP1251' to 'sr_CS.CP1251'\n#    updated 'sr_yu.iso88592' -> 'sr_YU.ISO8859-2' to 'sr_CS.ISO8859-2'\n#    updated 'sr_yu.iso88595' -> 'sr_YU.ISO8859-5' to 'sr_CS.ISO8859-5'\n#    updated 'sr_yu.iso88595@cyrillic' -> 'sr_YU.ISO8859-5' to 'sr_CS.ISO8859-5'\n#    updated 'sr_yu.microsoftcp1251@cyrillic' -> 'sr_YU.CP1251' to 'sr_CS.CP1251'\n#    updated 'sr_yu.utf8@cyrillic' -> 'sr_YU.UTF-8' to 'sr_CS.UTF-8'\n#    updated 'sr_yu@cyrillic' -> 'sr_YU.ISO8859-5' to 'sr_CS.ISO8859-5'\n#\n# AP 2010-04-12:\n# Updated alias mapping to most recent locale.alias file\n# from X.org distribution using makelocalealias.py.\n#\n# These are the differences compared to the old mapping (Python 2.6.5\n# and older):\n#\n#    updated 'ru' -> 'ru_RU.ISO8859-5' to 'ru_RU.UTF-8'\n#    updated 'ru_ru' -> 'ru_RU.ISO8859-5' to 'ru_RU.UTF-8'\n#    updated 'serbocroatian' -> 'sr_CS.ISO8859-2' to 'sr_RS.UTF-8@latin'\n#    updated 'sh' -> 'sr_CS.ISO8859-2' to 'sr_RS.UTF-8@latin'\n#    updated 'sh_yu' -> 'sr_CS.ISO8859-2' to 'sr_RS.UTF-8@latin'\n#    updated 'sr' -> 'sr_CS.ISO8859-5' to 'sr_RS.UTF-8'\n#    updated 'sr@cyrillic' -> 'sr_CS.ISO8859-5' to 'sr_RS.UTF-8'\n#    updated 'sr@latn' -> 'sr_CS.ISO8859-2' to 'sr_RS.UTF-8@latin'\n#    updated 'sr_cs.utf8@latn' -> 'sr_CS.UTF-8' to 'sr_RS.UTF-8@latin'\n#    updated 'sr_cs@latn' -> 'sr_CS.ISO8859-2' to 'sr_RS.UTF-8@latin'\n#    updated 'sr_yu' -> 'sr_CS.ISO8859-5' to 'sr_RS.UTF-8@latin'\n#    updated 'sr_yu.utf8@cyrillic' -> 'sr_CS.UTF-8' to 'sr_RS.UTF-8'\n#    updated 'sr_yu@cyrillic' -> 'sr_CS.ISO8859-5' to 'sr_RS.UTF-8'\n#\n# SS 2013-12-20:\n# Updated alias mapping to most recent locale.alias file\n# from X.org distribution using makelocalealias.py.\n#\n# These are the differences compared to the old mapping (Python 3.3.3\n# and older):\n#\n#    updated 'a3' -> 'a3_AZ.KOI8-C' to 'az_AZ.KOI8-C'\n#    updated 'a3_az' -> 'a3_AZ.KOI8-C' to 'az_AZ.KOI8-C'\n#    updated 'a3_az.koi8c' -> 'a3_AZ.KOI8-C' to 'az_AZ.KOI8-C'\n#    updated 'cs_cs.iso88592' -> 'cs_CS.ISO8859-2' to 'cs_CZ.ISO8859-2'\n#    updated 'hebrew' -> 'iw_IL.ISO8859-8' to 'he_IL.ISO8859-8'\n#    updated 'hebrew.iso88598' -> 'iw_IL.ISO8859-8' to 'he_IL.ISO8859-8'\n#    updated 'sd' -> 'sd_IN@devanagari.UTF-8' to 'sd_IN.UTF-8'\n#    updated 'sr@latn' -> 'sr_RS.UTF-8@latin' to 'sr_CS.UTF-8@latin'\n#    updated 'sr_cs' -> 'sr_RS.UTF-8' to 'sr_CS.UTF-8'\n#    updated 'sr_cs.utf8@latn' -> 'sr_RS.UTF-8@latin' to 'sr_CS.UTF-8@latin'\n#    updated 'sr_cs@latn' -> 'sr_RS.UTF-8@latin' to 'sr_CS.UTF-8@latin'\n#\n# SS 2014-10-01:\n# Updated alias mapping with glibc 2.19 supported locales.\n#\n# SS 2018-05-05:\n# Updated alias mapping with glibc 2.27 supported locales.\n#\n# These are the differences compared to the old mapping (Python 3.6.5\n# and older):\n#\n#    updated 'ca_es@valencia' -> 'ca_ES.ISO8859-15@valencia' to 'ca_ES.UTF-8@valencia'\n#    updated 'kk_kz' -> 'kk_KZ.RK1048' to 'kk_KZ.ptcp154'\n#    updated 'russian' -> 'ru_RU.ISO8859-5' to 'ru_RU.KOI8-R'\n\nlocale_alias = {\n    'a3':                                   'az_AZ.KOI8-C',\n    'a3_az':                                'az_AZ.KOI8-C',\n    'a3_az.koic':                           'az_AZ.KOI8-C',\n    'aa_dj':                                'aa_DJ.ISO8859-1',\n    'aa_er':                                'aa_ER.UTF-8',\n    'aa_et':                                'aa_ET.UTF-8',\n    'af':                                   'af_ZA.ISO8859-1',\n    'af_za':                                'af_ZA.ISO8859-1',\n    'agr_pe':                               'agr_PE.UTF-8',\n    'ak_gh':                                'ak_GH.UTF-8',\n    'am':                                   'am_ET.UTF-8',\n    'am_et':                                'am_ET.UTF-8',\n    'american':                             'en_US.ISO8859-1',\n    'an_es':                                'an_ES.ISO8859-15',\n    'anp_in':                               'anp_IN.UTF-8',\n    'ar':                                   'ar_AA.ISO8859-6',\n    'ar_aa':                                'ar_AA.ISO8859-6',\n    'ar_ae':                                'ar_AE.ISO8859-6',\n    'ar_bh':                                'ar_BH.ISO8859-6',\n    'ar_dz':                                'ar_DZ.ISO8859-6',\n    'ar_eg':                                'ar_EG.ISO8859-6',\n    'ar_in':                                'ar_IN.UTF-8',\n    'ar_iq':                                'ar_IQ.ISO8859-6',\n    'ar_jo':                                'ar_JO.ISO8859-6',\n    'ar_kw':                                'ar_KW.ISO8859-6',\n    'ar_lb':                                'ar_LB.ISO8859-6',\n    'ar_ly':                                'ar_LY.ISO8859-6',\n    'ar_ma':                                'ar_MA.ISO8859-6',\n    'ar_om':                                'ar_OM.ISO8859-6',\n    'ar_qa':                                'ar_QA.ISO8859-6',\n    'ar_sa':                                'ar_SA.ISO8859-6',\n    'ar_sd':                                'ar_SD.ISO8859-6',\n    'ar_ss':                                'ar_SS.UTF-8',\n    'ar_sy':                                'ar_SY.ISO8859-6',\n    'ar_tn':                                'ar_TN.ISO8859-6',\n    'ar_ye':                                'ar_YE.ISO8859-6',\n    'arabic':                               'ar_AA.ISO8859-6',\n    'as':                                   'as_IN.UTF-8',\n    'as_in':                                'as_IN.UTF-8',\n    'ast_es':                               'ast_ES.ISO8859-15',\n    'ayc_pe':                               'ayc_PE.UTF-8',\n    'az':                                   'az_AZ.ISO8859-9E',\n    'az_az':                                'az_AZ.ISO8859-9E',\n    'az_az.iso88599e':                      'az_AZ.ISO8859-9E',\n    'az_ir':                                'az_IR.UTF-8',\n    'be':                                   'be_BY.CP1251',\n    'be@latin':                             'be_BY.UTF-8@latin',\n    'be_bg.utf8':                           'bg_BG.UTF-8',\n    'be_by':                                'be_BY.CP1251',\n    'be_by@latin':                          'be_BY.UTF-8@latin',\n    'bem_zm':                               'bem_ZM.UTF-8',\n    'ber_dz':                               'ber_DZ.UTF-8',\n    'ber_ma':                               'ber_MA.UTF-8',\n    'bg':                                   'bg_BG.CP1251',\n    'bg_bg':                                'bg_BG.CP1251',\n    'bhb_in.utf8':                          'bhb_IN.UTF-8',\n    'bho_in':                               'bho_IN.UTF-8',\n    'bho_np':                               'bho_NP.UTF-8',\n    'bi_vu':                                'bi_VU.UTF-8',\n    'bn_bd':                                'bn_BD.UTF-8',\n    'bn_in':                                'bn_IN.UTF-8',\n    'bo_cn':                                'bo_CN.UTF-8',\n    'bo_in':                                'bo_IN.UTF-8',\n    'bokmal':                               'nb_NO.ISO8859-1',\n    'bokm\\xe5l':                            'nb_NO.ISO8859-1',\n    'br':                                   'br_FR.ISO8859-1',\n    'br_fr':                                'br_FR.ISO8859-1',\n    'brx_in':                               'brx_IN.UTF-8',\n    'bs':                                   'bs_BA.ISO8859-2',\n    'bs_ba':                                'bs_BA.ISO8859-2',\n    'bulgarian':                            'bg_BG.CP1251',\n    'byn_er':                               'byn_ER.UTF-8',\n    'c':                                    'C',\n    'c-french':                             'fr_CA.ISO8859-1',\n    'c.ascii':                              'C',\n    'c.en':                                 'C',\n    'c.iso88591':                           'en_US.ISO8859-1',\n    'c.utf8':                               'en_US.UTF-8',\n    'c_c':                                  'C',\n    'c_c.c':                                'C',\n    'ca':                                   'ca_ES.ISO8859-1',\n    'ca_ad':                                'ca_AD.ISO8859-1',\n    'ca_es':                                'ca_ES.ISO8859-1',\n    'ca_es@valencia':                       'ca_ES.UTF-8@valencia',\n    'ca_fr':                                'ca_FR.ISO8859-1',\n    'ca_it':                                'ca_IT.ISO8859-1',\n    'catalan':                              'ca_ES.ISO8859-1',\n    'ce_ru':                                'ce_RU.UTF-8',\n    'cextend':                              'en_US.ISO8859-1',\n    'chinese-s':                            'zh_CN.eucCN',\n    'chinese-t':                            'zh_TW.eucTW',\n    'chr_us':                               'chr_US.UTF-8',\n    'ckb_iq':                               'ckb_IQ.UTF-8',\n    'cmn_tw':                               'cmn_TW.UTF-8',\n    'crh_ua':                               'crh_UA.UTF-8',\n    'croatian':                             'hr_HR.ISO8859-2',\n    'cs':                                   'cs_CZ.ISO8859-2',\n    'cs_cs':                                'cs_CZ.ISO8859-2',\n    'cs_cz':                                'cs_CZ.ISO8859-2',\n    'csb_pl':                               'csb_PL.UTF-8',\n    'cv_ru':                                'cv_RU.UTF-8',\n    'cy':                                   'cy_GB.ISO8859-1',\n    'cy_gb':                                'cy_GB.ISO8859-1',\n    'cz':                                   'cs_CZ.ISO8859-2',\n    'cz_cz':                                'cs_CZ.ISO8859-2',\n    'czech':                                'cs_CZ.ISO8859-2',\n    'da':                                   'da_DK.ISO8859-1',\n    'da_dk':                                'da_DK.ISO8859-1',\n    'danish':                               'da_DK.ISO8859-1',\n    'dansk':                                'da_DK.ISO8859-1',\n    'de':                                   'de_DE.ISO8859-1',\n    'de_at':                                'de_AT.ISO8859-1',\n    'de_be':                                'de_BE.ISO8859-1',\n    'de_ch':                                'de_CH.ISO8859-1',\n    'de_de':                                'de_DE.ISO8859-1',\n    'de_it':                                'de_IT.ISO8859-1',\n    'de_li.utf8':                           'de_LI.UTF-8',\n    'de_lu':                                'de_LU.ISO8859-1',\n    'deutsch':                              'de_DE.ISO8859-1',\n    'doi_in':                               'doi_IN.UTF-8',\n    'dutch':                                'nl_NL.ISO8859-1',\n    'dutch.iso88591':                       'nl_BE.ISO8859-1',\n    'dv_mv':                                'dv_MV.UTF-8',\n    'dz_bt':                                'dz_BT.UTF-8',\n    'ee':                                   'ee_EE.ISO8859-4',\n    'ee_ee':                                'ee_EE.ISO8859-4',\n    'eesti':                                'et_EE.ISO8859-1',\n    'el':                                   'el_GR.ISO8859-7',\n    'el_cy':                                'el_CY.ISO8859-7',\n    'el_gr':                                'el_GR.ISO8859-7',\n    'el_gr@euro':                           'el_GR.ISO8859-15',\n    'en':                                   'en_US.ISO8859-1',\n    'en_ag':                                'en_AG.UTF-8',\n    'en_au':                                'en_AU.ISO8859-1',\n    'en_be':                                'en_BE.ISO8859-1',\n    'en_bw':                                'en_BW.ISO8859-1',\n    'en_ca':                                'en_CA.ISO8859-1',\n    'en_dk':                                'en_DK.ISO8859-1',\n    'en_dl.utf8':                           'en_DL.UTF-8',\n    'en_gb':                                'en_GB.ISO8859-1',\n    'en_hk':                                'en_HK.ISO8859-1',\n    'en_ie':                                'en_IE.ISO8859-1',\n    'en_il':                                'en_IL.UTF-8',\n    'en_in':                                'en_IN.ISO8859-1',\n    'en_ng':                                'en_NG.UTF-8',\n    'en_nz':                                'en_NZ.ISO8859-1',\n    'en_ph':                                'en_PH.ISO8859-1',\n    'en_sc.utf8':                           'en_SC.UTF-8',\n    'en_sg':                                'en_SG.ISO8859-1',\n    'en_uk':                                'en_GB.ISO8859-1',\n    'en_us':                                'en_US.ISO8859-1',\n    'en_us@euro@euro':                      'en_US.ISO8859-15',\n    'en_za':                                'en_ZA.ISO8859-1',\n    'en_zm':                                'en_ZM.UTF-8',\n    'en_zw':                                'en_ZW.ISO8859-1',\n    'en_zw.utf8':                           'en_ZS.UTF-8',\n    'eng_gb':                               'en_GB.ISO8859-1',\n    'english':                              'en_EN.ISO8859-1',\n    'english.iso88591':                     'en_US.ISO8859-1',\n    'english_uk':                           'en_GB.ISO8859-1',\n    'english_united-states':                'en_US.ISO8859-1',\n    'english_united-states.437':            'C',\n    'english_us':                           'en_US.ISO8859-1',\n    'eo':                                   'eo_XX.ISO8859-3',\n    'eo.utf8':                              'eo.UTF-8',\n    'eo_eo':                                'eo_EO.ISO8859-3',\n    'eo_us.utf8':                           'eo_US.UTF-8',\n    'eo_xx':                                'eo_XX.ISO8859-3',\n    'es':                                   'es_ES.ISO8859-1',\n    'es_ar':                                'es_AR.ISO8859-1',\n    'es_bo':                                'es_BO.ISO8859-1',\n    'es_cl':                                'es_CL.ISO8859-1',\n    'es_co':                                'es_CO.ISO8859-1',\n    'es_cr':                                'es_CR.ISO8859-1',\n    'es_cu':                                'es_CU.UTF-8',\n    'es_do':                                'es_DO.ISO8859-1',\n    'es_ec':                                'es_EC.ISO8859-1',\n    'es_es':                                'es_ES.ISO8859-1',\n    'es_gt':                                'es_GT.ISO8859-1',\n    'es_hn':                                'es_HN.ISO8859-1',\n    'es_mx':                                'es_MX.ISO8859-1',\n    'es_ni':                                'es_NI.ISO8859-1',\n    'es_pa':                                'es_PA.ISO8859-1',\n    'es_pe':                                'es_PE.ISO8859-1',\n    'es_pr':                                'es_PR.ISO8859-1',\n    'es_py':                                'es_PY.ISO8859-1',\n    'es_sv':                                'es_SV.ISO8859-1',\n    'es_us':                                'es_US.ISO8859-1',\n    'es_uy':                                'es_UY.ISO8859-1',\n    'es_ve':                                'es_VE.ISO8859-1',\n    'estonian':                             'et_EE.ISO8859-1',\n    'et':                                   'et_EE.ISO8859-15',\n    'et_ee':                                'et_EE.ISO8859-15',\n    'eu':                                   'eu_ES.ISO8859-1',\n    'eu_es':                                'eu_ES.ISO8859-1',\n    'eu_fr':                                'eu_FR.ISO8859-1',\n    'fa':                                   'fa_IR.UTF-8',\n    'fa_ir':                                'fa_IR.UTF-8',\n    'fa_ir.isiri3342':                      'fa_IR.ISIRI-3342',\n    'ff_sn':                                'ff_SN.UTF-8',\n    'fi':                                   'fi_FI.ISO8859-15',\n    'fi_fi':                                'fi_FI.ISO8859-15',\n    'fil_ph':                               'fil_PH.UTF-8',\n    'finnish':                              'fi_FI.ISO8859-1',\n    'fo':                                   'fo_FO.ISO8859-1',\n    'fo_fo':                                'fo_FO.ISO8859-1',\n    'fr':                                   'fr_FR.ISO8859-1',\n    'fr_be':                                'fr_BE.ISO8859-1',\n    'fr_ca':                                'fr_CA.ISO8859-1',\n    'fr_ch':                                'fr_CH.ISO8859-1',\n    'fr_fr':                                'fr_FR.ISO8859-1',\n    'fr_lu':                                'fr_LU.ISO8859-1',\n    'fran\\xe7ais':                          'fr_FR.ISO8859-1',\n    'fre_fr':                               'fr_FR.ISO8859-1',\n    'french':                               'fr_FR.ISO8859-1',\n    'french.iso88591':                      'fr_CH.ISO8859-1',\n    'french_france':                        'fr_FR.ISO8859-1',\n    'fur_it':                               'fur_IT.UTF-8',\n    'fy_de':                                'fy_DE.UTF-8',\n    'fy_nl':                                'fy_NL.UTF-8',\n    'ga':                                   'ga_IE.ISO8859-1',\n    'ga_ie':                                'ga_IE.ISO8859-1',\n    'galego':                               'gl_ES.ISO8859-1',\n    'galician':                             'gl_ES.ISO8859-1',\n    'gd':                                   'gd_GB.ISO8859-1',\n    'gd_gb':                                'gd_GB.ISO8859-1',\n    'ger_de':                               'de_DE.ISO8859-1',\n    'german':                               'de_DE.ISO8859-1',\n    'german.iso88591':                      'de_CH.ISO8859-1',\n    'german_germany':                       'de_DE.ISO8859-1',\n    'gez_er':                               'gez_ER.UTF-8',\n    'gez_et':                               'gez_ET.UTF-8',\n    'gl':                                   'gl_ES.ISO8859-1',\n    'gl_es':                                'gl_ES.ISO8859-1',\n    'greek':                                'el_GR.ISO8859-7',\n    'gu_in':                                'gu_IN.UTF-8',\n    'gv':                                   'gv_GB.ISO8859-1',\n    'gv_gb':                                'gv_GB.ISO8859-1',\n    'ha_ng':                                'ha_NG.UTF-8',\n    'hak_tw':                               'hak_TW.UTF-8',\n    'he':                                   'he_IL.ISO8859-8',\n    'he_il':                                'he_IL.ISO8859-8',\n    'hebrew':                               'he_IL.ISO8859-8',\n    'hi':                                   'hi_IN.ISCII-DEV',\n    'hi_in':                                'hi_IN.ISCII-DEV',\n    'hi_in.isciidev':                       'hi_IN.ISCII-DEV',\n    'hif_fj':                               'hif_FJ.UTF-8',\n    'hne':                                  'hne_IN.UTF-8',\n    'hne_in':                               'hne_IN.UTF-8',\n    'hr':                                   'hr_HR.ISO8859-2',\n    'hr_hr':                                'hr_HR.ISO8859-2',\n    'hrvatski':                             'hr_HR.ISO8859-2',\n    'hsb_de':                               'hsb_DE.ISO8859-2',\n    'ht_ht':                                'ht_HT.UTF-8',\n    'hu':                                   'hu_HU.ISO8859-2',\n    'hu_hu':                                'hu_HU.ISO8859-2',\n    'hungarian':                            'hu_HU.ISO8859-2',\n    'hy_am':                                'hy_AM.UTF-8',\n    'hy_am.armscii8':                       'hy_AM.ARMSCII_8',\n    'ia':                                   'ia.UTF-8',\n    'ia_fr':                                'ia_FR.UTF-8',\n    'icelandic':                            'is_IS.ISO8859-1',\n    'id':                                   'id_ID.ISO8859-1',\n    'id_id':                                'id_ID.ISO8859-1',\n    'ig_ng':                                'ig_NG.UTF-8',\n    'ik_ca':                                'ik_CA.UTF-8',\n    'in':                                   'id_ID.ISO8859-1',\n    'in_id':                                'id_ID.ISO8859-1',\n    'is':                                   'is_IS.ISO8859-1',\n    'is_is':                                'is_IS.ISO8859-1',\n    'iso-8859-1':                           'en_US.ISO8859-1',\n    'iso-8859-15':                          'en_US.ISO8859-15',\n    'iso8859-1':                            'en_US.ISO8859-1',\n    'iso8859-15':                           'en_US.ISO8859-15',\n    'iso_8859_1':                           'en_US.ISO8859-1',\n    'iso_8859_15':                          'en_US.ISO8859-15',\n    'it':                                   'it_IT.ISO8859-1',\n    'it_ch':                                'it_CH.ISO8859-1',\n    'it_it':                                'it_IT.ISO8859-1',\n    'italian':                              'it_IT.ISO8859-1',\n    'iu':                                   'iu_CA.NUNACOM-8',\n    'iu_ca':                                'iu_CA.NUNACOM-8',\n    'iu_ca.nunacom8':                       'iu_CA.NUNACOM-8',\n    'iw':                                   'he_IL.ISO8859-8',\n    'iw_il':                                'he_IL.ISO8859-8',\n    'iw_il.utf8':                           'iw_IL.UTF-8',\n    'ja':                                   'ja_JP.eucJP',\n    'ja_jp':                                'ja_JP.eucJP',\n    'ja_jp.euc':                            'ja_JP.eucJP',\n    'ja_jp.mscode':                         'ja_JP.SJIS',\n    'ja_jp.pck':                            'ja_JP.SJIS',\n    'japan':                                'ja_JP.eucJP',\n    'japanese':                             'ja_JP.eucJP',\n    'japanese-euc':                         'ja_JP.eucJP',\n    'japanese.euc':                         'ja_JP.eucJP',\n    'jp_jp':                                'ja_JP.eucJP',\n    'ka':                                   'ka_GE.GEORGIAN-ACADEMY',\n    'ka_ge':                                'ka_GE.GEORGIAN-ACADEMY',\n    'ka_ge.georgianacademy':                'ka_GE.GEORGIAN-ACADEMY',\n    'ka_ge.georgianps':                     'ka_GE.GEORGIAN-PS',\n    'ka_ge.georgianrs':                     'ka_GE.GEORGIAN-ACADEMY',\n    'kab_dz':                               'kab_DZ.UTF-8',\n    'kk_kz':                                'kk_KZ.ptcp154',\n    'kl':                                   'kl_GL.ISO8859-1',\n    'kl_gl':                                'kl_GL.ISO8859-1',\n    'km_kh':                                'km_KH.UTF-8',\n    'kn':                                   'kn_IN.UTF-8',\n    'kn_in':                                'kn_IN.UTF-8',\n    'ko':                                   'ko_KR.eucKR',\n    'ko_kr':                                'ko_KR.eucKR',\n    'ko_kr.euc':                            'ko_KR.eucKR',\n    'kok_in':                               'kok_IN.UTF-8',\n    'korean':                               'ko_KR.eucKR',\n    'korean.euc':                           'ko_KR.eucKR',\n    'ks':                                   'ks_IN.UTF-8',\n    'ks_in':                                'ks_IN.UTF-8',\n    'ks_in@devanagari.utf8':                'ks_IN.UTF-8@devanagari',\n    'ku_tr':                                'ku_TR.ISO8859-9',\n    'kw':                                   'kw_GB.ISO8859-1',\n    'kw_gb':                                'kw_GB.ISO8859-1',\n    'ky':                                   'ky_KG.UTF-8',\n    'ky_kg':                                'ky_KG.UTF-8',\n    'lb_lu':                                'lb_LU.UTF-8',\n    'lg_ug':                                'lg_UG.ISO8859-10',\n    'li_be':                                'li_BE.UTF-8',\n    'li_nl':                                'li_NL.UTF-8',\n    'lij_it':                               'lij_IT.UTF-8',\n    'lithuanian':                           'lt_LT.ISO8859-13',\n    'ln_cd':                                'ln_CD.UTF-8',\n    'lo':                                   'lo_LA.MULELAO-1',\n    'lo_la':                                'lo_LA.MULELAO-1',\n    'lo_la.cp1133':                         'lo_LA.IBM-CP1133',\n    'lo_la.ibmcp1133':                      'lo_LA.IBM-CP1133',\n    'lo_la.mulelao1':                       'lo_LA.MULELAO-1',\n    'lt':                                   'lt_LT.ISO8859-13',\n    'lt_lt':                                'lt_LT.ISO8859-13',\n    'lv':                                   'lv_LV.ISO8859-13',\n    'lv_lv':                                'lv_LV.ISO8859-13',\n    'lzh_tw':                               'lzh_TW.UTF-8',\n    'mag_in':                               'mag_IN.UTF-8',\n    'mai':                                  'mai_IN.UTF-8',\n    'mai_in':                               'mai_IN.UTF-8',\n    'mai_np':                               'mai_NP.UTF-8',\n    'mfe_mu':                               'mfe_MU.UTF-8',\n    'mg_mg':                                'mg_MG.ISO8859-15',\n    'mhr_ru':                               'mhr_RU.UTF-8',\n    'mi':                                   'mi_NZ.ISO8859-1',\n    'mi_nz':                                'mi_NZ.ISO8859-1',\n    'miq_ni':                               'miq_NI.UTF-8',\n    'mjw_in':                               'mjw_IN.UTF-8',\n    'mk':                                   'mk_MK.ISO8859-5',\n    'mk_mk':                                'mk_MK.ISO8859-5',\n    'ml':                                   'ml_IN.UTF-8',\n    'ml_in':                                'ml_IN.UTF-8',\n    'mn_mn':                                'mn_MN.UTF-8',\n    'mni_in':                               'mni_IN.UTF-8',\n    'mr':                                   'mr_IN.UTF-8',\n    'mr_in':                                'mr_IN.UTF-8',\n    'ms':                                   'ms_MY.ISO8859-1',\n    'ms_my':                                'ms_MY.ISO8859-1',\n    'mt':                                   'mt_MT.ISO8859-3',\n    'mt_mt':                                'mt_MT.ISO8859-3',\n    'my_mm':                                'my_MM.UTF-8',\n    'nan_tw':                               'nan_TW.UTF-8',\n    'nb':                                   'nb_NO.ISO8859-1',\n    'nb_no':                                'nb_NO.ISO8859-1',\n    'nds_de':                               'nds_DE.UTF-8',\n    'nds_nl':                               'nds_NL.UTF-8',\n    'ne_np':                                'ne_NP.UTF-8',\n    'nhn_mx':                               'nhn_MX.UTF-8',\n    'niu_nu':                               'niu_NU.UTF-8',\n    'niu_nz':                               'niu_NZ.UTF-8',\n    'nl':                                   'nl_NL.ISO8859-1',\n    'nl_aw':                                'nl_AW.UTF-8',\n    'nl_be':                                'nl_BE.ISO8859-1',\n    'nl_nl':                                'nl_NL.ISO8859-1',\n    'nn':                                   'nn_NO.ISO8859-1',\n    'nn_no':                                'nn_NO.ISO8859-1',\n    'no':                                   'no_NO.ISO8859-1',\n    'no@nynorsk':                           'ny_NO.ISO8859-1',\n    'no_no':                                'no_NO.ISO8859-1',\n    'no_no.iso88591@bokmal':                'no_NO.ISO8859-1',\n    'no_no.iso88591@nynorsk':               'no_NO.ISO8859-1',\n    'norwegian':                            'no_NO.ISO8859-1',\n    'nr':                                   'nr_ZA.ISO8859-1',\n    'nr_za':                                'nr_ZA.ISO8859-1',\n    'nso':                                  'nso_ZA.ISO8859-15',\n    'nso_za':                               'nso_ZA.ISO8859-15',\n    'ny':                                   'ny_NO.ISO8859-1',\n    'ny_no':                                'ny_NO.ISO8859-1',\n    'nynorsk':                              'nn_NO.ISO8859-1',\n    'oc':                                   'oc_FR.ISO8859-1',\n    'oc_fr':                                'oc_FR.ISO8859-1',\n    'om_et':                                'om_ET.UTF-8',\n    'om_ke':                                'om_KE.ISO8859-1',\n    'or':                                   'or_IN.UTF-8',\n    'or_in':                                'or_IN.UTF-8',\n    'os_ru':                                'os_RU.UTF-8',\n    'pa':                                   'pa_IN.UTF-8',\n    'pa_in':                                'pa_IN.UTF-8',\n    'pa_pk':                                'pa_PK.UTF-8',\n    'pap_an':                               'pap_AN.UTF-8',\n    'pap_aw':                               'pap_AW.UTF-8',\n    'pap_cw':                               'pap_CW.UTF-8',\n    'pd':                                   'pd_US.ISO8859-1',\n    'pd_de':                                'pd_DE.ISO8859-1',\n    'pd_us':                                'pd_US.ISO8859-1',\n    'ph':                                   'ph_PH.ISO8859-1',\n    'ph_ph':                                'ph_PH.ISO8859-1',\n    'pl':                                   'pl_PL.ISO8859-2',\n    'pl_pl':                                'pl_PL.ISO8859-2',\n    'polish':                               'pl_PL.ISO8859-2',\n    'portuguese':                           'pt_PT.ISO8859-1',\n    'portuguese_brazil':                    'pt_BR.ISO8859-1',\n    'posix':                                'C',\n    'posix-utf2':                           'C',\n    'pp':                                   'pp_AN.ISO8859-1',\n    'pp_an':                                'pp_AN.ISO8859-1',\n    'ps_af':                                'ps_AF.UTF-8',\n    'pt':                                   'pt_PT.ISO8859-1',\n    'pt_br':                                'pt_BR.ISO8859-1',\n    'pt_pt':                                'pt_PT.ISO8859-1',\n    'quz_pe':                               'quz_PE.UTF-8',\n    'raj_in':                               'raj_IN.UTF-8',\n    'ro':                                   'ro_RO.ISO8859-2',\n    'ro_ro':                                'ro_RO.ISO8859-2',\n    'romanian':                             'ro_RO.ISO8859-2',\n    'ru':                                   'ru_RU.UTF-8',\n    'ru_ru':                                'ru_RU.UTF-8',\n    'ru_ua':                                'ru_UA.KOI8-U',\n    'rumanian':                             'ro_RO.ISO8859-2',\n    'russian':                              'ru_RU.KOI8-R',\n    'rw':                                   'rw_RW.ISO8859-1',\n    'rw_rw':                                'rw_RW.ISO8859-1',\n    'sa_in':                                'sa_IN.UTF-8',\n    'sat_in':                               'sat_IN.UTF-8',\n    'sc_it':                                'sc_IT.UTF-8',\n    'sd':                                   'sd_IN.UTF-8',\n    'sd_in':                                'sd_IN.UTF-8',\n    'sd_in@devanagari.utf8':                'sd_IN.UTF-8@devanagari',\n    'sd_pk':                                'sd_PK.UTF-8',\n    'se_no':                                'se_NO.UTF-8',\n    'serbocroatian':                        'sr_RS.UTF-8@latin',\n    'sgs_lt':                               'sgs_LT.UTF-8',\n    'sh':                                   'sr_RS.UTF-8@latin',\n    'sh_ba.iso88592@bosnia':                'sr_CS.ISO8859-2',\n    'sh_hr':                                'sh_HR.ISO8859-2',\n    'sh_hr.iso88592':                       'hr_HR.ISO8859-2',\n    'sh_sp':                                'sr_CS.ISO8859-2',\n    'sh_yu':                                'sr_RS.UTF-8@latin',\n    'shn_mm':                               'shn_MM.UTF-8',\n    'shs_ca':                               'shs_CA.UTF-8',\n    'si':                                   'si_LK.UTF-8',\n    'si_lk':                                'si_LK.UTF-8',\n    'sid_et':                               'sid_ET.UTF-8',\n    'sinhala':                              'si_LK.UTF-8',\n    'sk':                                   'sk_SK.ISO8859-2',\n    'sk_sk':                                'sk_SK.ISO8859-2',\n    'sl':                                   'sl_SI.ISO8859-2',\n    'sl_cs':                                'sl_CS.ISO8859-2',\n    'sl_si':                                'sl_SI.ISO8859-2',\n    'slovak':                               'sk_SK.ISO8859-2',\n    'slovene':                              'sl_SI.ISO8859-2',\n    'slovenian':                            'sl_SI.ISO8859-2',\n    'sm_ws':                                'sm_WS.UTF-8',\n    'so_dj':                                'so_DJ.ISO8859-1',\n    'so_et':                                'so_ET.UTF-8',\n    'so_ke':                                'so_KE.ISO8859-1',\n    'so_so':                                'so_SO.ISO8859-1',\n    'sp':                                   'sr_CS.ISO8859-5',\n    'sp_yu':                                'sr_CS.ISO8859-5',\n    'spanish':                              'es_ES.ISO8859-1',\n    'spanish_spain':                        'es_ES.ISO8859-1',\n    'sq':                                   'sq_AL.ISO8859-2',\n    'sq_al':                                'sq_AL.ISO8859-2',\n    'sq_mk':                                'sq_MK.UTF-8',\n    'sr':                                   'sr_RS.UTF-8',\n    'sr@cyrillic':                          'sr_RS.UTF-8',\n    'sr@latn':                              'sr_CS.UTF-8@latin',\n    'sr_cs':                                'sr_CS.UTF-8',\n    'sr_cs.iso88592@latn':                  'sr_CS.ISO8859-2',\n    'sr_cs@latn':                           'sr_CS.UTF-8@latin',\n    'sr_me':                                'sr_ME.UTF-8',\n    'sr_rs':                                'sr_RS.UTF-8',\n    'sr_rs@latn':                           'sr_RS.UTF-8@latin',\n    'sr_sp':                                'sr_CS.ISO8859-2',\n    'sr_yu':                                'sr_RS.UTF-8@latin',\n    'sr_yu.cp1251@cyrillic':                'sr_CS.CP1251',\n    'sr_yu.iso88592':                       'sr_CS.ISO8859-2',\n    'sr_yu.iso88595':                       'sr_CS.ISO8859-5',\n    'sr_yu.iso88595@cyrillic':              'sr_CS.ISO8859-5',\n    'sr_yu.microsoftcp1251@cyrillic':       'sr_CS.CP1251',\n    'sr_yu.utf8':                           'sr_RS.UTF-8',\n    'sr_yu.utf8@cyrillic':                  'sr_RS.UTF-8',\n    'sr_yu@cyrillic':                       'sr_RS.UTF-8',\n    'ss':                                   'ss_ZA.ISO8859-1',\n    'ss_za':                                'ss_ZA.ISO8859-1',\n    'st':                                   'st_ZA.ISO8859-1',\n    'st_za':                                'st_ZA.ISO8859-1',\n    'sv':                                   'sv_SE.ISO8859-1',\n    'sv_fi':                                'sv_FI.ISO8859-1',\n    'sv_se':                                'sv_SE.ISO8859-1',\n    'sw_ke':                                'sw_KE.UTF-8',\n    'sw_tz':                                'sw_TZ.UTF-8',\n    'swedish':                              'sv_SE.ISO8859-1',\n    'szl_pl':                               'szl_PL.UTF-8',\n    'ta':                                   'ta_IN.TSCII-0',\n    'ta_in':                                'ta_IN.TSCII-0',\n    'ta_in.tscii':                          'ta_IN.TSCII-0',\n    'ta_in.tscii0':                         'ta_IN.TSCII-0',\n    'ta_lk':                                'ta_LK.UTF-8',\n    'tcy_in.utf8':                          'tcy_IN.UTF-8',\n    'te':                                   'te_IN.UTF-8',\n    'te_in':                                'te_IN.UTF-8',\n    'tg':                                   'tg_TJ.KOI8-C',\n    'tg_tj':                                'tg_TJ.KOI8-C',\n    'th':                                   'th_TH.ISO8859-11',\n    'th_th':                                'th_TH.ISO8859-11',\n    'th_th.tactis':                         'th_TH.TIS620',\n    'th_th.tis620':                         'th_TH.TIS620',\n    'thai':                                 'th_TH.ISO8859-11',\n    'the_np':                               'the_NP.UTF-8',\n    'ti_er':                                'ti_ER.UTF-8',\n    'ti_et':                                'ti_ET.UTF-8',\n    'tig_er':                               'tig_ER.UTF-8',\n    'tk_tm':                                'tk_TM.UTF-8',\n    'tl':                                   'tl_PH.ISO8859-1',\n    'tl_ph':                                'tl_PH.ISO8859-1',\n    'tn':                                   'tn_ZA.ISO8859-15',\n    'tn_za':                                'tn_ZA.ISO8859-15',\n    'to_to':                                'to_TO.UTF-8',\n    'tpi_pg':                               'tpi_PG.UTF-8',\n    'tr':                                   'tr_TR.ISO8859-9',\n    'tr_cy':                                'tr_CY.ISO8859-9',\n    'tr_tr':                                'tr_TR.ISO8859-9',\n    'ts':                                   'ts_ZA.ISO8859-1',\n    'ts_za':                                'ts_ZA.ISO8859-1',\n    'tt':                                   'tt_RU.TATAR-CYR',\n    'tt_ru':                                'tt_RU.TATAR-CYR',\n    'tt_ru.tatarcyr':                       'tt_RU.TATAR-CYR',\n    'tt_ru@iqtelif':                        'tt_RU.UTF-8@iqtelif',\n    'turkish':                              'tr_TR.ISO8859-9',\n    'ug_cn':                                'ug_CN.UTF-8',\n    'uk':                                   'uk_UA.KOI8-U',\n    'uk_ua':                                'uk_UA.KOI8-U',\n    'univ':                                 'en_US.utf',\n    'universal':                            'en_US.utf',\n    'universal.utf8@ucs4':                  'en_US.UTF-8',\n    'unm_us':                               'unm_US.UTF-8',\n    'ur':                                   'ur_PK.CP1256',\n    'ur_in':                                'ur_IN.UTF-8',\n    'ur_pk':                                'ur_PK.CP1256',\n    'uz':                                   'uz_UZ.UTF-8',\n    'uz_uz':                                'uz_UZ.UTF-8',\n    'uz_uz@cyrillic':                       'uz_UZ.UTF-8',\n    've':                                   've_ZA.UTF-8',\n    've_za':                                've_ZA.UTF-8',\n    'vi':                                   'vi_VN.TCVN',\n    'vi_vn':                                'vi_VN.TCVN',\n    'vi_vn.tcvn':                           'vi_VN.TCVN',\n    'vi_vn.tcvn5712':                       'vi_VN.TCVN',\n    'vi_vn.viscii':                         'vi_VN.VISCII',\n    'vi_vn.viscii111':                      'vi_VN.VISCII',\n    'wa':                                   'wa_BE.ISO8859-1',\n    'wa_be':                                'wa_BE.ISO8859-1',\n    'wae_ch':                               'wae_CH.UTF-8',\n    'wal_et':                               'wal_ET.UTF-8',\n    'wo_sn':                                'wo_SN.UTF-8',\n    'xh':                                   'xh_ZA.ISO8859-1',\n    'xh_za':                                'xh_ZA.ISO8859-1',\n    'yi':                                   'yi_US.CP1255',\n    'yi_us':                                'yi_US.CP1255',\n    'yo_ng':                                'yo_NG.UTF-8',\n    'yue_hk':                               'yue_HK.UTF-8',\n    'yuw_pg':                               'yuw_PG.UTF-8',\n    'zh':                                   'zh_CN.eucCN',\n    'zh_cn':                                'zh_CN.gb2312',\n    'zh_cn.big5':                           'zh_TW.big5',\n    'zh_cn.euc':                            'zh_CN.eucCN',\n    'zh_hk':                                'zh_HK.big5hkscs',\n    'zh_hk.big5hk':                         'zh_HK.big5hkscs',\n    'zh_sg':                                'zh_SG.GB2312',\n    'zh_sg.gbk':                            'zh_SG.GBK',\n    'zh_tw':                                'zh_TW.big5',\n    'zh_tw.euc':                            'zh_TW.eucTW',\n    'zh_tw.euctw':                          'zh_TW.eucTW',\n    'zu':                                   'zu_ZA.ISO8859-1',\n    'zu_za':                                'zu_ZA.ISO8859-1',\n}\n\n#\n# This maps Windows language identifiers to locale strings.\n#\n# This list has been updated from\n# http://msdn.microsoft.com/library/default.asp?url=/library/en-us/intl/nls_238z.asp\n# to include every locale up to Windows Vista.\n#\n# NOTE: this mapping is incomplete.  If your language is missing, please\n# submit a bug report to the Python bug tracker at http://bugs.python.org/\n# Make sure you include the missing language identifier and the suggested\n# locale code.\n#\n\nwindows_locale = {\n    0x0436: \"af_ZA\", # Afrikaans\n    0x041c: \"sq_AL\", # Albanian\n    0x0484: \"gsw_FR\",# Alsatian - France\n    0x045e: \"am_ET\", # Amharic - Ethiopia\n    0x0401: \"ar_SA\", # Arabic - Saudi Arabia\n    0x0801: \"ar_IQ\", # Arabic - Iraq\n    0x0c01: \"ar_EG\", # Arabic - Egypt\n    0x1001: \"ar_LY\", # Arabic - Libya\n    0x1401: \"ar_DZ\", # Arabic - Algeria\n    0x1801: \"ar_MA\", # Arabic - Morocco\n    0x1c01: \"ar_TN\", # Arabic - Tunisia\n    0x2001: \"ar_OM\", # Arabic - Oman\n    0x2401: \"ar_YE\", # Arabic - Yemen\n    0x2801: \"ar_SY\", # Arabic - Syria\n    0x2c01: \"ar_JO\", # Arabic - Jordan\n    0x3001: \"ar_LB\", # Arabic - Lebanon\n    0x3401: \"ar_KW\", # Arabic - Kuwait\n    0x3801: \"ar_AE\", # Arabic - United Arab Emirates\n    0x3c01: \"ar_BH\", # Arabic - Bahrain\n    0x4001: \"ar_QA\", # Arabic - Qatar\n    0x042b: \"hy_AM\", # Armenian\n    0x044d: \"as_IN\", # Assamese - India\n    0x042c: \"az_AZ\", # Azeri - Latin\n    0x082c: \"az_AZ\", # Azeri - Cyrillic\n    0x046d: \"ba_RU\", # Bashkir\n    0x042d: \"eu_ES\", # Basque - Russia\n    0x0423: \"be_BY\", # Belarusian\n    0x0445: \"bn_IN\", # Begali\n    0x201a: \"bs_BA\", # Bosnian - Cyrillic\n    0x141a: \"bs_BA\", # Bosnian - Latin\n    0x047e: \"br_FR\", # Breton - France\n    0x0402: \"bg_BG\", # Bulgarian\n#    0x0455: \"my_MM\", # Burmese - Not supported\n    0x0403: \"ca_ES\", # Catalan\n    0x0004: \"zh_CHS\",# Chinese - Simplified\n    0x0404: \"zh_TW\", # Chinese - Taiwan\n    0x0804: \"zh_CN\", # Chinese - PRC\n    0x0c04: \"zh_HK\", # Chinese - Hong Kong S.A.R.\n    0x1004: \"zh_SG\", # Chinese - Singapore\n    0x1404: \"zh_MO\", # Chinese - Macao S.A.R.\n    0x7c04: \"zh_CHT\",# Chinese - Traditional\n    0x0483: \"co_FR\", # Corsican - France\n    0x041a: \"hr_HR\", # Croatian\n    0x101a: \"hr_BA\", # Croatian - Bosnia\n    0x0405: \"cs_CZ\", # Czech\n    0x0406: \"da_DK\", # Danish\n    0x048c: \"gbz_AF\",# Dari - Afghanistan\n    0x0465: \"div_MV\",# Divehi - Maldives\n    0x0413: \"nl_NL\", # Dutch - The Netherlands\n    0x0813: \"nl_BE\", # Dutch - Belgium\n    0x0409: \"en_US\", # English - United States\n    0x0809: \"en_GB\", # English - United Kingdom\n    0x0c09: \"en_AU\", # English - Australia\n    0x1009: \"en_CA\", # English - Canada\n    0x1409: \"en_NZ\", # English - New Zealand\n    0x1809: \"en_IE\", # English - Ireland\n    0x1c09: \"en_ZA\", # English - South Africa\n    0x2009: \"en_JA\", # English - Jamaica\n    0x2409: \"en_CB\", # English - Caribbean\n    0x2809: \"en_BZ\", # English - Belize\n    0x2c09: \"en_TT\", # English - Trinidad\n    0x3009: \"en_ZW\", # English - Zimbabwe\n    0x3409: \"en_PH\", # English - Philippines\n    0x4009: \"en_IN\", # English - India\n    0x4409: \"en_MY\", # English - Malaysia\n    0x4809: \"en_IN\", # English - Singapore\n    0x0425: \"et_EE\", # Estonian\n    0x0438: \"fo_FO\", # Faroese\n    0x0464: \"fil_PH\",# Filipino\n    0x040b: \"fi_FI\", # Finnish\n    0x040c: \"fr_FR\", # French - France\n    0x080c: \"fr_BE\", # French - Belgium\n    0x0c0c: \"fr_CA\", # French - Canada\n    0x100c: \"fr_CH\", # French - Switzerland\n    0x140c: \"fr_LU\", # French - Luxembourg\n    0x180c: \"fr_MC\", # French - Monaco\n    0x0462: \"fy_NL\", # Frisian - Netherlands\n    0x0456: \"gl_ES\", # Galician\n    0x0437: \"ka_GE\", # Georgian\n    0x0407: \"de_DE\", # German - Germany\n    0x0807: \"de_CH\", # German - Switzerland\n    0x0c07: \"de_AT\", # German - Austria\n    0x1007: \"de_LU\", # German - Luxembourg\n    0x1407: \"de_LI\", # German - Liechtenstein\n    0x0408: \"el_GR\", # Greek\n    0x046f: \"kl_GL\", # Greenlandic - Greenland\n    0x0447: \"gu_IN\", # Gujarati\n    0x0468: \"ha_NG\", # Hausa - Latin\n    0x040d: \"he_IL\", # Hebrew\n    0x0439: \"hi_IN\", # Hindi\n    0x040e: \"hu_HU\", # Hungarian\n    0x040f: \"is_IS\", # Icelandic\n    0x0421: \"id_ID\", # Indonesian\n    0x045d: \"iu_CA\", # Inuktitut - Syllabics\n    0x085d: \"iu_CA\", # Inuktitut - Latin\n    0x083c: \"ga_IE\", # Irish - Ireland\n    0x0410: \"it_IT\", # Italian - Italy\n    0x0810: \"it_CH\", # Italian - Switzerland\n    0x0411: \"ja_JP\", # Japanese\n    0x044b: \"kn_IN\", # Kannada - India\n    0x043f: \"kk_KZ\", # Kazakh\n    0x0453: \"kh_KH\", # Khmer - Cambodia\n    0x0486: \"qut_GT\",# K'iche - Guatemala\n    0x0487: \"rw_RW\", # Kinyarwanda - Rwanda\n    0x0457: \"kok_IN\",# Konkani\n    0x0412: \"ko_KR\", # Korean\n    0x0440: \"ky_KG\", # Kyrgyz\n    0x0454: \"lo_LA\", # Lao - Lao PDR\n    0x0426: \"lv_LV\", # Latvian\n    0x0427: \"lt_LT\", # Lithuanian\n    0x082e: \"dsb_DE\",# Lower Sorbian - Germany\n    0x046e: \"lb_LU\", # Luxembourgish\n    0x042f: \"mk_MK\", # FYROM Macedonian\n    0x043e: \"ms_MY\", # Malay - Malaysia\n    0x083e: \"ms_BN\", # Malay - Brunei Darussalam\n    0x044c: \"ml_IN\", # Malayalam - India\n    0x043a: \"mt_MT\", # Maltese\n    0x0481: \"mi_NZ\", # Maori\n    0x047a: \"arn_CL\",# Mapudungun\n    0x044e: \"mr_IN\", # Marathi\n    0x047c: \"moh_CA\",# Mohawk - Canada\n    0x0450: \"mn_MN\", # Mongolian - Cyrillic\n    0x0850: \"mn_CN\", # Mongolian - PRC\n    0x0461: \"ne_NP\", # Nepali\n    0x0414: \"nb_NO\", # Norwegian - Bokmal\n    0x0814: \"nn_NO\", # Norwegian - Nynorsk\n    0x0482: \"oc_FR\", # Occitan - France\n    0x0448: \"or_IN\", # Oriya - India\n    0x0463: \"ps_AF\", # Pashto - Afghanistan\n    0x0429: \"fa_IR\", # Persian\n    0x0415: \"pl_PL\", # Polish\n    0x0416: \"pt_BR\", # Portuguese - Brazil\n    0x0816: \"pt_PT\", # Portuguese - Portugal\n    0x0446: \"pa_IN\", # Punjabi\n    0x046b: \"quz_BO\",# Quechua (Bolivia)\n    0x086b: \"quz_EC\",# Quechua (Ecuador)\n    0x0c6b: \"quz_PE\",# Quechua (Peru)\n    0x0418: \"ro_RO\", # Romanian - Romania\n    0x0417: \"rm_CH\", # Romansh\n    0x0419: \"ru_RU\", # Russian\n    0x243b: \"smn_FI\",# Sami Finland\n    0x103b: \"smj_NO\",# Sami Norway\n    0x143b: \"smj_SE\",# Sami Sweden\n    0x043b: \"se_NO\", # Sami Northern Norway\n    0x083b: \"se_SE\", # Sami Northern Sweden\n    0x0c3b: \"se_FI\", # Sami Northern Finland\n    0x203b: \"sms_FI\",# Sami Skolt\n    0x183b: \"sma_NO\",# Sami Southern Norway\n    0x1c3b: \"sma_SE\",# Sami Southern Sweden\n    0x044f: \"sa_IN\", # Sanskrit\n    0x0c1a: \"sr_SP\", # Serbian - Cyrillic\n    0x1c1a: \"sr_BA\", # Serbian - Bosnia Cyrillic\n    0x081a: \"sr_SP\", # Serbian - Latin\n    0x181a: \"sr_BA\", # Serbian - Bosnia Latin\n    0x045b: \"si_LK\", # Sinhala - Sri Lanka\n    0x046c: \"ns_ZA\", # Northern Sotho\n    0x0432: \"tn_ZA\", # Setswana - Southern Africa\n    0x041b: \"sk_SK\", # Slovak\n    0x0424: \"sl_SI\", # Slovenian\n    0x040a: \"es_ES\", # Spanish - Spain\n    0x080a: \"es_MX\", # Spanish - Mexico\n    0x0c0a: \"es_ES\", # Spanish - Spain (Modern)\n    0x100a: \"es_GT\", # Spanish - Guatemala\n    0x140a: \"es_CR\", # Spanish - Costa Rica\n    0x180a: \"es_PA\", # Spanish - Panama\n    0x1c0a: \"es_DO\", # Spanish - Dominican Republic\n    0x200a: \"es_VE\", # Spanish - Venezuela\n    0x240a: \"es_CO\", # Spanish - Colombia\n    0x280a: \"es_PE\", # Spanish - Peru\n    0x2c0a: \"es_AR\", # Spanish - Argentina\n    0x300a: \"es_EC\", # Spanish - Ecuador\n    0x340a: \"es_CL\", # Spanish - Chile\n    0x380a: \"es_UR\", # Spanish - Uruguay\n    0x3c0a: \"es_PY\", # Spanish - Paraguay\n    0x400a: \"es_BO\", # Spanish - Bolivia\n    0x440a: \"es_SV\", # Spanish - El Salvador\n    0x480a: \"es_HN\", # Spanish - Honduras\n    0x4c0a: \"es_NI\", # Spanish - Nicaragua\n    0x500a: \"es_PR\", # Spanish - Puerto Rico\n    0x540a: \"es_US\", # Spanish - United States\n#    0x0430: \"\", # Sutu - Not supported\n    0x0441: \"sw_KE\", # Swahili\n    0x041d: \"sv_SE\", # Swedish - Sweden\n    0x081d: \"sv_FI\", # Swedish - Finland\n    0x045a: \"syr_SY\",# Syriac\n    0x0428: \"tg_TJ\", # Tajik - Cyrillic\n    0x085f: \"tmz_DZ\",# Tamazight - Latin\n    0x0449: \"ta_IN\", # Tamil\n    0x0444: \"tt_RU\", # Tatar\n    0x044a: \"te_IN\", # Telugu\n    0x041e: \"th_TH\", # Thai\n    0x0851: \"bo_BT\", # Tibetan - Bhutan\n    0x0451: \"bo_CN\", # Tibetan - PRC\n    0x041f: \"tr_TR\", # Turkish\n    0x0442: \"tk_TM\", # Turkmen - Cyrillic\n    0x0480: \"ug_CN\", # Uighur - Arabic\n    0x0422: \"uk_UA\", # Ukrainian\n    0x042e: \"wen_DE\",# Upper Sorbian - Germany\n    0x0420: \"ur_PK\", # Urdu\n    0x0820: \"ur_IN\", # Urdu - India\n    0x0443: \"uz_UZ\", # Uzbek - Latin\n    0x0843: \"uz_UZ\", # Uzbek - Cyrillic\n    0x042a: \"vi_VN\", # Vietnamese\n    0x0452: \"cy_GB\", # Welsh\n    0x0488: \"wo_SN\", # Wolof - Senegal\n    0x0434: \"xh_ZA\", # Xhosa - South Africa\n    0x0485: \"sah_RU\",# Yakut - Cyrillic\n    0x0478: \"ii_CN\", # Yi - PRC\n    0x046a: \"yo_NG\", # Yoruba - Nigeria\n    0x0435: \"zu_ZA\", # Zulu\n}\n\ndef _print_locale():\n\n    \"\"\" Test function.\n    \"\"\"\n    categories = {}\n    def _init_categories(categories=categories):\n        for k,v in globals().items():\n            if k[:3] == 'LC_':\n                categories[k] = v\n    _init_categories()\n    del categories['LC_ALL']\n\n    print('Locale defaults as determined by getdefaultlocale():')\n    print('-'*72)\n    lang, enc = getdefaultlocale()\n    print('Language: ', lang or '(undefined)')\n    print('Encoding: ', enc or '(undefined)')\n    print()\n\n    print('Locale settings on startup:')\n    print('-'*72)\n    for name,category in categories.items():\n        print(name, '...')\n        lang, enc = getlocale(category)\n        print('   Language: ', lang or '(undefined)')\n        print('   Encoding: ', enc or '(undefined)')\n        print()\n\n    print()\n    print('Locale settings after calling resetlocale():')\n    print('-'*72)\n    resetlocale()\n    for name,category in categories.items():\n        print(name, '...')\n        lang, enc = getlocale(category)\n        print('   Language: ', lang or '(undefined)')\n        print('   Encoding: ', enc or '(undefined)')\n        print()\n\n    try:\n        setlocale(LC_ALL, \"\")\n    except:\n        print('NOTE:')\n        print('setlocale(LC_ALL, \"\") does not support the default locale')\n        print('given in the OS environment variables.')\n    else:\n        print()\n        print('Locale settings after calling setlocale(LC_ALL, \"\"):')\n        print('-'*72)\n        for name,category in categories.items():\n            print(name, '...')\n            lang, enc = getlocale(category)\n            print('   Language: ', lang or '(undefined)')\n            print('   Encoding: ', enc or '(undefined)')\n            print()\n\n###\n\ntry:\n    LC_MESSAGES\nexcept NameError:\n    pass\nelse:\n    __all__.append(\"LC_MESSAGES\")\n\nif __name__=='__main__':\n    print('Locale aliasing:')\n    print()\n    _print_locale()\n    print()\n    print('Number formatting:')\n    print()\n    _test()\n",1789],"/home/ma-user/anaconda3/envs/py311/lib/python3.11/gettext.py":["\"\"\"Internationalization and localization support.\n\nThis module provides internationalization (I18N) and localization (L10N)\nsupport for your Python programs by providing an interface to the GNU gettext\nmessage catalog library.\n\nI18N refers to the operation by which a program is made aware of multiple\nlanguages.  L10N refers to the adaptation of your program, once\ninternationalized, to the local language and cultural habits.\n\n\"\"\"\n\n# This module represents the integration of work, contributions, feedback, and\n# suggestions from the following people:\n#\n# Martin von Loewis, who wrote the initial implementation of the underlying\n# C-based libintlmodule (later renamed _gettext), along with a skeletal\n# gettext.py implementation.\n#\n# Peter Funk, who wrote fintl.py, a fairly complete wrapper around intlmodule,\n# which also included a pure-Python implementation to read .mo files if\n# intlmodule wasn't available.\n#\n# James Henstridge, who also wrote a gettext.py module, which has some\n# interesting, but currently unsupported experimental features: the notion of\n# a Catalog class and instances, and the ability to add to a catalog file via\n# a Python API.\n#\n# Barry Warsaw integrated these modules, wrote the .install() API and code,\n# and conformed all C and Python code to Python's coding standards.\n#\n# Francois Pinard and Marc-Andre Lemburg also contributed valuably to this\n# module.\n#\n# J. David Ibanez implemented plural forms. Bruno Haible fixed some bugs.\n#\n# TODO:\n# - Lazy loading of .mo files.  Currently the entire catalog is loaded into\n#   memory, but that's probably bad for large translated programs.  Instead,\n#   the lexical sort of original strings in GNU .mo files should be exploited\n#   to do binary searches and lazy initializations.  Or you might want to use\n#   the undocumented double-hash algorithm for .mo files with hash tables, but\n#   you'll need to study the GNU gettext code to do this.\n#\n# - Support Solaris .mo file formats.  Unfortunately, we've been unable to\n#   find this format documented anywhere.\n\n\nimport os\nimport re\nimport sys\n\n\n__all__ = ['NullTranslations', 'GNUTranslations', 'Catalog',\n           'bindtextdomain', 'find', 'translation', 'install',\n           'textdomain', 'dgettext', 'dngettext', 'gettext',\n           'ngettext', 'pgettext', 'dpgettext', 'npgettext',\n           'dnpgettext'\n           ]\n\n_default_localedir = os.path.join(sys.base_prefix, 'share', 'locale')\n\n# Expression parsing for plural form selection.\n#\n# The gettext library supports a small subset of C syntax.  The only\n# incompatible difference is that integer literals starting with zero are\n# decimal.\n#\n# https://www.gnu.org/software/gettext/manual/gettext.html#Plural-forms\n# http://git.savannah.gnu.org/cgit/gettext.git/tree/gettext-runtime/intl/plural.y\n\n_token_pattern = re.compile(r\"\"\"\n        (?P<WHITESPACES>[ \\t]+)                    | # spaces and horizontal tabs\n        (?P<NUMBER>[0-9]+\\b)                       | # decimal integer\n        (?P<NAME>n\\b)                              | # only n is allowed\n        (?P<PARENTHESIS>[()])                      |\n        (?P<OPERATOR>[-*/%+?:]|[><!]=?|==|&&|\\|\\|) | # !, *, /, %, +, -, <, >,\n                                                     # <=, >=, ==, !=, &&, ||,\n                                                     # ? :\n                                                     # unary and bitwise ops\n                                                     # not allowed\n        (?P<INVALID>\\w+|.)                           # invalid token\n    \"\"\", re.VERBOSE|re.DOTALL)\n\n\ndef _tokenize(plural):\n    for mo in re.finditer(_token_pattern, plural):\n        kind = mo.lastgroup\n        if kind == 'WHITESPACES':\n            continue\n        value = mo.group(kind)\n        if kind == 'INVALID':\n            raise ValueError('invalid token in plural form: %s' % value)\n        yield value\n    yield ''\n\n\ndef _error(value):\n    if value:\n        return ValueError('unexpected token in plural form: %s' % value)\n    else:\n        return ValueError('unexpected end of plural form')\n\n\n_binary_ops = (\n    ('||',),\n    ('&&',),\n    ('==', '!='),\n    ('<', '>', '<=', '>='),\n    ('+', '-'),\n    ('*', '/', '%'),\n)\n_binary_ops = {op: i for i, ops in enumerate(_binary_ops, 1) for op in ops}\n_c2py_ops = {'||': 'or', '&&': 'and', '/': '//'}\n\n\ndef _parse(tokens, priority=-1):\n    result = ''\n    nexttok = next(tokens)\n    while nexttok == '!':\n        result += 'not '\n        nexttok = next(tokens)\n\n    if nexttok == '(':\n        sub, nexttok = _parse(tokens)\n        result = '%s(%s)' % (result, sub)\n        if nexttok != ')':\n            raise ValueError('unbalanced parenthesis in plural form')\n    elif nexttok == 'n':\n        result = '%s%s' % (result, nexttok)\n    else:\n        try:\n            value = int(nexttok, 10)\n        except ValueError:\n            raise _error(nexttok) from None\n        result = '%s%d' % (result, value)\n    nexttok = next(tokens)\n\n    j = 100\n    while nexttok in _binary_ops:\n        i = _binary_ops[nexttok]\n        if i < priority:\n            break\n        # Break chained comparisons\n        if i in (3, 4) and j in (3, 4):  # '==', '!=', '<', '>', '<=', '>='\n            result = '(%s)' % result\n        # Replace some C operators by their Python equivalents\n        op = _c2py_ops.get(nexttok, nexttok)\n        right, nexttok = _parse(tokens, i + 1)\n        result = '%s %s %s' % (result, op, right)\n        j = i\n    if j == priority == 4:  # '<', '>', '<=', '>='\n        result = '(%s)' % result\n\n    if nexttok == '?' and priority <= 0:\n        if_true, nexttok = _parse(tokens, 0)\n        if nexttok != ':':\n            raise _error(nexttok)\n        if_false, nexttok = _parse(tokens)\n        result = '%s if %s else %s' % (if_true, result, if_false)\n        if priority == 0:\n            result = '(%s)' % result\n\n    return result, nexttok\n\n\ndef _as_int(n):\n    try:\n        i = round(n)\n    except TypeError:\n        raise TypeError('Plural value must be an integer, got %s' %\n                        (n.__class__.__name__,)) from None\n    import warnings\n    warnings.warn('Plural value must be an integer, got %s' %\n                  (n.__class__.__name__,),\n                  DeprecationWarning, 4)\n    return n\n\n\ndef c2py(plural):\n    \"\"\"Gets a C expression as used in PO files for plural forms and returns a\n    Python function that implements an equivalent expression.\n    \"\"\"\n\n    if len(plural) > 1000:\n        raise ValueError('plural form expression is too long')\n    try:\n        result, nexttok = _parse(_tokenize(plural))\n        if nexttok:\n            raise _error(nexttok)\n\n        depth = 0\n        for c in result:\n            if c == '(':\n                depth += 1\n                if depth > 20:\n                    # Python compiler limit is about 90.\n                    # The most complex example has 2.\n                    raise ValueError('plural form expression is too complex')\n            elif c == ')':\n                depth -= 1\n\n        ns = {'_as_int': _as_int}\n        exec('''if True:\n            def func(n):\n                if not isinstance(n, int):\n                    n = _as_int(n)\n                return int(%s)\n            ''' % result, ns)\n        return ns['func']\n    except RecursionError:\n        # Recursion error can be raised in _parse() or exec().\n        raise ValueError('plural form expression is too complex')\n\n\ndef _expand_lang(loc):\n    import locale\n    loc = locale.normalize(loc)\n    COMPONENT_CODESET   = 1 << 0\n    COMPONENT_TERRITORY = 1 << 1\n    COMPONENT_MODIFIER  = 1 << 2\n    # split up the locale into its base components\n    mask = 0\n    pos = loc.find('@')\n    if pos >= 0:\n        modifier = loc[pos:]\n        loc = loc[:pos]\n        mask |= COMPONENT_MODIFIER\n    else:\n        modifier = ''\n    pos = loc.find('.')\n    if pos >= 0:\n        codeset = loc[pos:]\n        loc = loc[:pos]\n        mask |= COMPONENT_CODESET\n    else:\n        codeset = ''\n    pos = loc.find('_')\n    if pos >= 0:\n        territory = loc[pos:]\n        loc = loc[:pos]\n        mask |= COMPONENT_TERRITORY\n    else:\n        territory = ''\n    language = loc\n    ret = []\n    for i in range(mask+1):\n        if not (i & ~mask):  # if all components for this combo exist ...\n            val = language\n            if i & COMPONENT_TERRITORY: val += territory\n            if i & COMPONENT_CODESET:   val += codeset\n            if i & COMPONENT_MODIFIER:  val += modifier\n            ret.append(val)\n    ret.reverse()\n    return ret\n\n\nclass NullTranslations:\n    def __init__(self, fp=None):\n        self._info = {}\n        self._charset = None\n        self._fallback = None\n        if fp is not None:\n            self._parse(fp)\n\n    def _parse(self, fp):\n        pass\n\n    def add_fallback(self, fallback):\n        if self._fallback:\n            self._fallback.add_fallback(fallback)\n        else:\n            self._fallback = fallback\n\n    def gettext(self, message):\n        if self._fallback:\n            return self._fallback.gettext(message)\n        return message\n\n    def ngettext(self, msgid1, msgid2, n):\n        if self._fallback:\n            return self._fallback.ngettext(msgid1, msgid2, n)\n        if n == 1:\n            return msgid1\n        else:\n            return msgid2\n\n    def pgettext(self, context, message):\n        if self._fallback:\n            return self._fallback.pgettext(context, message)\n        return message\n\n    def npgettext(self, context, msgid1, msgid2, n):\n        if self._fallback:\n            return self._fallback.npgettext(context, msgid1, msgid2, n)\n        if n == 1:\n            return msgid1\n        else:\n            return msgid2\n\n    def info(self):\n        return self._info\n\n    def charset(self):\n        return self._charset\n\n    def install(self, names=None):\n        import builtins\n        builtins.__dict__['_'] = self.gettext\n        if names is not None:\n            allowed = {'gettext', 'ngettext', 'npgettext', 'pgettext'}\n            for name in allowed & set(names):\n                builtins.__dict__[name] = getattr(self, name)\n\n\nclass GNUTranslations(NullTranslations):\n    # Magic number of .mo files\n    LE_MAGIC = 0x950412de\n    BE_MAGIC = 0xde120495\n\n    # The encoding of a msgctxt and a msgid in a .mo file is\n    # msgctxt + \"\\x04\" + msgid (gettext version >= 0.15)\n    CONTEXT = \"%s\\x04%s\"\n\n    # Acceptable .mo versions\n    VERSIONS = (0, 1)\n\n    def _get_versions(self, version):\n        \"\"\"Returns a tuple of major version, minor version\"\"\"\n        return (version >> 16, version & 0xffff)\n\n    def _parse(self, fp):\n        \"\"\"Override this method to support alternative .mo formats.\"\"\"\n        # Delay struct import for speeding up gettext import when .mo files\n        # are not used.\n        from struct import unpack\n        filename = getattr(fp, 'name', '')\n        # Parse the .mo file header, which consists of 5 little endian 32\n        # bit words.\n        self._catalog = catalog = {}\n        self.plural = lambda n: int(n != 1) # germanic plural by default\n        buf = fp.read()\n        buflen = len(buf)\n        # Are we big endian or little endian?\n        magic = unpack('<I', buf[:4])[0]\n        if magic == self.LE_MAGIC:\n            version, msgcount, masteridx, transidx = unpack('<4I', buf[4:20])\n            ii = '<II'\n        elif magic == self.BE_MAGIC:\n            version, msgcount, masteridx, transidx = unpack('>4I', buf[4:20])\n            ii = '>II'\n        else:\n            raise OSError(0, 'Bad magic number', filename)\n\n        major_version, minor_version = self._get_versions(version)\n\n        if major_version not in self.VERSIONS:\n            raise OSError(0, 'Bad version number ' + str(major_version), filename)\n\n        # Now put all messages from the .mo file buffer into the catalog\n        # dictionary.\n        for i in range(0, msgcount):\n            mlen, moff = unpack(ii, buf[masteridx:masteridx+8])\n            mend = moff + mlen\n            tlen, toff = unpack(ii, buf[transidx:transidx+8])\n            tend = toff + tlen\n            if mend < buflen and tend < buflen:\n                msg = buf[moff:mend]\n                tmsg = buf[toff:tend]\n            else:\n                raise OSError(0, 'File is corrupt', filename)\n            # See if we're looking at GNU .mo conventions for metadata\n            if mlen == 0:\n                # Catalog description\n                lastk = None\n                for b_item in tmsg.split(b'\\n'):\n                    item = b_item.decode().strip()\n                    if not item:\n                        continue\n                    # Skip over comment lines:\n                    if item.startswith('#-#-#-#-#') and item.endswith('#-#-#-#-#'):\n                        continue\n                    k = v = None\n                    if ':' in item:\n                        k, v = item.split(':', 1)\n                        k = k.strip().lower()\n                        v = v.strip()\n                        self._info[k] = v\n                        lastk = k\n                    elif lastk:\n                        self._info[lastk] += '\\n' + item\n                    if k == 'content-type':\n                        self._charset = v.split('charset=')[1]\n                    elif k == 'plural-forms':\n                        v = v.split(';')\n                        plural = v[1].split('plural=')[1]\n                        self.plural = c2py(plural)\n            # Note: we unconditionally convert both msgids and msgstrs to\n            # Unicode using the character encoding specified in the charset\n            # parameter of the Content-Type header.  The gettext documentation\n            # strongly encourages msgids to be us-ascii, but some applications\n            # require alternative encodings (e.g. Zope's ZCML and ZPT).  For\n            # traditional gettext applications, the msgid conversion will\n            # cause no problems since us-ascii should always be a subset of\n            # the charset encoding.  We may want to fall back to 8-bit msgids\n            # if the Unicode conversion fails.\n            charset = self._charset or 'ascii'\n            if b'\\x00' in msg:\n                # Plural forms\n                msgid1, msgid2 = msg.split(b'\\x00')\n                tmsg = tmsg.split(b'\\x00')\n                msgid1 = str(msgid1, charset)\n                for i, x in enumerate(tmsg):\n                    catalog[(msgid1, i)] = str(x, charset)\n            else:\n                catalog[str(msg, charset)] = str(tmsg, charset)\n            # advance to next entry in the seek tables\n            masteridx += 8\n            transidx += 8\n\n    def gettext(self, message):\n        missing = object()\n        tmsg = self._catalog.get(message, missing)\n        if tmsg is missing:\n            if self._fallback:\n                return self._fallback.gettext(message)\n            return message\n        return tmsg\n\n    def ngettext(self, msgid1, msgid2, n):\n        try:\n            tmsg = self._catalog[(msgid1, self.plural(n))]\n        except KeyError:\n            if self._fallback:\n                return self._fallback.ngettext(msgid1, msgid2, n)\n            if n == 1:\n                tmsg = msgid1\n            else:\n                tmsg = msgid2\n        return tmsg\n\n    def pgettext(self, context, message):\n        ctxt_msg_id = self.CONTEXT % (context, message)\n        missing = object()\n        tmsg = self._catalog.get(ctxt_msg_id, missing)\n        if tmsg is missing:\n            if self._fallback:\n                return self._fallback.pgettext(context, message)\n            return message\n        return tmsg\n\n    def npgettext(self, context, msgid1, msgid2, n):\n        ctxt_msg_id = self.CONTEXT % (context, msgid1)\n        try:\n            tmsg = self._catalog[ctxt_msg_id, self.plural(n)]\n        except KeyError:\n            if self._fallback:\n                return self._fallback.npgettext(context, msgid1, msgid2, n)\n            if n == 1:\n                tmsg = msgid1\n            else:\n                tmsg = msgid2\n        return tmsg\n\n\n# Locate a .mo file using the gettext strategy\ndef find(domain, localedir=None, languages=None, all=False):\n    # Get some reasonable defaults for arguments that were not supplied\n    if localedir is None:\n        localedir = _default_localedir\n    if languages is None:\n        languages = []\n        for envar in ('LANGUAGE', 'LC_ALL', 'LC_MESSAGES', 'LANG'):\n            val = os.environ.get(envar)\n            if val:\n                languages = val.split(':')\n                break\n        if 'C' not in languages:\n            languages.append('C')\n    # now normalize and expand the languages\n    nelangs = []\n    for lang in languages:\n        for nelang in _expand_lang(lang):\n            if nelang not in nelangs:\n                nelangs.append(nelang)\n    # select a language\n    if all:\n        result = []\n    else:\n        result = None\n    for lang in nelangs:\n        if lang == 'C':\n            break\n        mofile = os.path.join(localedir, lang, 'LC_MESSAGES', '%s.mo' % domain)\n        if os.path.exists(mofile):\n            if all:\n                result.append(mofile)\n            else:\n                return mofile\n    return result\n\n\n# a mapping between absolute .mo file path and Translation object\n_translations = {}\n\n\ndef translation(domain, localedir=None, languages=None,\n                class_=None, fallback=False):\n    if class_ is None:\n        class_ = GNUTranslations\n    mofiles = find(domain, localedir, languages, all=True)\n    if not mofiles:\n        if fallback:\n            return NullTranslations()\n        from errno import ENOENT\n        raise FileNotFoundError(ENOENT,\n                                'No translation file found for domain', domain)\n    # Avoid opening, reading, and parsing the .mo file after it's been done\n    # once.\n    result = None\n    for mofile in mofiles:\n        key = (class_, os.path.abspath(mofile))\n        t = _translations.get(key)\n        if t is None:\n            with open(mofile, 'rb') as fp:\n                t = _translations.setdefault(key, class_(fp))\n        # Copy the translation object to allow setting fallbacks and\n        # output charset. All other instance data is shared with the\n        # cached object.\n        # Delay copy import for speeding up gettext import when .mo files\n        # are not used.\n        import copy\n        t = copy.copy(t)\n        if result is None:\n            result = t\n        else:\n            result.add_fallback(t)\n    return result\n\n\ndef install(domain, localedir=None, *, names=None):\n    t = translation(domain, localedir, fallback=True)\n    t.install(names)\n\n\n# a mapping b/w domains and locale directories\n_localedirs = {}\n# current global domain, `messages' used for compatibility w/ GNU gettext\n_current_domain = 'messages'\n\n\ndef textdomain(domain=None):\n    global _current_domain\n    if domain is not None:\n        _current_domain = domain\n    return _current_domain\n\n\ndef bindtextdomain(domain, localedir=None):\n    global _localedirs\n    if localedir is not None:\n        _localedirs[domain] = localedir\n    return _localedirs.get(domain, _default_localedir)\n\n\ndef dgettext(domain, message):\n    try:\n        t = translation(domain, _localedirs.get(domain, None))\n    except OSError:\n        return message\n    return t.gettext(message)\n\n\ndef dngettext(domain, msgid1, msgid2, n):\n    try:\n        t = translation(domain, _localedirs.get(domain, None))\n    except OSError:\n        if n == 1:\n            return msgid1\n        else:\n            return msgid2\n    return t.ngettext(msgid1, msgid2, n)\n\n\ndef dpgettext(domain, context, message):\n    try:\n        t = translation(domain, _localedirs.get(domain, None))\n    except OSError:\n        return message\n    return t.pgettext(context, message)\n\n\ndef dnpgettext(domain, context, msgid1, msgid2, n):\n    try:\n        t = translation(domain, _localedirs.get(domain, None))\n    except OSError:\n        if n == 1:\n            return msgid1\n        else:\n            return msgid2\n    return t.npgettext(context, msgid1, msgid2, n)\n\n\ndef gettext(message):\n    return dgettext(_current_domain, message)\n\n\ndef ngettext(msgid1, msgid2, n):\n    return dngettext(_current_domain, msgid1, msgid2, n)\n\n\ndef pgettext(context, message):\n    return dpgettext(_current_domain, context, message)\n\n\ndef npgettext(context, msgid1, msgid2, n):\n    return dnpgettext(_current_domain, context, msgid1, msgid2, n)\n\n\n# dcgettext() has been deemed unnecessary and is not implemented.\n\n# James Henstridge's Catalog constructor from GNOME gettext.  Documented usage\n# was:\n#\n#    import gettext\n#    cat = gettext.Catalog(PACKAGE, localedir=LOCALEDIR)\n#    _ = cat.gettext\n#    print _('Hello World')\n\n# The resulting catalog object currently don't support access through a\n# dictionary API, which was supported (but apparently unused) in GNOME\n# gettext.\n\nCatalog = translation\n",634],"/home/ma-user/anaconda3/envs/py311/lib/python3.11/enum.py":["import sys\nimport builtins as bltns\nfrom types import MappingProxyType, DynamicClassAttribute\nfrom operator import or_ as _or_\nfrom functools import reduce\n\n\n__all__ = [\n        'EnumType', 'EnumMeta',\n        'Enum', 'IntEnum', 'StrEnum', 'Flag', 'IntFlag', 'ReprEnum',\n        'auto', 'unique', 'property', 'verify', 'member', 'nonmember',\n        'FlagBoundary', 'STRICT', 'CONFORM', 'EJECT', 'KEEP',\n        'global_flag_repr', 'global_enum_repr', 'global_str', 'global_enum',\n        'EnumCheck', 'CONTINUOUS', 'NAMED_FLAGS', 'UNIQUE',\n        ]\n\n\n# Dummy value for Enum and Flag as there are explicit checks for them\n# before they have been created.\n# This is also why there are checks in EnumType like `if Enum is not None`\nEnum = Flag = EJECT = _stdlib_enums = ReprEnum = None\n\nclass nonmember(object):\n    \"\"\"\n    Protects item from becaming an Enum member during class creation.\n    \"\"\"\n    def __init__(self, value):\n        self.value = value\n\nclass member(object):\n    \"\"\"\n    Forces item to became an Enum member during class creation.\n    \"\"\"\n    def __init__(self, value):\n        self.value = value\n\ndef _is_descriptor(obj):\n    \"\"\"\n    Returns True if obj is a descriptor, False otherwise.\n    \"\"\"\n    return (\n            hasattr(obj, '__get__') or\n            hasattr(obj, '__set__') or\n            hasattr(obj, '__delete__')\n            )\n\ndef _is_dunder(name):\n    \"\"\"\n    Returns True if a __dunder__ name, False otherwise.\n    \"\"\"\n    return (\n            len(name) > 4 and\n            name[:2] == name[-2:] == '__' and\n            name[2] != '_' and\n            name[-3] != '_'\n            )\n\ndef _is_sunder(name):\n    \"\"\"\n    Returns True if a _sunder_ name, False otherwise.\n    \"\"\"\n    return (\n            len(name) > 2 and\n            name[0] == name[-1] == '_' and\n            name[1:2] != '_' and\n            name[-2:-1] != '_'\n            )\n\ndef _is_internal_class(cls_name, obj):\n    # do not use `re` as `re` imports `enum`\n    if not isinstance(obj, type):\n        return False\n    qualname = getattr(obj, '__qualname__', '')\n    s_pattern = cls_name + '.' + getattr(obj, '__name__', '')\n    e_pattern = '.' + s_pattern\n    return qualname == s_pattern or qualname.endswith(e_pattern)\n\ndef _is_private(cls_name, name):\n    # do not use `re` as `re` imports `enum`\n    pattern = '_%s__' % (cls_name, )\n    pat_len = len(pattern)\n    if (\n            len(name) > pat_len\n            and name.startswith(pattern)\n            and name[pat_len:pat_len+1] != ['_']\n            and (name[-1] != '_' or name[-2] != '_')\n        ):\n        return True\n    else:\n        return False\n\ndef _is_single_bit(num):\n    \"\"\"\n    True if only one bit set in num (should be an int)\n    \"\"\"\n    if num == 0:\n        return False\n    num &= num - 1\n    return num == 0\n\ndef _make_class_unpicklable(obj):\n    \"\"\"\n    Make the given obj un-picklable.\n\n    obj should be either a dictionary, or an Enum\n    \"\"\"\n    def _break_on_call_reduce(self, proto):\n        raise TypeError('%r cannot be pickled' % self)\n    if isinstance(obj, dict):\n        obj['__reduce_ex__'] = _break_on_call_reduce\n        obj['__module__'] = '<unknown>'\n    else:\n        setattr(obj, '__reduce_ex__', _break_on_call_reduce)\n        setattr(obj, '__module__', '<unknown>')\n\ndef _iter_bits_lsb(num):\n    # num must be an integer\n    if isinstance(num, Enum):\n        num = num.value\n    while num:\n        b = num & (~num + 1)\n        yield b\n        num ^= b\n\ndef show_flag_values(value):\n    return list(_iter_bits_lsb(value))\n\ndef bin(num, max_bits=None):\n    \"\"\"\n    Like built-in bin(), except negative values are represented in\n    twos-compliment, and the leading bit always indicates sign\n    (0=positive, 1=negative).\n\n    >>> bin(10)\n    '0b0 1010'\n    >>> bin(~10)   # ~10 is -11\n    '0b1 0101'\n    \"\"\"\n\n    ceiling = 2 ** (num).bit_length()\n    if num >= 0:\n        s = bltns.bin(num + ceiling).replace('1', '0', 1)\n    else:\n        s = bltns.bin(~num ^ (ceiling - 1) + ceiling)\n    sign = s[:3]\n    digits = s[3:]\n    if max_bits is not None:\n        if len(digits) < max_bits:\n            digits = (sign[-1] * max_bits + digits)[-max_bits:]\n    return \"%s %s\" % (sign, digits)\n\ndef _dedent(text):\n    \"\"\"\n    Like textwrap.dedent.  Rewritten because we cannot import textwrap.\n    \"\"\"\n    lines = text.split('\\n')\n    blanks = 0\n    for i, ch in enumerate(lines[0]):\n        if ch != ' ':\n            break\n    for j, l in enumerate(lines):\n        lines[j] = l[i:]\n    return '\\n'.join(lines)\n\nclass _auto_null:\n    def __repr__(self):\n        return '_auto_null'\n_auto_null = _auto_null()\n\nclass auto:\n    \"\"\"\n    Instances are replaced with an appropriate value in Enum class suites.\n    \"\"\"\n    value = _auto_null\n\n    def __repr__(self):\n        return \"auto(%r)\" % self.value\n\nclass property(DynamicClassAttribute):\n    \"\"\"\n    This is a descriptor, used to define attributes that act differently\n    when accessed through an enum member and through an enum class.\n    Instance access is the same as property(), but access to an attribute\n    through the enum class will instead look in the class' _member_map_ for\n    a corresponding enum member.\n    \"\"\"\n\n    def __get__(self, instance, ownerclass=None):\n        if instance is None:\n            try:\n                return ownerclass._member_map_[self.name]\n            except KeyError:\n                raise AttributeError(\n                        '%r has no attribute %r' % (ownerclass, self.name)\n                        )\n        else:\n            if self.fget is None:\n                raise AttributeError(\n                        '%r member has no attribute %r' % (ownerclass, self.name)\n                        )\n            else:\n                return self.fget(instance)\n\n    def __set__(self, instance, value):\n        if self.fset is None:\n            raise AttributeError(\n                    \"<enum %r> cannot set attribute %r\" % (self.clsname, self.name)\n                    )\n        else:\n            return self.fset(instance, value)\n\n    def __delete__(self, instance):\n        if self.fdel is None:\n            raise AttributeError(\n                    \"<enum %r> cannot delete attribute %r\" % (self.clsname, self.name)\n                    )\n        else:\n            return self.fdel(instance)\n\n    def __set_name__(self, ownerclass, name):\n        self.name = name\n        self.clsname = ownerclass.__name__\n\n\nclass _proto_member:\n    \"\"\"\n    intermediate step for enum members between class execution and final creation\n    \"\"\"\n\n    def __init__(self, value):\n        self.value = value\n\n    def __set_name__(self, enum_class, member_name):\n        \"\"\"\n        convert each quasi-member into an instance of the new enum class\n        \"\"\"\n        # first step: remove ourself from enum_class\n        delattr(enum_class, member_name)\n        # second step: create member based on enum_class\n        value = self.value\n        if not isinstance(value, tuple):\n            args = (value, )\n        else:\n            args = value\n        if enum_class._member_type_ is tuple:   # special case for tuple enums\n            args = (args, )     # wrap it one more time\n        if not enum_class._use_args_:\n            enum_member = enum_class._new_member_(enum_class)\n            if not hasattr(enum_member, '_value_'):\n                try:\n                    enum_member._value_ = enum_class._member_type_(*args)\n                except Exception as exc:\n                    enum_member._value_ = value\n        else:\n            enum_member = enum_class._new_member_(enum_class, *args)\n            if not hasattr(enum_member, '_value_'):\n                if enum_class._member_type_ is object:\n                    enum_member._value_ = value\n                else:\n                    try:\n                        enum_member._value_ = enum_class._member_type_(*args)\n                    except Exception as exc:\n                        raise TypeError(\n                                '_value_ not set in __new__, unable to create it'\n                                ) from None\n        value = enum_member._value_\n        enum_member._name_ = member_name\n        enum_member.__objclass__ = enum_class\n        enum_member.__init__(*args)\n        enum_member._sort_order_ = len(enum_class._member_names_)\n        # If another member with the same value was already defined, the\n        # new member becomes an alias to the existing one.\n        try:\n            try:\n                # try to do a fast lookup to avoid the quadratic loop\n                enum_member = enum_class._value2member_map_[value]\n            except TypeError:\n                for name, canonical_member in enum_class._member_map_.items():\n                    if canonical_member._value_ == value:\n                        enum_member = canonical_member\n                        break\n                else:\n                    raise KeyError\n        except KeyError:\n            # this could still be an alias if the value is multi-bit and the\n            # class is a flag class\n            if (\n                    Flag is None\n                    or not issubclass(enum_class, Flag)\n                ):\n                # no other instances found, record this member in _member_names_\n                enum_class._member_names_.append(member_name)\n            elif (\n                    Flag is not None\n                    and issubclass(enum_class, Flag)\n                    and _is_single_bit(value)\n                ):\n                # no other instances found, record this member in _member_names_\n                enum_class._member_names_.append(member_name)\n        # get redirect in place before adding to _member_map_\n        # but check for other instances in parent classes first\n        need_override = False\n        descriptor = None\n        for base in enum_class.__mro__[1:]:\n            descriptor = base.__dict__.get(member_name)\n            if descriptor is not None:\n                if isinstance(descriptor, (property, DynamicClassAttribute)):\n                    break\n                else:\n                    need_override = True\n                    # keep looking for an enum.property\n        if descriptor and not need_override:\n            # previous enum.property found, no further action needed\n            pass\n        elif descriptor and need_override:\n            redirect = property()\n            redirect.__set_name__(enum_class, member_name)\n            # Previous enum.property found, but some other inherited attribute\n            # is in the way; copy fget, fset, fdel to this one.\n            redirect.fget = descriptor.fget\n            redirect.fset = descriptor.fset\n            redirect.fdel = descriptor.fdel\n            setattr(enum_class, member_name, redirect)\n        else:\n            setattr(enum_class, member_name, enum_member)\n        # now add to _member_map_ (even aliases)\n        enum_class._member_map_[member_name] = enum_member\n        try:\n            # This may fail if value is not hashable. We can't add the value\n            # to the map, and by-value lookups for this value will be\n            # linear.\n            enum_class._value2member_map_.setdefault(value, enum_member)\n        except TypeError:\n            # keep track of the value in a list so containment checks are quick\n            enum_class._unhashable_values_.append(value)\n\n\nclass _EnumDict(dict):\n    \"\"\"\n    Track enum member order and ensure member names are not reused.\n\n    EnumType will use the names found in self._member_names as the\n    enumeration member names.\n    \"\"\"\n    def __init__(self):\n        super().__init__()\n        self._member_names = {} # use a dict to keep insertion order\n        self._last_values = []\n        self._ignore = []\n        self._auto_called = False\n\n    def __setitem__(self, key, value):\n        \"\"\"\n        Changes anything not dundered or not a descriptor.\n\n        If an enum member name is used twice, an error is raised; duplicate\n        values are not checked for.\n\n        Single underscore (sunder) names are reserved.\n        \"\"\"\n        if _is_internal_class(self._cls_name, value):\n            import warnings\n            warnings.warn(\n                    \"In 3.13 classes created inside an enum will not become a member.  \"\n                    \"Use the `member` decorator to keep the current behavior.\",\n                    DeprecationWarning,\n                    stacklevel=2,\n                    )\n        if _is_private(self._cls_name, key):\n            # also do nothing, name will be a normal attribute\n            pass\n        elif _is_sunder(key):\n            if key not in (\n                    '_order_',\n                    '_generate_next_value_', '_numeric_repr_', '_missing_', '_ignore_',\n                    '_iter_member_', '_iter_member_by_value_', '_iter_member_by_def_',\n                    ):\n                raise ValueError(\n                        '_sunder_ names, such as %r, are reserved for future Enum use'\n                        % (key, )\n                        )\n            if key == '_generate_next_value_':\n                # check if members already defined as auto()\n                if self._auto_called:\n                    raise TypeError(\"_generate_next_value_ must be defined before members\")\n                _gnv = value.__func__ if isinstance(value, staticmethod) else value\n                setattr(self, '_generate_next_value', _gnv)\n            elif key == '_ignore_':\n                if isinstance(value, str):\n                    value = value.replace(',',' ').split()\n                else:\n                    value = list(value)\n                self._ignore = value\n                already = set(value) & set(self._member_names)\n                if already:\n                    raise ValueError(\n                            '_ignore_ cannot specify already set names: %r'\n                            % (already, )\n                            )\n        elif _is_dunder(key):\n            if key == '__order__':\n                key = '_order_'\n        elif key in self._member_names:\n            # descriptor overwriting an enum?\n            raise TypeError('%r already defined as %r' % (key, self[key]))\n        elif key in self._ignore:\n            pass\n        elif isinstance(value, nonmember):\n            # unwrap value here; it won't be processed by the below `else`\n            value = value.value\n        elif _is_descriptor(value):\n            pass\n        # TODO: uncomment next three lines in 3.12\n        # elif _is_internal_class(self._cls_name, value):\n        #     # do nothing, name will be a normal attribute\n        #     pass\n        else:\n            if key in self:\n                # enum overwriting a descriptor?\n                raise TypeError('%r already defined as %r' % (key, self[key]))\n            elif isinstance(value, member):\n                # unwrap value here -- it will become a member\n                value = value.value\n            if isinstance(value, auto):\n                if value.value == _auto_null:\n                    value.value = self._generate_next_value(\n                            key, 1, len(self._member_names), self._last_values[:],\n                            )\n                    self._auto_called = True\n                value = value.value\n            self._member_names[key] = None\n            self._last_values.append(value)\n        super().__setitem__(key, value)\n\n    def update(self, members, **more_members):\n        try:\n            for name in members.keys():\n                self[name] = members[name]\n        except AttributeError:\n            for name, value in members:\n                self[name] = value\n        for name, value in more_members.items():\n            self[name] = value\n\n\nclass EnumType(type):\n    \"\"\"\n    Metaclass for Enum\n    \"\"\"\n\n    @classmethod\n    def __prepare__(metacls, cls, bases, **kwds):\n        # check that previous enum members do not exist\n        metacls._check_for_existing_members_(cls, bases)\n        # create the namespace dict\n        enum_dict = _EnumDict()\n        enum_dict._cls_name = cls\n        # inherit previous flags and _generate_next_value_ function\n        member_type, first_enum = metacls._get_mixins_(cls, bases)\n        if first_enum is not None:\n            enum_dict['_generate_next_value_'] = getattr(\n                    first_enum, '_generate_next_value_', None,\n                    )\n        return enum_dict\n\n    def __new__(metacls, cls, bases, classdict, *, boundary=None, _simple=False, **kwds):\n        # an Enum class is final once enumeration items have been defined; it\n        # cannot be mixed with other types (int, float, etc.) if it has an\n        # inherited __new__ unless a new __new__ is defined (or the resulting\n        # class will fail).\n        #\n        if _simple:\n            return super().__new__(metacls, cls, bases, classdict, **kwds)\n        #\n        # remove any keys listed in _ignore_\n        classdict.setdefault('_ignore_', []).append('_ignore_')\n        ignore = classdict['_ignore_']\n        for key in ignore:\n            classdict.pop(key, None)\n        #\n        # grab member names\n        member_names = classdict._member_names\n        #\n        # check for illegal enum names (any others?)\n        invalid_names = set(member_names) & {'mro', ''}\n        if invalid_names:\n            raise ValueError('invalid enum member name(s) %s'  % (\n                    ','.join(repr(n) for n in invalid_names)\n                    ))\n        #\n        # adjust the sunders\n        _order_ = classdict.pop('_order_', None)\n        # convert to normal dict\n        classdict = dict(classdict.items())\n        #\n        # data type of member and the controlling Enum class\n        member_type, first_enum = metacls._get_mixins_(cls, bases)\n        __new__, save_new, use_args = metacls._find_new_(\n                classdict, member_type, first_enum,\n                )\n        classdict['_new_member_'] = __new__\n        classdict['_use_args_'] = use_args\n        #\n        # convert future enum members into temporary _proto_members\n        # and record integer values in case this will be a Flag\n        flag_mask = 0\n        for name in member_names:\n            value = classdict[name]\n            if isinstance(value, int):\n                flag_mask |= value\n            classdict[name] = _proto_member(value)\n        #\n        # house-keeping structures\n        classdict['_member_names_'] = []\n        classdict['_member_map_'] = {}\n        classdict['_value2member_map_'] = {}\n        classdict['_unhashable_values_'] = []\n        classdict['_member_type_'] = member_type\n        # now set the __repr__ for the value\n        classdict['_value_repr_'] = metacls._find_data_repr_(cls, bases)\n        #\n        # Flag structures (will be removed if final class is not a Flag\n        classdict['_boundary_'] = (\n                boundary\n                or getattr(first_enum, '_boundary_', None)\n                )\n        classdict['_flag_mask_'] = flag_mask\n        classdict['_all_bits_'] = 2 ** ((flag_mask).bit_length()) - 1\n        classdict['_inverted_'] = None\n        try:\n            exc = None\n            enum_class = super().__new__(metacls, cls, bases, classdict, **kwds)\n        except RuntimeError as e:\n            # any exceptions raised by member.__new__ will get converted to a\n            # RuntimeError, so get that original exception back and raise it instead\n            exc = e.__cause__ or e\n        if exc is not None:\n            raise exc\n        #\n        # update classdict with any changes made by __init_subclass__\n        classdict.update(enum_class.__dict__)\n        #\n        # double check that repr and friends are not the mixin's or various\n        # things break (such as pickle)\n        # however, if the method is defined in the Enum itself, don't replace\n        # it\n        #\n        # Also, special handling for ReprEnum\n        if ReprEnum is not None and ReprEnum in bases:\n            if member_type is object:\n                raise TypeError(\n                        'ReprEnum subclasses must be mixed with a data type (i.e.'\n                        ' int, str, float, etc.)'\n                        )\n            if '__format__' not in classdict:\n                enum_class.__format__ = member_type.__format__\n                classdict['__format__'] = enum_class.__format__\n            if '__str__' not in classdict:\n                method = member_type.__str__\n                if method is object.__str__:\n                    # if member_type does not define __str__, object.__str__ will use\n                    # its __repr__ instead, so we'll also use its __repr__\n                    method = member_type.__repr__\n                enum_class.__str__ = method\n                classdict['__str__'] = enum_class.__str__\n        for name in ('__repr__', '__str__', '__format__', '__reduce_ex__'):\n            if name not in classdict:\n                # check for mixin overrides before replacing\n                enum_method = getattr(first_enum, name)\n                found_method = getattr(enum_class, name)\n                object_method = getattr(object, name)\n                data_type_method = getattr(member_type, name)\n                if found_method in (data_type_method, object_method):\n                    setattr(enum_class, name, enum_method)\n        #\n        # for Flag, add __or__, __and__, __xor__, and __invert__\n        if Flag is not None and issubclass(enum_class, Flag):\n            for name in (\n                    '__or__', '__and__', '__xor__',\n                    '__ror__', '__rand__', '__rxor__',\n                    '__invert__'\n                ):\n                if name not in classdict:\n                    enum_method = getattr(Flag, name)\n                    setattr(enum_class, name, enum_method)\n                    classdict[name] = enum_method\n        #\n        # replace any other __new__ with our own (as long as Enum is not None,\n        # anyway) -- again, this is to support pickle\n        if Enum is not None:\n            # if the user defined their own __new__, save it before it gets\n            # clobbered in case they subclass later\n            if save_new:\n                enum_class.__new_member__ = __new__\n            enum_class.__new__ = Enum.__new__\n        #\n        # py3 support for definition order (helps keep py2/py3 code in sync)\n        #\n        # _order_ checking is spread out into three/four steps\n        # - if enum_class is a Flag:\n        #   - remove any non-single-bit flags from _order_\n        # - remove any aliases from _order_\n        # - check that _order_ and _member_names_ match\n        #\n        # step 1: ensure we have a list\n        if _order_ is not None:\n            if isinstance(_order_, str):\n                _order_ = _order_.replace(',', ' ').split()\n        #\n        # remove Flag structures if final class is not a Flag\n        if (\n                Flag is None and cls != 'Flag'\n                or Flag is not None and not issubclass(enum_class, Flag)\n            ):\n            delattr(enum_class, '_boundary_')\n            delattr(enum_class, '_flag_mask_')\n            delattr(enum_class, '_all_bits_')\n            delattr(enum_class, '_inverted_')\n        elif Flag is not None and issubclass(enum_class, Flag):\n            # ensure _all_bits_ is correct and there are no missing flags\n            single_bit_total = 0\n            multi_bit_total = 0\n            for flag in enum_class._member_map_.values():\n                flag_value = flag._value_\n                if _is_single_bit(flag_value):\n                    single_bit_total |= flag_value\n                else:\n                    # multi-bit flags are considered aliases\n                    multi_bit_total |= flag_value\n            enum_class._flag_mask_ = single_bit_total\n            #\n            # set correct __iter__\n            member_list = [m._value_ for m in enum_class]\n            if member_list != sorted(member_list):\n                enum_class._iter_member_ = enum_class._iter_member_by_def_\n            if _order_:\n                # _order_ step 2: remove any items from _order_ that are not single-bit\n                _order_ = [\n                        o\n                        for o in _order_\n                        if o not in enum_class._member_map_ or _is_single_bit(enum_class[o]._value_)\n                        ]\n        #\n        if _order_:\n            # _order_ step 3: remove aliases from _order_\n            _order_ = [\n                    o\n                    for o in _order_\n                    if (\n                        o not in enum_class._member_map_\n                        or\n                        (o in enum_class._member_map_ and o in enum_class._member_names_)\n                        )]\n            # _order_ step 4: verify that _order_ and _member_names_ match\n            if _order_ != enum_class._member_names_:\n                raise TypeError(\n                        'member order does not match _order_:\\n  %r\\n  %r'\n                        % (enum_class._member_names_, _order_)\n                        )\n\n        return enum_class\n\n    def __bool__(cls):\n        \"\"\"\n        classes/types should always be True.\n        \"\"\"\n        return True\n\n    def __call__(cls, value, names=None, *, module=None, qualname=None, type=None, start=1, boundary=None):\n        \"\"\"\n        Either returns an existing member, or creates a new enum class.\n\n        This method is used both when an enum class is given a value to match\n        to an enumeration member (i.e. Color(3)) and for the functional API\n        (i.e. Color = Enum('Color', names='RED GREEN BLUE')).\n\n        When used for the functional API:\n\n        `value` will be the name of the new class.\n\n        `names` should be either a string of white-space/comma delimited names\n        (values will start at `start`), or an iterator/mapping of name, value pairs.\n\n        `module` should be set to the module this class is being created in;\n        if it is not set, an attempt to find that module will be made, but if\n        it fails the class will not be picklable.\n\n        `qualname` should be set to the actual location this class can be found\n        at in its module; by default it is set to the global scope.  If this is\n        not correct, unpickling will fail in some circumstances.\n\n        `type`, if set, will be mixed in as the first base class.\n        \"\"\"\n        if names is None:  # simple value lookup\n            return cls.__new__(cls, value)\n        # otherwise, functional API: we're creating a new Enum type\n        return cls._create_(\n                value,\n                names,\n                module=module,\n                qualname=qualname,\n                type=type,\n                start=start,\n                boundary=boundary,\n                )\n\n    def __contains__(cls, member):\n        \"\"\"\n        Return True if member is a member of this enum\n        raises TypeError if member is not an enum member\n\n        note: in 3.12 TypeError will no longer be raised, and True will also be\n        returned if member is the value of a member in this enum\n        \"\"\"\n        if not isinstance(member, Enum):\n            import warnings\n            warnings.warn(\n                    \"in 3.12 __contains__ will no longer raise TypeError, but will return True or\\n\"\n                    \"False depending on whether the value is a member or the value of a member\",\n                    DeprecationWarning,\n                    stacklevel=2,\n                    )\n            raise TypeError(\n                \"unsupported operand type(s) for 'in': '%s' and '%s'\" % (\n                    type(member).__qualname__, cls.__class__.__qualname__))\n        return isinstance(member, cls) and member._name_ in cls._member_map_\n\n    def __delattr__(cls, attr):\n        # nicer error message when someone tries to delete an attribute\n        # (see issue19025).\n        if attr in cls._member_map_:\n            raise AttributeError(\"%r cannot delete member %r.\" % (cls.__name__, attr))\n        super().__delattr__(attr)\n\n    def __dir__(cls):\n        interesting = set([\n                '__class__', '__contains__', '__doc__', '__getitem__',\n                '__iter__', '__len__', '__members__', '__module__',\n                '__name__', '__qualname__',\n                ]\n                + cls._member_names_\n                )\n        if cls._new_member_ is not object.__new__:\n            interesting.add('__new__')\n        if cls.__init_subclass__ is not object.__init_subclass__:\n            interesting.add('__init_subclass__')\n        if cls._member_type_ is object:\n            return sorted(interesting)\n        else:\n            # return whatever mixed-in data type has\n            return sorted(set(dir(cls._member_type_)) | interesting)\n\n    def __getattr__(cls, name):\n        \"\"\"\n        Return the enum member matching `name`\n\n        We use __getattr__ instead of descriptors or inserting into the enum\n        class' __dict__ in order to support `name` and `value` being both\n        properties for enum members (which live in the class' __dict__) and\n        enum members themselves.\n        \"\"\"\n        if _is_dunder(name):\n            raise AttributeError(name)\n        try:\n            return cls._member_map_[name]\n        except KeyError:\n            raise AttributeError(name) from None\n\n    def __getitem__(cls, name):\n        \"\"\"\n        Return the member matching `name`.\n        \"\"\"\n        return cls._member_map_[name]\n\n    def __iter__(cls):\n        \"\"\"\n        Return members in definition order.\n        \"\"\"\n        return (cls._member_map_[name] for name in cls._member_names_)\n\n    def __len__(cls):\n        \"\"\"\n        Return the number of members (no aliases)\n        \"\"\"\n        return len(cls._member_names_)\n\n    @bltns.property\n    def __members__(cls):\n        \"\"\"\n        Returns a mapping of member name->value.\n\n        This mapping lists all enum members, including aliases. Note that this\n        is a read-only view of the internal mapping.\n        \"\"\"\n        return MappingProxyType(cls._member_map_)\n\n    def __repr__(cls):\n        if Flag is not None and issubclass(cls, Flag):\n            return \"<flag %r>\" % cls.__name__\n        else:\n            return \"<enum %r>\" % cls.__name__\n\n    def __reversed__(cls):\n        \"\"\"\n        Return members in reverse definition order.\n        \"\"\"\n        return (cls._member_map_[name] for name in reversed(cls._member_names_))\n\n    def __setattr__(cls, name, value):\n        \"\"\"\n        Block attempts to reassign Enum members.\n\n        A simple assignment to the class namespace only changes one of the\n        several possible ways to get an Enum member from the Enum class,\n        resulting in an inconsistent Enumeration.\n        \"\"\"\n        member_map = cls.__dict__.get('_member_map_', {})\n        if name in member_map:\n            raise AttributeError('cannot reassign member %r' % (name, ))\n        super().__setattr__(name, value)\n\n    def _create_(cls, class_name, names, *, module=None, qualname=None, type=None, start=1, boundary=None):\n        \"\"\"\n        Convenience method to create a new Enum class.\n\n        `names` can be:\n\n        * A string containing member names, separated either with spaces or\n          commas.  Values are incremented by 1 from `start`.\n        * An iterable of member names.  Values are incremented by 1 from `start`.\n        * An iterable of (member name, value) pairs.\n        * A mapping of member name -> value pairs.\n        \"\"\"\n        metacls = cls.__class__\n        bases = (cls, ) if type is None else (type, cls)\n        _, first_enum = cls._get_mixins_(class_name, bases)\n        classdict = metacls.__prepare__(class_name, bases)\n\n        # special processing needed for names?\n        if isinstance(names, str):\n            names = names.replace(',', ' ').split()\n        if isinstance(names, (tuple, list)) and names and isinstance(names[0], str):\n            original_names, names = names, []\n            last_values = []\n            for count, name in enumerate(original_names):\n                value = first_enum._generate_next_value_(name, start, count, last_values[:])\n                last_values.append(value)\n                names.append((name, value))\n\n        # Here, names is either an iterable of (name, value) or a mapping.\n        for item in names:\n            if isinstance(item, str):\n                member_name, member_value = item, names[item]\n            else:\n                member_name, member_value = item\n            classdict[member_name] = member_value\n\n        # TODO: replace the frame hack if a blessed way to know the calling\n        # module is ever developed\n        if module is None:\n            try:\n                module = sys._getframe(2).f_globals['__name__']\n            except (AttributeError, ValueError, KeyError):\n                pass\n        if module is None:\n            _make_class_unpicklable(classdict)\n        else:\n            classdict['__module__'] = module\n        if qualname is not None:\n            classdict['__qualname__'] = qualname\n\n        return metacls.__new__(metacls, class_name, bases, classdict, boundary=boundary)\n\n    def _convert_(cls, name, module, filter, source=None, *, boundary=None, as_global=False):\n        \"\"\"\n        Create a new Enum subclass that replaces a collection of global constants\n        \"\"\"\n        # convert all constants from source (or module) that pass filter() to\n        # a new Enum called name, and export the enum and its members back to\n        # module;\n        # also, replace the __reduce_ex__ method so unpickling works in\n        # previous Python versions\n        module_globals = sys.modules[module].__dict__\n        if source:\n            source = source.__dict__\n        else:\n            source = module_globals\n        # _value2member_map_ is populated in the same order every time\n        # for a consistent reverse mapping of number to name when there\n        # are multiple names for the same number.\n        members = [\n                (name, value)\n                for name, value in source.items()\n                if filter(name)]\n        try:\n            # sort by value\n            members.sort(key=lambda t: (t[1], t[0]))\n        except TypeError:\n            # unless some values aren't comparable, in which case sort by name\n            members.sort(key=lambda t: t[0])\n        body = {t[0]: t[1] for t in members}\n        body['__module__'] = module\n        tmp_cls = type(name, (object, ), body)\n        cls = _simple_enum(etype=cls, boundary=boundary or KEEP)(tmp_cls)\n        cls.__reduce_ex__ = _reduce_ex_by_global_name\n        if as_global:\n            global_enum(cls)\n        else:\n            sys.modules[cls.__module__].__dict__.update(cls.__members__)\n        module_globals[name] = cls\n        return cls\n\n    @classmethod\n    def _check_for_existing_members_(mcls, class_name, bases):\n        for chain in bases:\n            for base in chain.__mro__:\n                if issubclass(base, Enum) and base._member_names_:\n                    raise TypeError(\n                            \"<enum %r> cannot extend %r\"\n                            % (class_name, base)\n                            )\n\n    @classmethod\n    def _get_mixins_(mcls, class_name, bases):\n        \"\"\"\n        Returns the type for creating enum members, and the first inherited\n        enum class.\n\n        bases: the tuple of bases that was given to __new__\n        \"\"\"\n        if not bases:\n            return object, Enum\n\n        mcls._check_for_existing_members_(class_name, bases)\n\n        # ensure final parent class is an Enum derivative, find any concrete\n        # data type, and check that Enum has no members\n        first_enum = bases[-1]\n        if not issubclass(first_enum, Enum):\n            raise TypeError(\"new enumerations should be created as \"\n                    \"`EnumName([mixin_type, ...] [data_type,] enum_type)`\")\n        member_type = mcls._find_data_type_(class_name, bases) or object\n        return member_type, first_enum\n\n    @classmethod\n    def _find_data_repr_(mcls, class_name, bases):\n        for chain in bases:\n            for base in chain.__mro__:\n                if base is object:\n                    continue\n                elif issubclass(base, Enum):\n                    # if we hit an Enum, use it's _value_repr_\n                    return base._value_repr_\n                elif '__repr__' in base.__dict__:\n                    # this is our data repr\n                    return base.__dict__['__repr__']\n        return None\n\n    @classmethod\n    def _find_data_type_(mcls, class_name, bases):\n        data_types = set()\n        base_chain = set()\n        for chain in bases:\n            candidate = None\n            for base in chain.__mro__:\n                base_chain.add(base)\n                if base is object:\n                    continue\n                elif issubclass(base, Enum):\n                    if base._member_type_ is not object:\n                        data_types.add(base._member_type_)\n                        break\n                elif '__new__' in base.__dict__ or '__init__' in base.__dict__:\n                    if issubclass(base, Enum):\n                        continue\n                    data_types.add(candidate or base)\n                    break\n                else:\n                    candidate = candidate or base\n        if len(data_types) > 1:\n            raise TypeError('too many data types for %r: %r' % (class_name, data_types))\n        elif data_types:\n            return data_types.pop()\n        else:\n            return None\n\n    @classmethod\n    def _find_new_(mcls, classdict, member_type, first_enum):\n        \"\"\"\n        Returns the __new__ to be used for creating the enum members.\n\n        classdict: the class dictionary given to __new__\n        member_type: the data type whose __new__ will be used by default\n        first_enum: enumeration to check for an overriding __new__\n        \"\"\"\n        # now find the correct __new__, checking to see of one was defined\n        # by the user; also check earlier enum classes in case a __new__ was\n        # saved as __new_member__\n        __new__ = classdict.get('__new__', None)\n\n        # should __new__ be saved as __new_member__ later?\n        save_new = first_enum is not None and __new__ is not None\n\n        if __new__ is None:\n            # check all possibles for __new_member__ before falling back to\n            # __new__\n            for method in ('__new_member__', '__new__'):\n                for possible in (member_type, first_enum):\n                    target = getattr(possible, method, None)\n                    if target not in {\n                            None,\n                            None.__new__,\n                            object.__new__,\n                            Enum.__new__,\n                            }:\n                        __new__ = target\n                        break\n                if __new__ is not None:\n                    break\n            else:\n                __new__ = object.__new__\n\n        # if a non-object.__new__ is used then whatever value/tuple was\n        # assigned to the enum member name will be passed to __new__ and to the\n        # new enum member's __init__\n        if first_enum is None or __new__ in (Enum.__new__, object.__new__):\n            use_args = False\n        else:\n            use_args = True\n        return __new__, save_new, use_args\nEnumMeta = EnumType\n\n\nclass Enum(metaclass=EnumType):\n    \"\"\"\n    Create a collection of name/value pairs.\n\n    Example enumeration:\n\n    >>> class Color(Enum):\n    ...     RED = 1\n    ...     BLUE = 2\n    ...     GREEN = 3\n\n    Access them by:\n\n    - attribute access::\n\n    >>> Color.RED\n    <Color.RED: 1>\n\n    - value lookup:\n\n    >>> Color(1)\n    <Color.RED: 1>\n\n    - name lookup:\n\n    >>> Color['RED']\n    <Color.RED: 1>\n\n    Enumerations can be iterated over, and know how many members they have:\n\n    >>> len(Color)\n    3\n\n    >>> list(Color)\n    [<Color.RED: 1>, <Color.BLUE: 2>, <Color.GREEN: 3>]\n\n    Methods can be added to enumerations, and members can have their own\n    attributes -- see the documentation for details.\n    \"\"\"\n\n    def __new__(cls, value):\n        # all enum instances are actually created during class construction\n        # without calling this method; this method is called by the metaclass'\n        # __call__ (i.e. Color(3) ), and by pickle\n        if type(value) is cls:\n            # For lookups like Color(Color.RED)\n            return value\n        # by-value search for a matching enum member\n        # see if it's in the reverse mapping (for hashable values)\n        try:\n            return cls._value2member_map_[value]\n        except KeyError:\n            # Not found, no need to do long O(n) search\n            pass\n        except TypeError:\n            # not there, now do long search -- O(n) behavior\n            for member in cls._member_map_.values():\n                if member._value_ == value:\n                    return member\n        # still not found -- try _missing_ hook\n        try:\n            exc = None\n            result = cls._missing_(value)\n        except Exception as e:\n            exc = e\n            result = None\n        try:\n            if isinstance(result, cls):\n                return result\n            elif (\n                    Flag is not None and issubclass(cls, Flag)\n                    and cls._boundary_ is EJECT and isinstance(result, int)\n                ):\n                return result\n            else:\n                ve_exc = ValueError(\"%r is not a valid %s\" % (value, cls.__qualname__))\n                if result is None and exc is None:\n                    raise ve_exc\n                elif exc is None:\n                    exc = TypeError(\n                            'error in %s._missing_: returned %r instead of None or a valid member'\n                            % (cls.__name__, result)\n                            )\n                if not isinstance(exc, ValueError):\n                    exc.__context__ = ve_exc\n                raise exc\n        finally:\n            # ensure all variables that could hold an exception are destroyed\n            exc = None\n            ve_exc = None\n\n    def __init__(self, *args, **kwds):\n        pass\n\n    def _generate_next_value_(name, start, count, last_values):\n        \"\"\"\n        Generate the next value when not given.\n\n        name: the name of the member\n        start: the initial start value or None\n        count: the number of existing members\n        last_values: the list of values assigned\n        \"\"\"\n        if not last_values:\n            return start\n        try:\n            last = last_values[-1]\n            last_values.sort()\n            if last == last_values[-1]:\n                # no difference between old and new methods\n                return last + 1\n            else:\n                # trigger old method (with warning)\n                raise TypeError\n        except TypeError:\n            import warnings\n            warnings.warn(\n                    \"In 3.13 the default `auto()`/`_generate_next_value_` will require all values to be sortable and support adding +1\\n\"\n                    \"and the value returned will be the largest value in the enum incremented by 1\",\n                    DeprecationWarning,\n                    stacklevel=3,\n                    )\n            for v in last_values:\n                try:\n                    return v + 1\n                except TypeError:\n                    pass\n            return start\n\n    @classmethod\n    def _missing_(cls, value):\n        return None\n\n    def __repr__(self):\n        v_repr = self.__class__._value_repr_ or repr\n        return \"<%s.%s: %s>\" % (self.__class__.__name__, self._name_, v_repr(self._value_))\n\n    def __str__(self):\n        return \"%s.%s\" % (self.__class__.__name__, self._name_, )\n\n    def __dir__(self):\n        \"\"\"\n        Returns all members and all public methods\n        \"\"\"\n        if self.__class__._member_type_ is object:\n            interesting = set(['__class__', '__doc__', '__eq__', '__hash__', '__module__', 'name', 'value'])\n        else:\n            interesting = set(object.__dir__(self))\n        for name in getattr(self, '__dict__', []):\n            if name[0] != '_':\n                interesting.add(name)\n        for cls in self.__class__.mro():\n            for name, obj in cls.__dict__.items():\n                if name[0] == '_':\n                    continue\n                if isinstance(obj, property):\n                    # that's an enum.property\n                    if obj.fget is not None or name not in self._member_map_:\n                        interesting.add(name)\n                    else:\n                        # in case it was added by `dir(self)`\n                        interesting.discard(name)\n                else:\n                    interesting.add(name)\n        names = sorted(\n                set(['__class__', '__doc__', '__eq__', '__hash__', '__module__'])\n                | interesting\n                )\n        return names\n\n    def __format__(self, format_spec):\n        return str.__format__(str(self), format_spec)\n\n    def __hash__(self):\n        return hash(self._name_)\n\n    def __reduce_ex__(self, proto):\n        return getattr, (self.__class__, self._name_)\n\n    # enum.property is used to provide access to the `name` and\n    # `value` attributes of enum members while keeping some measure of\n    # protection from modification, while still allowing for an enumeration\n    # to have members named `name` and `value`.  This works because enumeration\n    # members are not set directly on the enum class; they are kept in a\n    # separate structure, _member_map_, which is where enum.property looks for\n    # them\n\n    @property\n    def name(self):\n        \"\"\"The name of the Enum member.\"\"\"\n        return self._name_\n\n    @property\n    def value(self):\n        \"\"\"The value of the Enum member.\"\"\"\n        return self._value_\n\n\nclass ReprEnum(Enum):\n    \"\"\"\n    Only changes the repr(), leaving str() and format() to the mixed-in type.\n    \"\"\"\n\n\nclass IntEnum(int, ReprEnum):\n    \"\"\"\n    Enum where members are also (and must be) ints\n    \"\"\"\n\n\nclass StrEnum(str, ReprEnum):\n    \"\"\"\n    Enum where members are also (and must be) strings\n    \"\"\"\n\n    def __new__(cls, *values):\n        \"values must already be of type `str`\"\n        if len(values) > 3:\n            raise TypeError('too many arguments for str(): %r' % (values, ))\n        if len(values) == 1:\n            # it must be a string\n            if not isinstance(values[0], str):\n                raise TypeError('%r is not a string' % (values[0], ))\n        if len(values) >= 2:\n            # check that encoding argument is a string\n            if not isinstance(values[1], str):\n                raise TypeError('encoding must be a string, not %r' % (values[1], ))\n        if len(values) == 3:\n            # check that errors argument is a string\n            if not isinstance(values[2], str):\n                raise TypeError('errors must be a string, not %r' % (values[2]))\n        value = str(*values)\n        member = str.__new__(cls, value)\n        member._value_ = value\n        return member\n\n    def _generate_next_value_(name, start, count, last_values):\n        \"\"\"\n        Return the lower-cased version of the member name.\n        \"\"\"\n        return name.lower()\n\n\ndef _reduce_ex_by_global_name(self, proto):\n    return self.name\n\nclass FlagBoundary(StrEnum):\n    \"\"\"\n    control how out of range values are handled\n    \"strict\" -> error is raised  [default for Flag]\n    \"conform\" -> extra bits are discarded\n    \"eject\" -> lose flag status [default for IntFlag]\n    \"keep\" -> keep flag status and all bits\n    \"\"\"\n    STRICT = auto()\n    CONFORM = auto()\n    EJECT = auto()\n    KEEP = auto()\nSTRICT, CONFORM, EJECT, KEEP = FlagBoundary\n\n\nclass Flag(Enum, boundary=CONFORM):\n    \"\"\"\n    Support for flags\n    \"\"\"\n\n    def __reduce_ex__(self, proto):\n        cls = self.__class__\n        unknown = self._value_ & ~cls._flag_mask_\n        member_value = self._value_ & cls._flag_mask_\n        if unknown and member_value:\n            return _or_, (cls(member_value), unknown)\n        for val in _iter_bits_lsb(member_value):\n            rest = member_value & ~val\n            if rest:\n                return _or_, (cls(rest), cls._value2member_map_.get(val))\n            else:\n                break\n        if self._name_ is None:\n            return cls, (self._value_,)\n        else:\n            return getattr, (cls, self._name_)\n\n    _numeric_repr_ = repr\n\n    def _generate_next_value_(name, start, count, last_values):\n        \"\"\"\n        Generate the next value when not given.\n\n        name: the name of the member\n        start: the initial start value or None\n        count: the number of existing members\n        last_values: the last value assigned or None\n        \"\"\"\n        if not count:\n            return start if start is not None else 1\n        last_value = max(last_values)\n        try:\n            high_bit = _high_bit(last_value)\n        except Exception:\n            raise TypeError('invalid flag value %r' % last_value) from None\n        return 2 ** (high_bit+1)\n\n    @classmethod\n    def _iter_member_by_value_(cls, value):\n        \"\"\"\n        Extract all members from the value in definition (i.e. increasing value) order.\n        \"\"\"\n        for val in _iter_bits_lsb(value & cls._flag_mask_):\n            yield cls._value2member_map_.get(val)\n\n    _iter_member_ = _iter_member_by_value_\n\n    @classmethod\n    def _iter_member_by_def_(cls, value):\n        \"\"\"\n        Extract all members from the value in definition order.\n        \"\"\"\n        yield from sorted(\n                cls._iter_member_by_value_(value),\n                key=lambda m: m._sort_order_,\n                )\n\n    @classmethod\n    def _missing_(cls, value):\n        \"\"\"\n        Create a composite member containing all canonical members present in `value`.\n\n        If non-member values are present, result depends on `_boundary_` setting.\n        \"\"\"\n        if not isinstance(value, int):\n            raise ValueError(\n                    \"%r is not a valid %s\" % (value, cls.__qualname__)\n                    )\n        # check boundaries\n        # - value must be in range (e.g. -16 <-> +15, i.e. ~15 <-> 15)\n        # - value must not include any skipped flags (e.g. if bit 2 is not\n        #   defined, then 0d10 is invalid)\n        flag_mask = cls._flag_mask_\n        all_bits = cls._all_bits_\n        neg_value = None\n        if (\n                not ~all_bits <= value <= all_bits\n                or value & (all_bits ^ flag_mask)\n            ):\n            if cls._boundary_ is STRICT:\n                max_bits = max(value.bit_length(), flag_mask.bit_length())\n                raise ValueError(\n                        \"%r invalid value %r\\n    given %s\\n  allowed %s\" % (\n                            cls, value, bin(value, max_bits), bin(flag_mask, max_bits),\n                            ))\n            elif cls._boundary_ is CONFORM:\n                value = value & flag_mask\n            elif cls._boundary_ is EJECT:\n                return value\n            elif cls._boundary_ is KEEP:\n                if value < 0:\n                    value = (\n                            max(all_bits+1, 2**(value.bit_length()))\n                            + value\n                            )\n            else:\n                raise ValueError(\n                        '%r unknown flag boundary %r' % (cls, cls._boundary_, )\n                        )\n        if value < 0:\n            neg_value = value\n            value = all_bits + 1 + value\n        # get members and unknown\n        unknown = value & ~flag_mask\n        member_value = value & flag_mask\n        if unknown and cls._boundary_ is not KEEP:\n            raise ValueError(\n                    '%s(%r) -->  unknown values %r [%s]'\n                    % (cls.__name__, value, unknown, bin(unknown))\n                    )\n        # normal Flag?\n        __new__ = getattr(cls, '__new_member__', None)\n        if cls._member_type_ is object and not __new__:\n            # construct a singleton enum pseudo-member\n            pseudo_member = object.__new__(cls)\n        else:\n            pseudo_member = (__new__ or cls._member_type_.__new__)(cls, value)\n        if not hasattr(pseudo_member, '_value_'):\n            pseudo_member._value_ = value\n        if member_value:\n            pseudo_member._name_ = '|'.join([\n                m._name_ for m in cls._iter_member_(member_value)\n                ])\n            if unknown:\n                pseudo_member._name_ += '|%s' % cls._numeric_repr_(unknown)\n        else:\n            pseudo_member._name_ = None\n        # use setdefault in case another thread already created a composite\n        # with this value, but only if all members are known\n        # note: zero is a special case -- add it\n        if not unknown:\n            pseudo_member = cls._value2member_map_.setdefault(value, pseudo_member)\n            if neg_value is not None:\n                cls._value2member_map_[neg_value] = pseudo_member\n        return pseudo_member\n\n    def __contains__(self, other):\n        \"\"\"\n        Returns True if self has at least the same flags set as other.\n        \"\"\"\n        if not isinstance(other, self.__class__):\n            raise TypeError(\n                \"unsupported operand type(s) for 'in': %r and %r\" % (\n                    type(other).__qualname__, self.__class__.__qualname__))\n        return other._value_ & self._value_ == other._value_\n\n    def __iter__(self):\n        \"\"\"\n        Returns flags in definition order.\n        \"\"\"\n        yield from self._iter_member_(self._value_)\n\n    def __len__(self):\n        return self._value_.bit_count()\n\n    def __repr__(self):\n        cls_name = self.__class__.__name__\n        v_repr = self.__class__._value_repr_ or repr\n        if self._name_ is None:\n            return \"<%s: %s>\" % (cls_name, v_repr(self._value_))\n        else:\n            return \"<%s.%s: %s>\" % (cls_name, self._name_, v_repr(self._value_))\n\n    def __str__(self):\n        cls_name = self.__class__.__name__\n        if self._name_ is None:\n            return '%s(%r)' % (cls_name, self._value_)\n        else:\n            return \"%s.%s\" % (cls_name, self._name_)\n\n    def __bool__(self):\n        return bool(self._value_)\n\n    def __or__(self, other):\n        if isinstance(other, self.__class__):\n            other = other._value_\n        elif self._member_type_ is not object and isinstance(other, self._member_type_):\n            other = other\n        else:\n            return NotImplemented\n        value = self._value_\n        return self.__class__(value | other)\n\n    def __and__(self, other):\n        if isinstance(other, self.__class__):\n            other = other._value_\n        elif self._member_type_ is not object and isinstance(other, self._member_type_):\n            other = other\n        else:\n            return NotImplemented\n        value = self._value_\n        return self.__class__(value & other)\n\n    def __xor__(self, other):\n        if isinstance(other, self.__class__):\n            other = other._value_\n        elif self._member_type_ is not object and isinstance(other, self._member_type_):\n            other = other\n        else:\n            return NotImplemented\n        value = self._value_\n        return self.__class__(value ^ other)\n\n    def __invert__(self):\n        if self._inverted_ is None:\n            if self._boundary_ is KEEP:\n                # use all bits\n                self._inverted_ = self.__class__(~self._value_)\n            else:\n                # calculate flags not in this member\n                self._inverted_ = self.__class__(self._flag_mask_ ^ self._value_)\n            if isinstance(self._inverted_, self.__class__):\n                self._inverted_._inverted_ = self\n        return self._inverted_\n\n    __rand__ = __and__\n    __ror__ = __or__\n    __rxor__ = __xor__\n\n\nclass IntFlag(int, ReprEnum, Flag, boundary=KEEP):\n    \"\"\"\n    Support for integer-based Flags\n    \"\"\"\n\n\ndef _high_bit(value):\n    \"\"\"\n    returns index of highest bit, or -1 if value is zero or negative\n    \"\"\"\n    return value.bit_length() - 1\n\ndef unique(enumeration):\n    \"\"\"\n    Class decorator for enumerations ensuring unique member values.\n    \"\"\"\n    duplicates = []\n    for name, member in enumeration.__members__.items():\n        if name != member.name:\n            duplicates.append((name, member.name))\n    if duplicates:\n        alias_details = ', '.join(\n                [\"%s -> %s\" % (alias, name) for (alias, name) in duplicates])\n        raise ValueError('duplicate values found in %r: %s' %\n                (enumeration, alias_details))\n    return enumeration\n\ndef _power_of_two(value):\n    if value < 1:\n        return False\n    return value == 2 ** _high_bit(value)\n\ndef global_enum_repr(self):\n    \"\"\"\n    use module.enum_name instead of class.enum_name\n\n    the module is the last module in case of a multi-module name\n    \"\"\"\n    module = self.__class__.__module__.split('.')[-1]\n    return '%s.%s' % (module, self._name_)\n\ndef global_flag_repr(self):\n    \"\"\"\n    use module.flag_name instead of class.flag_name\n\n    the module is the last module in case of a multi-module name\n    \"\"\"\n    module = self.__class__.__module__.split('.')[-1]\n    cls_name = self.__class__.__name__\n    if self._name_ is None:\n        return \"%s.%s(%r)\" % (module, cls_name, self._value_)\n    if _is_single_bit(self):\n        return '%s.%s' % (module, self._name_)\n    if self._boundary_ is not FlagBoundary.KEEP:\n        return '|'.join(['%s.%s' % (module, name) for name in self.name.split('|')])\n    else:\n        name = []\n        for n in self._name_.split('|'):\n            if n[0].isdigit():\n                name.append(n)\n            else:\n                name.append('%s.%s' % (module, n))\n        return '|'.join(name)\n\ndef global_str(self):\n    \"\"\"\n    use enum_name instead of class.enum_name\n    \"\"\"\n    if self._name_ is None:\n        cls_name = self.__class__.__name__\n        return \"%s(%r)\" % (cls_name, self._value_)\n    else:\n        return self._name_\n\ndef global_enum(cls, update_str=False):\n    \"\"\"\n    decorator that makes the repr() of an enum member reference its module\n    instead of its class; also exports all members to the enum's module's\n    global namespace\n    \"\"\"\n    if issubclass(cls, Flag):\n        cls.__repr__ = global_flag_repr\n    else:\n        cls.__repr__ = global_enum_repr\n    if not issubclass(cls, ReprEnum) or update_str:\n        cls.__str__ = global_str\n    sys.modules[cls.__module__].__dict__.update(cls.__members__)\n    return cls\n\ndef _simple_enum(etype=Enum, *, boundary=None, use_args=None):\n    \"\"\"\n    Class decorator that converts a normal class into an :class:`Enum`.  No\n    safety checks are done, and some advanced behavior (such as\n    :func:`__init_subclass__`) is not available.  Enum creation can be faster\n    using :func:`simple_enum`.\n\n        >>> from enum import Enum, _simple_enum\n        >>> @_simple_enum(Enum)\n        ... class Color:\n        ...     RED = auto()\n        ...     GREEN = auto()\n        ...     BLUE = auto()\n        >>> Color\n        <enum 'Color'>\n    \"\"\"\n    def convert_class(cls):\n        nonlocal use_args\n        cls_name = cls.__name__\n        if use_args is None:\n            use_args = etype._use_args_\n        __new__ = cls.__dict__.get('__new__')\n        if __new__ is not None:\n            new_member = __new__.__func__\n        else:\n            new_member = etype._member_type_.__new__\n        attrs = {}\n        body = {}\n        if __new__ is not None:\n            body['__new_member__'] = new_member\n        body['_new_member_'] = new_member\n        body['_use_args_'] = use_args\n        body['_generate_next_value_'] = gnv = etype._generate_next_value_\n        body['_member_names_'] = member_names = []\n        body['_member_map_'] = member_map = {}\n        body['_value2member_map_'] = value2member_map = {}\n        body['_unhashable_values_'] = []\n        body['_member_type_'] = member_type = etype._member_type_\n        body['_value_repr_'] = etype._value_repr_\n        if issubclass(etype, Flag):\n            body['_boundary_'] = boundary or etype._boundary_\n            body['_flag_mask_'] = None\n            body['_all_bits_'] = None\n            body['_inverted_'] = None\n            body['__or__'] = Flag.__or__\n            body['__xor__'] = Flag.__xor__\n            body['__and__'] = Flag.__and__\n            body['__ror__'] = Flag.__ror__\n            body['__rxor__'] = Flag.__rxor__\n            body['__rand__'] = Flag.__rand__\n            body['__invert__'] = Flag.__invert__\n        for name, obj in cls.__dict__.items():\n            if name in ('__dict__', '__weakref__'):\n                continue\n            if _is_dunder(name) or _is_private(cls_name, name) or _is_sunder(name) or _is_descriptor(obj):\n                body[name] = obj\n            else:\n                attrs[name] = obj\n        if cls.__dict__.get('__doc__') is None:\n            body['__doc__'] = 'An enumeration.'\n        #\n        # double check that repr and friends are not the mixin's or various\n        # things break (such as pickle)\n        # however, if the method is defined in the Enum itself, don't replace\n        # it\n        enum_class = type(cls_name, (etype, ), body, boundary=boundary, _simple=True)\n        for name in ('__repr__', '__str__', '__format__', '__reduce_ex__'):\n            if name not in body:\n                # check for mixin overrides before replacing\n                enum_method = getattr(etype, name)\n                found_method = getattr(enum_class, name)\n                object_method = getattr(object, name)\n                data_type_method = getattr(member_type, name)\n                if found_method in (data_type_method, object_method):\n                    setattr(enum_class, name, enum_method)\n        gnv_last_values = []\n        if issubclass(enum_class, Flag):\n            # Flag / IntFlag\n            single_bits = multi_bits = 0\n            for name, value in attrs.items():\n                if isinstance(value, auto) and auto.value is _auto_null:\n                    value = gnv(name, 1, len(member_names), gnv_last_values)\n                if value in value2member_map:\n                    # an alias to an existing member\n                    redirect = property()\n                    redirect.__set_name__(enum_class, name)\n                    setattr(enum_class, name, redirect)\n                    member_map[name] = value2member_map[value]\n                else:\n                    # create the member\n                    if use_args:\n                        if not isinstance(value, tuple):\n                            value = (value, )\n                        member = new_member(enum_class, *value)\n                        value = value[0]\n                    else:\n                        member = new_member(enum_class)\n                    if __new__ is None:\n                        member._value_ = value\n                    member._name_ = name\n                    member.__objclass__ = enum_class\n                    member.__init__(value)\n                    redirect = property()\n                    redirect.__set_name__(enum_class, name)\n                    setattr(enum_class, name, redirect)\n                    member_map[name] = member\n                    member._sort_order_ = len(member_names)\n                    value2member_map[value] = member\n                    if _is_single_bit(value):\n                        # not a multi-bit alias, record in _member_names_ and _flag_mask_\n                        member_names.append(name)\n                        single_bits |= value\n                    else:\n                        multi_bits |= value\n                    gnv_last_values.append(value)\n            enum_class._flag_mask_ = single_bits\n            enum_class._all_bits_ = 2 ** ((single_bits|multi_bits).bit_length()) - 1\n            # set correct __iter__\n            member_list = [m._value_ for m in enum_class]\n            if member_list != sorted(member_list):\n                enum_class._iter_member_ = enum_class._iter_member_by_def_\n        else:\n            # Enum / IntEnum / StrEnum\n            for name, value in attrs.items():\n                if isinstance(value, auto):\n                    if value.value is _auto_null:\n                        value.value = gnv(name, 1, len(member_names), gnv_last_values)\n                    value = value.value\n                if value in value2member_map:\n                    # an alias to an existing member\n                    redirect = property()\n                    redirect.__set_name__(enum_class, name)\n                    setattr(enum_class, name, redirect)\n                    member_map[name] = value2member_map[value]\n                else:\n                    # create the member\n                    if use_args:\n                        if not isinstance(value, tuple):\n                            value = (value, )\n                        member = new_member(enum_class, *value)\n                        value = value[0]\n                    else:\n                        member = new_member(enum_class)\n                    if __new__ is None:\n                        member._value_ = value\n                    member._name_ = name\n                    member.__objclass__ = enum_class\n                    member.__init__(value)\n                    member._sort_order_ = len(member_names)\n                    redirect = property()\n                    redirect.__set_name__(enum_class, name)\n                    setattr(enum_class, name, redirect)\n                    member_map[name] = member\n                    value2member_map[value] = member\n                    member_names.append(name)\n                    gnv_last_values.append(value)\n        if '__new__' in body:\n            enum_class.__new_member__ = enum_class.__new__\n        enum_class.__new__ = Enum.__new__\n        return enum_class\n    return convert_class\n\n@_simple_enum(StrEnum)\nclass EnumCheck:\n    \"\"\"\n    various conditions to check an enumeration for\n    \"\"\"\n    CONTINUOUS = \"no skipped integer values\"\n    NAMED_FLAGS = \"multi-flag aliases may not contain unnamed flags\"\n    UNIQUE = \"one name per value\"\nCONTINUOUS, NAMED_FLAGS, UNIQUE = EnumCheck\n\n\nclass verify:\n    \"\"\"\n    Check an enumeration for various constraints. (see EnumCheck)\n    \"\"\"\n    def __init__(self, *checks):\n        self.checks = checks\n    def __call__(self, enumeration):\n        checks = self.checks\n        cls_name = enumeration.__name__\n        if Flag is not None and issubclass(enumeration, Flag):\n            enum_type = 'flag'\n        elif issubclass(enumeration, Enum):\n            enum_type = 'enum'\n        else:\n            raise TypeError(\"the 'verify' decorator only works with Enum and Flag\")\n        for check in checks:\n            if check is UNIQUE:\n                # check for duplicate names\n                duplicates = []\n                for name, member in enumeration.__members__.items():\n                    if name != member.name:\n                        duplicates.append((name, member.name))\n                if duplicates:\n                    alias_details = ', '.join(\n                            [\"%s -> %s\" % (alias, name) for (alias, name) in duplicates])\n                    raise ValueError('aliases found in %r: %s' %\n                            (enumeration, alias_details))\n            elif check is CONTINUOUS:\n                values = set(e.value for e in enumeration)\n                if len(values) < 2:\n                    continue\n                low, high = min(values), max(values)\n                missing = []\n                if enum_type == 'flag':\n                    # check for powers of two\n                    for i in range(_high_bit(low)+1, _high_bit(high)):\n                        if 2**i not in values:\n                            missing.append(2**i)\n                elif enum_type == 'enum':\n                    # check for powers of one\n                    for i in range(low+1, high):\n                        if i not in values:\n                            missing.append(i)\n                else:\n                    raise Exception('verify: unknown type %r' % enum_type)\n                if missing:\n                    raise ValueError(('invalid %s %r: missing values %s' % (\n                            enum_type, cls_name, ', '.join((str(m) for m in missing)))\n                            )[:256])\n                            # limit max length to protect against DOS attacks\n            elif check is NAMED_FLAGS:\n                # examine each alias and check for unnamed flags\n                member_names = enumeration._member_names_\n                member_values = [m.value for m in enumeration]\n                missing_names = []\n                missing_value = 0\n                for name, alias in enumeration._member_map_.items():\n                    if name in member_names:\n                        # not an alias\n                        continue\n                    values = list(_iter_bits_lsb(alias.value))\n                    missed = [v for v in values if v not in member_values]\n                    if missed:\n                        missing_names.append(name)\n                        missing_value |= reduce(_or_, missed)\n                if missing_names:\n                    if len(missing_names) == 1:\n                        alias = 'alias %s is missing' % missing_names[0]\n                    else:\n                        alias = 'aliases %s and %s are missing' % (\n                                ', '.join(missing_names[:-1]), missing_names[-1]\n                                )\n                    if _is_single_bit(missing_value):\n                        value = 'value 0x%x' % missing_value\n                    else:\n                        value = 'combined values of 0x%x' % missing_value\n                    raise ValueError(\n                            'invalid Flag %r: %s %s [use enum.show_flag_values(value) for details]'\n                            % (cls_name, alias, value)\n                            )\n        return enumeration\n\ndef _test_simple_enum(checked_enum, simple_enum):\n    \"\"\"\n    A function that can be used to test an enum created with :func:`_simple_enum`\n    against the version created by subclassing :class:`Enum`::\n\n        >>> from enum import Enum, _simple_enum, _test_simple_enum\n        >>> @_simple_enum(Enum)\n        ... class Color:\n        ...     RED = auto()\n        ...     GREEN = auto()\n        ...     BLUE = auto()\n        >>> class CheckedColor(Enum):\n        ...     RED = auto()\n        ...     GREEN = auto()\n        ...     BLUE = auto()\n        >>> _test_simple_enum(CheckedColor, Color)\n\n    If differences are found, a :exc:`TypeError` is raised.\n    \"\"\"\n    failed = []\n    if checked_enum.__dict__ != simple_enum.__dict__:\n        checked_dict = checked_enum.__dict__\n        checked_keys = list(checked_dict.keys())\n        simple_dict = simple_enum.__dict__\n        simple_keys = list(simple_dict.keys())\n        member_names = set(\n                list(checked_enum._member_map_.keys())\n                + list(simple_enum._member_map_.keys())\n                )\n        for key in set(checked_keys + simple_keys):\n            if key in ('__module__', '_member_map_', '_value2member_map_', '__doc__'):\n                # keys known to be different, or very long\n                continue\n            elif key in member_names:\n                # members are checked below\n                continue\n            elif key not in simple_keys:\n                failed.append(\"missing key: %r\" % (key, ))\n            elif key not in checked_keys:\n                failed.append(\"extra key:   %r\" % (key, ))\n            else:\n                checked_value = checked_dict[key]\n                simple_value = simple_dict[key]\n                if callable(checked_value) or isinstance(checked_value, bltns.property):\n                    continue\n                if key == '__doc__':\n                    # remove all spaces/tabs\n                    compressed_checked_value = checked_value.replace(' ','').replace('\\t','')\n                    compressed_simple_value = simple_value.replace(' ','').replace('\\t','')\n                    if compressed_checked_value != compressed_simple_value:\n                        failed.append(\"%r:\\n         %s\\n         %s\" % (\n                                key,\n                                \"checked -> %r\" % (checked_value, ),\n                                \"simple  -> %r\" % (simple_value, ),\n                                ))\n                elif checked_value != simple_value:\n                    failed.append(\"%r:\\n         %s\\n         %s\" % (\n                            key,\n                            \"checked -> %r\" % (checked_value, ),\n                            \"simple  -> %r\" % (simple_value, ),\n                            ))\n        failed.sort()\n        for name in member_names:\n            failed_member = []\n            if name not in simple_keys:\n                failed.append('missing member from simple enum: %r' % name)\n            elif name not in checked_keys:\n                failed.append('extra member in simple enum: %r' % name)\n            else:\n                checked_member_dict = checked_enum[name].__dict__\n                checked_member_keys = list(checked_member_dict.keys())\n                simple_member_dict = simple_enum[name].__dict__\n                simple_member_keys = list(simple_member_dict.keys())\n                for key in set(checked_member_keys + simple_member_keys):\n                    if key in ('__module__', '__objclass__', '_inverted_'):\n                        # keys known to be different or absent\n                        continue\n                    elif key not in simple_member_keys:\n                        failed_member.append(\"missing key %r not in the simple enum member %r\" % (key, name))\n                    elif key not in checked_member_keys:\n                        failed_member.append(\"extra key %r in simple enum member %r\" % (key, name))\n                    else:\n                        checked_value = checked_member_dict[key]\n                        simple_value = simple_member_dict[key]\n                        if checked_value != simple_value:\n                            failed_member.append(\"%r:\\n         %s\\n         %s\" % (\n                                    key,\n                                    \"checked member -> %r\" % (checked_value, ),\n                                    \"simple member  -> %r\" % (simple_value, ),\n                                    ))\n            if failed_member:\n                failed.append('%r member mismatch:\\n      %s' % (\n                        name, '\\n      '.join(failed_member),\n                        ))\n        for method in (\n                '__str__', '__repr__', '__reduce_ex__', '__format__',\n                '__getnewargs_ex__', '__getnewargs__', '__reduce_ex__', '__reduce__'\n            ):\n            if method in simple_keys and method in checked_keys:\n                # cannot compare functions, and it exists in both, so we're good\n                continue\n            elif method not in simple_keys and method not in checked_keys:\n                # method is inherited -- check it out\n                checked_method = getattr(checked_enum, method, None)\n                simple_method = getattr(simple_enum, method, None)\n                if hasattr(checked_method, '__func__'):\n                    checked_method = checked_method.__func__\n                    simple_method = simple_method.__func__\n                if checked_method != simple_method:\n                    failed.append(\"%r:  %-30s %s\" % (\n                            method,\n                            \"checked -> %r\" % (checked_method, ),\n                            \"simple -> %r\" % (simple_method, ),\n                            ))\n            else:\n                # if the method existed in only one of the enums, it will have been caught\n                # in the first checks above\n                pass\n    if failed:\n        raise TypeError('enum mismatch:\\n   %s' % '\\n   '.join(failed))\n\ndef _old_convert_(etype, name, module, filter, source=None, *, boundary=None):\n    \"\"\"\n    Create a new Enum subclass that replaces a collection of global constants\n    \"\"\"\n    # convert all constants from source (or module) that pass filter() to\n    # a new Enum called name, and export the enum and its members back to\n    # module;\n    # also, replace the __reduce_ex__ method so unpickling works in\n    # previous Python versions\n    module_globals = sys.modules[module].__dict__\n    if source:\n        source = source.__dict__\n    else:\n        source = module_globals\n    # _value2member_map_ is populated in the same order every time\n    # for a consistent reverse mapping of number to name when there\n    # are multiple names for the same number.\n    members = [\n            (name, value)\n            for name, value in source.items()\n            if filter(name)]\n    try:\n        # sort by value\n        members.sort(key=lambda t: (t[1], t[0]))\n    except TypeError:\n        # unless some values aren't comparable, in which case sort by name\n        members.sort(key=lambda t: t[0])\n    cls = etype(name, members, module=module, boundary=boundary or KEEP)\n    cls.__reduce_ex__ = _reduce_ex_by_global_name\n    return cls\n\n_stdlib_enums = IntEnum, StrEnum, IntFlag\n",2016],"/home/ma-user/anaconda3/envs/py311/lib/python3.11/re/_compiler.py":["#\n# Secret Labs' Regular Expression Engine\n#\n# convert template to internal format\n#\n# Copyright (c) 1997-2001 by Secret Labs AB.  All rights reserved.\n#\n# See the __init__.py file for information on usage and redistribution.\n#\n\n\"\"\"Internal support module for sre\"\"\"\n\nimport _sre\nfrom . import _parser\nfrom ._constants import *\nfrom ._casefix import _EXTRA_CASES\n\nassert _sre.MAGIC == MAGIC, \"SRE module mismatch\"\n\n_LITERAL_CODES = {LITERAL, NOT_LITERAL}\n_SUCCESS_CODES = {SUCCESS, FAILURE}\n_ASSERT_CODES = {ASSERT, ASSERT_NOT}\n_UNIT_CODES = _LITERAL_CODES | {ANY, IN}\n\n_REPEATING_CODES = {\n    MIN_REPEAT: (REPEAT, MIN_UNTIL, MIN_REPEAT_ONE),\n    MAX_REPEAT: (REPEAT, MAX_UNTIL, REPEAT_ONE),\n    POSSESSIVE_REPEAT: (POSSESSIVE_REPEAT, SUCCESS, POSSESSIVE_REPEAT_ONE),\n}\n\ndef _combine_flags(flags, add_flags, del_flags,\n                   TYPE_FLAGS=_parser.TYPE_FLAGS):\n    if add_flags & TYPE_FLAGS:\n        flags &= ~TYPE_FLAGS\n    return (flags | add_flags) & ~del_flags\n\ndef _compile(code, pattern, flags):\n    # internal: compile a (sub)pattern\n    emit = code.append\n    _len = len\n    LITERAL_CODES = _LITERAL_CODES\n    REPEATING_CODES = _REPEATING_CODES\n    SUCCESS_CODES = _SUCCESS_CODES\n    ASSERT_CODES = _ASSERT_CODES\n    iscased = None\n    tolower = None\n    fixes = None\n    if flags & SRE_FLAG_IGNORECASE and not flags & SRE_FLAG_LOCALE:\n        if flags & SRE_FLAG_UNICODE:\n            iscased = _sre.unicode_iscased\n            tolower = _sre.unicode_tolower\n            fixes = _EXTRA_CASES\n        else:\n            iscased = _sre.ascii_iscased\n            tolower = _sre.ascii_tolower\n    for op, av in pattern:\n        if op in LITERAL_CODES:\n            if not flags & SRE_FLAG_IGNORECASE:\n                emit(op)\n                emit(av)\n            elif flags & SRE_FLAG_LOCALE:\n                emit(OP_LOCALE_IGNORE[op])\n                emit(av)\n            elif not iscased(av):\n                emit(op)\n                emit(av)\n            else:\n                lo = tolower(av)\n                if not fixes:  # ascii\n                    emit(OP_IGNORE[op])\n                    emit(lo)\n                elif lo not in fixes:\n                    emit(OP_UNICODE_IGNORE[op])\n                    emit(lo)\n                else:\n                    emit(IN_UNI_IGNORE)\n                    skip = _len(code); emit(0)\n                    if op is NOT_LITERAL:\n                        emit(NEGATE)\n                    for k in (lo,) + fixes[lo]:\n                        emit(LITERAL)\n                        emit(k)\n                    emit(FAILURE)\n                    code[skip] = _len(code) - skip\n        elif op is IN:\n            charset, hascased = _optimize_charset(av, iscased, tolower, fixes)\n            if flags & SRE_FLAG_IGNORECASE and flags & SRE_FLAG_LOCALE:\n                emit(IN_LOC_IGNORE)\n            elif not hascased:\n                emit(IN)\n            elif not fixes:  # ascii\n                emit(IN_IGNORE)\n            else:\n                emit(IN_UNI_IGNORE)\n            skip = _len(code); emit(0)\n            _compile_charset(charset, flags, code)\n            code[skip] = _len(code) - skip\n        elif op is ANY:\n            if flags & SRE_FLAG_DOTALL:\n                emit(ANY_ALL)\n            else:\n                emit(ANY)\n        elif op in REPEATING_CODES:\n            if flags & SRE_FLAG_TEMPLATE:\n                raise error(\"internal: unsupported template operator %r\" % (op,))\n            if _simple(av[2]):\n                emit(REPEATING_CODES[op][2])\n                skip = _len(code); emit(0)\n                emit(av[0])\n                emit(av[1])\n                _compile(code, av[2], flags)\n                emit(SUCCESS)\n                code[skip] = _len(code) - skip\n            else:\n                emit(REPEATING_CODES[op][0])\n                skip = _len(code); emit(0)\n                emit(av[0])\n                emit(av[1])\n                _compile(code, av[2], flags)\n                code[skip] = _len(code) - skip\n                emit(REPEATING_CODES[op][1])\n        elif op is SUBPATTERN:\n            group, add_flags, del_flags, p = av\n            if group:\n                emit(MARK)\n                emit((group-1)*2)\n            # _compile_info(code, p, _combine_flags(flags, add_flags, del_flags))\n            _compile(code, p, _combine_flags(flags, add_flags, del_flags))\n            if group:\n                emit(MARK)\n                emit((group-1)*2+1)\n        elif op is ATOMIC_GROUP:\n            # Atomic Groups are handled by starting with an Atomic\n            # Group op code, then putting in the atomic group pattern\n            # and finally a success op code to tell any repeat\n            # operations within the Atomic Group to stop eating and\n            # pop their stack if they reach it\n            emit(ATOMIC_GROUP)\n            skip = _len(code); emit(0)\n            _compile(code, av, flags)\n            emit(SUCCESS)\n            code[skip] = _len(code) - skip\n        elif op in SUCCESS_CODES:\n            emit(op)\n        elif op in ASSERT_CODES:\n            emit(op)\n            skip = _len(code); emit(0)\n            if av[0] >= 0:\n                emit(0) # look ahead\n            else:\n                lo, hi = av[1].getwidth()\n                if lo != hi:\n                    raise error(\"look-behind requires fixed-width pattern\")\n                emit(lo) # look behind\n            _compile(code, av[1], flags)\n            emit(SUCCESS)\n            code[skip] = _len(code) - skip\n        elif op is AT:\n            emit(op)\n            if flags & SRE_FLAG_MULTILINE:\n                av = AT_MULTILINE.get(av, av)\n            if flags & SRE_FLAG_LOCALE:\n                av = AT_LOCALE.get(av, av)\n            elif flags & SRE_FLAG_UNICODE:\n                av = AT_UNICODE.get(av, av)\n            emit(av)\n        elif op is BRANCH:\n            emit(op)\n            tail = []\n            tailappend = tail.append\n            for av in av[1]:\n                skip = _len(code); emit(0)\n                # _compile_info(code, av, flags)\n                _compile(code, av, flags)\n                emit(JUMP)\n                tailappend(_len(code)); emit(0)\n                code[skip] = _len(code) - skip\n            emit(FAILURE) # end of branch\n            for tail in tail:\n                code[tail] = _len(code) - tail\n        elif op is CATEGORY:\n            emit(op)\n            if flags & SRE_FLAG_LOCALE:\n                av = CH_LOCALE[av]\n            elif flags & SRE_FLAG_UNICODE:\n                av = CH_UNICODE[av]\n            emit(av)\n        elif op is GROUPREF:\n            if not flags & SRE_FLAG_IGNORECASE:\n                emit(op)\n            elif flags & SRE_FLAG_LOCALE:\n                emit(GROUPREF_LOC_IGNORE)\n            elif not fixes:  # ascii\n                emit(GROUPREF_IGNORE)\n            else:\n                emit(GROUPREF_UNI_IGNORE)\n            emit(av-1)\n        elif op is GROUPREF_EXISTS:\n            emit(op)\n            emit(av[0]-1)\n            skipyes = _len(code); emit(0)\n            _compile(code, av[1], flags)\n            if av[2]:\n                emit(JUMP)\n                skipno = _len(code); emit(0)\n                code[skipyes] = _len(code) - skipyes + 1\n                _compile(code, av[2], flags)\n                code[skipno] = _len(code) - skipno\n            else:\n                code[skipyes] = _len(code) - skipyes + 1\n        else:\n            raise error(\"internal: unsupported operand type %r\" % (op,))\n\ndef _compile_charset(charset, flags, code):\n    # compile charset subprogram\n    emit = code.append\n    for op, av in charset:\n        emit(op)\n        if op is NEGATE:\n            pass\n        elif op is LITERAL:\n            emit(av)\n        elif op is RANGE or op is RANGE_UNI_IGNORE:\n            emit(av[0])\n            emit(av[1])\n        elif op is CHARSET:\n            code.extend(av)\n        elif op is BIGCHARSET:\n            code.extend(av)\n        elif op is CATEGORY:\n            if flags & SRE_FLAG_LOCALE:\n                emit(CH_LOCALE[av])\n            elif flags & SRE_FLAG_UNICODE:\n                emit(CH_UNICODE[av])\n            else:\n                emit(av)\n        else:\n            raise error(\"internal: unsupported set operator %r\" % (op,))\n    emit(FAILURE)\n\ndef _optimize_charset(charset, iscased=None, fixup=None, fixes=None):\n    # internal: optimize character set\n    out = []\n    tail = []\n    charmap = bytearray(256)\n    hascased = False\n    for op, av in charset:\n        while True:\n            try:\n                if op is LITERAL:\n                    if fixup:\n                        lo = fixup(av)\n                        charmap[lo] = 1\n                        if fixes and lo in fixes:\n                            for k in fixes[lo]:\n                                charmap[k] = 1\n                        if not hascased and iscased(av):\n                            hascased = True\n                    else:\n                        charmap[av] = 1\n                elif op is RANGE:\n                    r = range(av[0], av[1]+1)\n                    if fixup:\n                        if fixes:\n                            for i in map(fixup, r):\n                                charmap[i] = 1\n                                if i in fixes:\n                                    for k in fixes[i]:\n                                        charmap[k] = 1\n                        else:\n                            for i in map(fixup, r):\n                                charmap[i] = 1\n                        if not hascased:\n                            hascased = any(map(iscased, r))\n                    else:\n                        for i in r:\n                            charmap[i] = 1\n                elif op is NEGATE:\n                    out.append((op, av))\n                else:\n                    tail.append((op, av))\n            except IndexError:\n                if len(charmap) == 256:\n                    # character set contains non-UCS1 character codes\n                    charmap += b'\\0' * 0xff00\n                    continue\n                # Character set contains non-BMP character codes.\n                # For range, all BMP characters in the range are already\n                # proceeded.\n                if fixup:\n                    hascased = True\n                    # For now, IN_UNI_IGNORE+LITERAL and\n                    # IN_UNI_IGNORE+RANGE_UNI_IGNORE work for all non-BMP\n                    # characters, because two characters (at least one of\n                    # which is not in the BMP) match case-insensitively\n                    # if and only if:\n                    # 1) c1.lower() == c2.lower()\n                    # 2) c1.lower() == c2 or c1.lower().upper() == c2\n                    # Also, both c.lower() and c.lower().upper() are single\n                    # characters for every non-BMP character.\n                    if op is RANGE:\n                        op = RANGE_UNI_IGNORE\n                tail.append((op, av))\n            break\n\n    # compress character map\n    runs = []\n    q = 0\n    while True:\n        p = charmap.find(1, q)\n        if p < 0:\n            break\n        if len(runs) >= 2:\n            runs = None\n            break\n        q = charmap.find(0, p)\n        if q < 0:\n            runs.append((p, len(charmap)))\n            break\n        runs.append((p, q))\n    if runs is not None:\n        # use literal/range\n        for p, q in runs:\n            if q - p == 1:\n                out.append((LITERAL, p))\n            else:\n                out.append((RANGE, (p, q - 1)))\n        out += tail\n        # if the case was changed or new representation is more compact\n        if hascased or len(out) < len(charset):\n            return out, hascased\n        # else original character set is good enough\n        return charset, hascased\n\n    # use bitmap\n    if len(charmap) == 256:\n        data = _mk_bitmap(charmap)\n        out.append((CHARSET, data))\n        out += tail\n        return out, hascased\n\n    # To represent a big charset, first a bitmap of all characters in the\n    # set is constructed. Then, this bitmap is sliced into chunks of 256\n    # characters, duplicate chunks are eliminated, and each chunk is\n    # given a number. In the compiled expression, the charset is\n    # represented by a 32-bit word sequence, consisting of one word for\n    # the number of different chunks, a sequence of 256 bytes (64 words)\n    # of chunk numbers indexed by their original chunk position, and a\n    # sequence of 256-bit chunks (8 words each).\n\n    # Compression is normally good: in a typical charset, large ranges of\n    # Unicode will be either completely excluded (e.g. if only cyrillic\n    # letters are to be matched), or completely included (e.g. if large\n    # subranges of Kanji match). These ranges will be represented by\n    # chunks of all one-bits or all zero-bits.\n\n    # Matching can be also done efficiently: the more significant byte of\n    # the Unicode character is an index into the chunk number, and the\n    # less significant byte is a bit index in the chunk (just like the\n    # CHARSET matching).\n\n    charmap = bytes(charmap) # should be hashable\n    comps = {}\n    mapping = bytearray(256)\n    block = 0\n    data = bytearray()\n    for i in range(0, 65536, 256):\n        chunk = charmap[i: i + 256]\n        if chunk in comps:\n            mapping[i // 256] = comps[chunk]\n        else:\n            mapping[i // 256] = comps[chunk] = block\n            block += 1\n            data += chunk\n    data = _mk_bitmap(data)\n    data[0:0] = [block] + _bytes_to_codes(mapping)\n    out.append((BIGCHARSET, data))\n    out += tail\n    return out, hascased\n\n_CODEBITS = _sre.CODESIZE * 8\nMAXCODE = (1 << _CODEBITS) - 1\n_BITS_TRANS = b'0' + b'1' * 255\ndef _mk_bitmap(bits, _CODEBITS=_CODEBITS, _int=int):\n    s = bits.translate(_BITS_TRANS)[::-1]\n    return [_int(s[i - _CODEBITS: i], 2)\n            for i in range(len(s), 0, -_CODEBITS)]\n\ndef _bytes_to_codes(b):\n    # Convert block indices to word array\n    a = memoryview(b).cast('I')\n    assert a.itemsize == _sre.CODESIZE\n    assert len(a) * a.itemsize == len(b)\n    return a.tolist()\n\ndef _simple(p):\n    # check if this subpattern is a \"simple\" operator\n    if len(p) != 1:\n        return False\n    op, av = p[0]\n    if op is SUBPATTERN:\n        return av[0] is None and _simple(av[-1])\n    return op in _UNIT_CODES\n\ndef _generate_overlap_table(prefix):\n    \"\"\"\n    Generate an overlap table for the following prefix.\n    An overlap table is a table of the same size as the prefix which\n    informs about the potential self-overlap for each index in the prefix:\n    - if overlap[i] == 0, prefix[i:] can't overlap prefix[0:...]\n    - if overlap[i] == k with 0 < k <= i, prefix[i-k+1:i+1] overlaps with\n      prefix[0:k]\n    \"\"\"\n    table = [0] * len(prefix)\n    for i in range(1, len(prefix)):\n        idx = table[i - 1]\n        while prefix[i] != prefix[idx]:\n            if idx == 0:\n                table[i] = 0\n                break\n            idx = table[idx - 1]\n        else:\n            table[i] = idx + 1\n    return table\n\ndef _get_iscased(flags):\n    if not flags & SRE_FLAG_IGNORECASE:\n        return None\n    elif flags & SRE_FLAG_UNICODE:\n        return _sre.unicode_iscased\n    else:\n        return _sre.ascii_iscased\n\ndef _get_literal_prefix(pattern, flags):\n    # look for literal prefix\n    prefix = []\n    prefixappend = prefix.append\n    prefix_skip = None\n    iscased = _get_iscased(flags)\n    for op, av in pattern.data:\n        if op is LITERAL:\n            if iscased and iscased(av):\n                break\n            prefixappend(av)\n        elif op is SUBPATTERN:\n            group, add_flags, del_flags, p = av\n            flags1 = _combine_flags(flags, add_flags, del_flags)\n            if flags1 & SRE_FLAG_IGNORECASE and flags1 & SRE_FLAG_LOCALE:\n                break\n            prefix1, prefix_skip1, got_all = _get_literal_prefix(p, flags1)\n            if prefix_skip is None:\n                if group is not None:\n                    prefix_skip = len(prefix)\n                elif prefix_skip1 is not None:\n                    prefix_skip = len(prefix) + prefix_skip1\n            prefix.extend(prefix1)\n            if not got_all:\n                break\n        else:\n            break\n    else:\n        return prefix, prefix_skip, True\n    return prefix, prefix_skip, False\n\ndef _get_charset_prefix(pattern, flags):\n    while True:\n        if not pattern.data:\n            return None\n        op, av = pattern.data[0]\n        if op is not SUBPATTERN:\n            break\n        group, add_flags, del_flags, pattern = av\n        flags = _combine_flags(flags, add_flags, del_flags)\n        if flags & SRE_FLAG_IGNORECASE and flags & SRE_FLAG_LOCALE:\n            return None\n\n    iscased = _get_iscased(flags)\n    if op is LITERAL:\n        if iscased and iscased(av):\n            return None\n        return [(op, av)]\n    elif op is BRANCH:\n        charset = []\n        charsetappend = charset.append\n        for p in av[1]:\n            if not p:\n                return None\n            op, av = p[0]\n            if op is LITERAL and not (iscased and iscased(av)):\n                charsetappend((op, av))\n            else:\n                return None\n        return charset\n    elif op is IN:\n        charset = av\n        if iscased:\n            for op, av in charset:\n                if op is LITERAL:\n                    if iscased(av):\n                        return None\n                elif op is RANGE:\n                    if av[1] > 0xffff:\n                        return None\n                    if any(map(iscased, range(av[0], av[1]+1))):\n                        return None\n        return charset\n    return None\n\ndef _compile_info(code, pattern, flags):\n    # internal: compile an info block.  in the current version,\n    # this contains min/max pattern width, and an optional literal\n    # prefix or a character map\n    lo, hi = pattern.getwidth()\n    if hi > MAXCODE:\n        hi = MAXCODE\n    if lo == 0:\n        code.extend([INFO, 4, 0, lo, hi])\n        return\n    # look for a literal prefix\n    prefix = []\n    prefix_skip = 0\n    charset = [] # not used\n    if not (flags & SRE_FLAG_IGNORECASE and flags & SRE_FLAG_LOCALE):\n        # look for literal prefix\n        prefix, prefix_skip, got_all = _get_literal_prefix(pattern, flags)\n        # if no prefix, look for charset prefix\n        if not prefix:\n            charset = _get_charset_prefix(pattern, flags)\n##     if prefix:\n##         print(\"*** PREFIX\", prefix, prefix_skip)\n##     if charset:\n##         print(\"*** CHARSET\", charset)\n    # add an info block\n    emit = code.append\n    emit(INFO)\n    skip = len(code); emit(0)\n    # literal flag\n    mask = 0\n    if prefix:\n        mask = SRE_INFO_PREFIX\n        if prefix_skip is None and got_all:\n            mask = mask | SRE_INFO_LITERAL\n    elif charset:\n        mask = mask | SRE_INFO_CHARSET\n    emit(mask)\n    # pattern length\n    if lo < MAXCODE:\n        emit(lo)\n    else:\n        emit(MAXCODE)\n        prefix = prefix[:MAXCODE]\n    emit(min(hi, MAXCODE))\n    # add literal prefix\n    if prefix:\n        emit(len(prefix)) # length\n        if prefix_skip is None:\n            prefix_skip =  len(prefix)\n        emit(prefix_skip) # skip\n        code.extend(prefix)\n        # generate overlap table\n        code.extend(_generate_overlap_table(prefix))\n    elif charset:\n        charset, hascased = _optimize_charset(charset)\n        assert not hascased\n        _compile_charset(charset, flags, code)\n    code[skip] = len(code) - skip\n\ndef isstring(obj):\n    return isinstance(obj, (str, bytes))\n\ndef _code(p, flags):\n\n    flags = p.state.flags | flags\n    code = []\n\n    # compile info block\n    _compile_info(code, p, flags)\n\n    # compile the pattern\n    _compile(code, p.data, flags)\n\n    code.append(SUCCESS)\n\n    return code\n\ndef _hex_code(code):\n    return '[%s]' % ', '.join('%#0*x' % (_sre.CODESIZE*2+2, x) for x in code)\n\ndef dis(code):\n    import sys\n\n    labels = set()\n    level = 0\n    offset_width = len(str(len(code) - 1))\n\n    def dis_(start, end):\n        def print_(*args, to=None):\n            if to is not None:\n                labels.add(to)\n                args += ('(to %d)' % (to,),)\n            print('%*d%s ' % (offset_width, start, ':' if start in labels else '.'),\n                  end='  '*(level-1))\n            print(*args)\n\n        def print_2(*args):\n            print(end=' '*(offset_width + 2*level))\n            print(*args)\n\n        nonlocal level\n        level += 1\n        i = start\n        while i < end:\n            start = i\n            op = code[i]\n            i += 1\n            op = OPCODES[op]\n            if op in (SUCCESS, FAILURE, ANY, ANY_ALL,\n                      MAX_UNTIL, MIN_UNTIL, NEGATE):\n                print_(op)\n            elif op in (LITERAL, NOT_LITERAL,\n                        LITERAL_IGNORE, NOT_LITERAL_IGNORE,\n                        LITERAL_UNI_IGNORE, NOT_LITERAL_UNI_IGNORE,\n                        LITERAL_LOC_IGNORE, NOT_LITERAL_LOC_IGNORE):\n                arg = code[i]\n                i += 1\n                print_(op, '%#02x (%r)' % (arg, chr(arg)))\n            elif op is AT:\n                arg = code[i]\n                i += 1\n                arg = str(ATCODES[arg])\n                assert arg[:3] == 'AT_'\n                print_(op, arg[3:])\n            elif op is CATEGORY:\n                arg = code[i]\n                i += 1\n                arg = str(CHCODES[arg])\n                assert arg[:9] == 'CATEGORY_'\n                print_(op, arg[9:])\n            elif op in (IN, IN_IGNORE, IN_UNI_IGNORE, IN_LOC_IGNORE):\n                skip = code[i]\n                print_(op, skip, to=i+skip)\n                dis_(i+1, i+skip)\n                i += skip\n            elif op in (RANGE, RANGE_UNI_IGNORE):\n                lo, hi = code[i: i+2]\n                i += 2\n                print_(op, '%#02x %#02x (%r-%r)' % (lo, hi, chr(lo), chr(hi)))\n            elif op is CHARSET:\n                print_(op, _hex_code(code[i: i + 256//_CODEBITS]))\n                i += 256//_CODEBITS\n            elif op is BIGCHARSET:\n                arg = code[i]\n                i += 1\n                mapping = list(b''.join(x.to_bytes(_sre.CODESIZE, sys.byteorder)\n                                        for x in code[i: i + 256//_sre.CODESIZE]))\n                print_(op, arg, mapping)\n                i += 256//_sre.CODESIZE\n                level += 1\n                for j in range(arg):\n                    print_2(_hex_code(code[i: i + 256//_CODEBITS]))\n                    i += 256//_CODEBITS\n                level -= 1\n            elif op in (MARK, GROUPREF, GROUPREF_IGNORE, GROUPREF_UNI_IGNORE,\n                        GROUPREF_LOC_IGNORE):\n                arg = code[i]\n                i += 1\n                print_(op, arg)\n            elif op is JUMP:\n                skip = code[i]\n                print_(op, skip, to=i+skip)\n                i += 1\n            elif op is BRANCH:\n                skip = code[i]\n                print_(op, skip, to=i+skip)\n                while skip:\n                    dis_(i+1, i+skip)\n                    i += skip\n                    start = i\n                    skip = code[i]\n                    if skip:\n                        print_('branch', skip, to=i+skip)\n                    else:\n                        print_(FAILURE)\n                i += 1\n            elif op in (REPEAT, REPEAT_ONE, MIN_REPEAT_ONE,\n                        POSSESSIVE_REPEAT, POSSESSIVE_REPEAT_ONE):\n                skip, min, max = code[i: i+3]\n                if max == MAXREPEAT:\n                    max = 'MAXREPEAT'\n                print_(op, skip, min, max, to=i+skip)\n                dis_(i+3, i+skip)\n                i += skip\n            elif op is GROUPREF_EXISTS:\n                arg, skip = code[i: i+2]\n                print_(op, arg, skip, to=i+skip)\n                i += 2\n            elif op in (ASSERT, ASSERT_NOT):\n                skip, arg = code[i: i+2]\n                print_(op, skip, arg, to=i+skip)\n                dis_(i+2, i+skip)\n                i += skip\n            elif op is ATOMIC_GROUP:\n                skip = code[i]\n                print_(op, skip, to=i+skip)\n                dis_(i+1, i+skip)\n                i += skip\n            elif op is INFO:\n                skip, flags, min, max = code[i: i+4]\n                if max == MAXREPEAT:\n                    max = 'MAXREPEAT'\n                print_(op, skip, bin(flags), min, max, to=i+skip)\n                start = i+4\n                if flags & SRE_INFO_PREFIX:\n                    prefix_len, prefix_skip = code[i+4: i+6]\n                    print_2('  prefix_skip', prefix_skip)\n                    start = i + 6\n                    prefix = code[start: start+prefix_len]\n                    print_2('  prefix',\n                            '[%s]' % ', '.join('%#02x' % x for x in prefix),\n                            '(%r)' % ''.join(map(chr, prefix)))\n                    start += prefix_len\n                    print_2('  overlap', code[start: start+prefix_len])\n                    start += prefix_len\n                if flags & SRE_INFO_CHARSET:\n                    level += 1\n                    print_2('in')\n                    dis_(start, i+skip)\n                    level -= 1\n                i += skip\n            else:\n                raise ValueError(op)\n\n        level -= 1\n\n    dis_(0, len(code))\n\n\ndef compile(p, flags=0):\n    # internal: convert pattern list to internal format\n\n    if isstring(p):\n        pattern = p\n        p = _parser.parse(p, flags)\n    else:\n        pattern = None\n\n    code = _code(p, flags)\n\n    if flags & SRE_FLAG_DEBUG:\n        print()\n        dis(code)\n\n    # map in either direction\n    groupindex = p.state.groupdict\n    indexgroup = [None] * p.state.groups\n    for k, i in groupindex.items():\n        indexgroup[i] = k\n\n    return _sre.compile(\n        pattern, flags | p.state.flags, code,\n        p.state.groups-1,\n        groupindex, tuple(indexgroup)\n        )\n",763],"/home/ma-user/anaconda3/envs/py311/lib/python3.11/re/_parser.py":["#\n# Secret Labs' Regular Expression Engine\n#\n# convert re-style regular expression to sre pattern\n#\n# Copyright (c) 1998-2001 by Secret Labs AB.  All rights reserved.\n#\n# See the __init__.py file for information on usage and redistribution.\n#\n\n\"\"\"Internal support module for sre\"\"\"\n\n# XXX: show string offset and offending character for all errors\n\nfrom ._constants import *\n\nSPECIAL_CHARS = \".\\\\[{()*+?^$|\"\nREPEAT_CHARS = \"*+?{\"\n\nDIGITS = frozenset(\"0123456789\")\n\nOCTDIGITS = frozenset(\"01234567\")\nHEXDIGITS = frozenset(\"0123456789abcdefABCDEF\")\nASCIILETTERS = frozenset(\"abcdefghijklmnopqrstuvwxyzABCDEFGHIJKLMNOPQRSTUVWXYZ\")\n\nWHITESPACE = frozenset(\" \\t\\n\\r\\v\\f\")\n\n_REPEATCODES = frozenset({MIN_REPEAT, MAX_REPEAT, POSSESSIVE_REPEAT})\n_UNITCODES = frozenset({ANY, RANGE, IN, LITERAL, NOT_LITERAL, CATEGORY})\n\nESCAPES = {\n    r\"\\a\": (LITERAL, ord(\"\\a\")),\n    r\"\\b\": (LITERAL, ord(\"\\b\")),\n    r\"\\f\": (LITERAL, ord(\"\\f\")),\n    r\"\\n\": (LITERAL, ord(\"\\n\")),\n    r\"\\r\": (LITERAL, ord(\"\\r\")),\n    r\"\\t\": (LITERAL, ord(\"\\t\")),\n    r\"\\v\": (LITERAL, ord(\"\\v\")),\n    r\"\\\\\": (LITERAL, ord(\"\\\\\"))\n}\n\nCATEGORIES = {\n    r\"\\A\": (AT, AT_BEGINNING_STRING), # start of string\n    r\"\\b\": (AT, AT_BOUNDARY),\n    r\"\\B\": (AT, AT_NON_BOUNDARY),\n    r\"\\d\": (IN, [(CATEGORY, CATEGORY_DIGIT)]),\n    r\"\\D\": (IN, [(CATEGORY, CATEGORY_NOT_DIGIT)]),\n    r\"\\s\": (IN, [(CATEGORY, CATEGORY_SPACE)]),\n    r\"\\S\": (IN, [(CATEGORY, CATEGORY_NOT_SPACE)]),\n    r\"\\w\": (IN, [(CATEGORY, CATEGORY_WORD)]),\n    r\"\\W\": (IN, [(CATEGORY, CATEGORY_NOT_WORD)]),\n    r\"\\Z\": (AT, AT_END_STRING), # end of string\n}\n\nFLAGS = {\n    # standard flags\n    \"i\": SRE_FLAG_IGNORECASE,\n    \"L\": SRE_FLAG_LOCALE,\n    \"m\": SRE_FLAG_MULTILINE,\n    \"s\": SRE_FLAG_DOTALL,\n    \"x\": SRE_FLAG_VERBOSE,\n    # extensions\n    \"a\": SRE_FLAG_ASCII,\n    \"t\": SRE_FLAG_TEMPLATE,\n    \"u\": SRE_FLAG_UNICODE,\n}\n\nTYPE_FLAGS = SRE_FLAG_ASCII | SRE_FLAG_LOCALE | SRE_FLAG_UNICODE\nGLOBAL_FLAGS = SRE_FLAG_DEBUG | SRE_FLAG_TEMPLATE\n\nclass State:\n    # keeps track of state for parsing\n    def __init__(self):\n        self.flags = 0\n        self.groupdict = {}\n        self.groupwidths = [None]  # group 0\n        self.lookbehindgroups = None\n        self.grouprefpos = {}\n    @property\n    def groups(self):\n        return len(self.groupwidths)\n    def opengroup(self, name=None):\n        gid = self.groups\n        self.groupwidths.append(None)\n        if self.groups > MAXGROUPS:\n            raise error(\"too many groups\")\n        if name is not None:\n            ogid = self.groupdict.get(name, None)\n            if ogid is not None:\n                raise error(\"redefinition of group name %r as group %d; \"\n                            \"was group %d\" % (name, gid,  ogid))\n            self.groupdict[name] = gid\n        return gid\n    def closegroup(self, gid, p):\n        self.groupwidths[gid] = p.getwidth()\n    def checkgroup(self, gid):\n        return gid < self.groups and self.groupwidths[gid] is not None\n\n    def checklookbehindgroup(self, gid, source):\n        if self.lookbehindgroups is not None:\n            if not self.checkgroup(gid):\n                raise source.error('cannot refer to an open group')\n            if gid >= self.lookbehindgroups:\n                raise source.error('cannot refer to group defined in the same '\n                                   'lookbehind subpattern')\n\nclass SubPattern:\n    # a subpattern, in intermediate form\n    def __init__(self, state, data=None):\n        self.state = state\n        if data is None:\n            data = []\n        self.data = data\n        self.width = None\n\n    def dump(self, level=0):\n        nl = True\n        seqtypes = (tuple, list)\n        for op, av in self.data:\n            print(level*\"  \" + str(op), end='')\n            if op is IN:\n                # member sublanguage\n                print()\n                for op, a in av:\n                    print((level+1)*\"  \" + str(op), a)\n            elif op is BRANCH:\n                print()\n                for i, a in enumerate(av[1]):\n                    if i:\n                        print(level*\"  \" + \"OR\")\n                    a.dump(level+1)\n            elif op is GROUPREF_EXISTS:\n                condgroup, item_yes, item_no = av\n                print('', condgroup)\n                item_yes.dump(level+1)\n                if item_no:\n                    print(level*\"  \" + \"ELSE\")\n                    item_no.dump(level+1)\n            elif isinstance(av, seqtypes):\n                nl = False\n                for a in av:\n                    if isinstance(a, SubPattern):\n                        if not nl:\n                            print()\n                        a.dump(level+1)\n                        nl = True\n                    else:\n                        if not nl:\n                            print(' ', end='')\n                        print(a, end='')\n                        nl = False\n                if not nl:\n                    print()\n            else:\n                print('', av)\n    def __repr__(self):\n        return repr(self.data)\n    def __len__(self):\n        return len(self.data)\n    def __delitem__(self, index):\n        del self.data[index]\n    def __getitem__(self, index):\n        if isinstance(index, slice):\n            return SubPattern(self.state, self.data[index])\n        return self.data[index]\n    def __setitem__(self, index, code):\n        self.data[index] = code\n    def insert(self, index, code):\n        self.data.insert(index, code)\n    def append(self, code):\n        self.data.append(code)\n    def getwidth(self):\n        # determine the width (min, max) for this subpattern\n        if self.width is not None:\n            return self.width\n        lo = hi = 0\n        for op, av in self.data:\n            if op is BRANCH:\n                i = MAXREPEAT - 1\n                j = 0\n                for av in av[1]:\n                    l, h = av.getwidth()\n                    i = min(i, l)\n                    j = max(j, h)\n                lo = lo + i\n                hi = hi + j\n            elif op is ATOMIC_GROUP:\n                i, j = av.getwidth()\n                lo = lo + i\n                hi = hi + j\n            elif op is SUBPATTERN:\n                i, j = av[-1].getwidth()\n                lo = lo + i\n                hi = hi + j\n            elif op in _REPEATCODES:\n                i, j = av[2].getwidth()\n                lo = lo + i * av[0]\n                hi = hi + j * av[1]\n            elif op in _UNITCODES:\n                lo = lo + 1\n                hi = hi + 1\n            elif op is GROUPREF:\n                i, j = self.state.groupwidths[av]\n                lo = lo + i\n                hi = hi + j\n            elif op is GROUPREF_EXISTS:\n                i, j = av[1].getwidth()\n                if av[2] is not None:\n                    l, h = av[2].getwidth()\n                    i = min(i, l)\n                    j = max(j, h)\n                else:\n                    i = 0\n                lo = lo + i\n                hi = hi + j\n            elif op is SUCCESS:\n                break\n        self.width = min(lo, MAXREPEAT - 1), min(hi, MAXREPEAT)\n        return self.width\n\nclass Tokenizer:\n    def __init__(self, string):\n        self.istext = isinstance(string, str)\n        self.string = string\n        if not self.istext:\n            string = str(string, 'latin1')\n        self.decoded_string = string\n        self.index = 0\n        self.next = None\n        self.__next()\n    def __next(self):\n        index = self.index\n        try:\n            char = self.decoded_string[index]\n        except IndexError:\n            self.next = None\n            return\n        if char == \"\\\\\":\n            index += 1\n            try:\n                char += self.decoded_string[index]\n            except IndexError:\n                raise error(\"bad escape (end of pattern)\",\n                            self.string, len(self.string) - 1) from None\n        self.index = index + 1\n        self.next = char\n    def match(self, char):\n        if char == self.next:\n            self.__next()\n            return True\n        return False\n    def get(self):\n        this = self.next\n        self.__next()\n        return this\n    def getwhile(self, n, charset):\n        result = ''\n        for _ in range(n):\n            c = self.next\n            if c not in charset:\n                break\n            result += c\n            self.__next()\n        return result\n    def getuntil(self, terminator, name):\n        result = ''\n        while True:\n            c = self.next\n            self.__next()\n            if c is None:\n                if not result:\n                    raise self.error(\"missing \" + name)\n                raise self.error(\"missing %s, unterminated name\" % terminator,\n                                 len(result))\n            if c == terminator:\n                if not result:\n                    raise self.error(\"missing \" + name, 1)\n                break\n            result += c\n        return result\n    @property\n    def pos(self):\n        return self.index - len(self.next or '')\n    def tell(self):\n        return self.index - len(self.next or '')\n    def seek(self, index):\n        self.index = index\n        self.__next()\n\n    def error(self, msg, offset=0):\n        if not self.istext:\n            msg = msg.encode('ascii', 'backslashreplace').decode('ascii')\n        return error(msg, self.string, self.tell() - offset)\n\n    def checkgroupname(self, name, offset, nested):\n        if not name.isidentifier():\n            msg = \"bad character in group name %r\" % name\n            raise self.error(msg, len(name) + offset)\n        if not (self.istext or name.isascii()):\n            import warnings\n            warnings.warn(\n                \"bad character in group name %a at position %d\" %\n                (name, self.tell() - len(name) - offset),\n                DeprecationWarning, stacklevel=nested + 7\n            )\n\ndef _class_escape(source, escape):\n    # handle escape code inside character class\n    code = ESCAPES.get(escape)\n    if code:\n        return code\n    code = CATEGORIES.get(escape)\n    if code and code[0] is IN:\n        return code\n    try:\n        c = escape[1:2]\n        if c == \"x\":\n            # hexadecimal escape (exactly two digits)\n            escape += source.getwhile(2, HEXDIGITS)\n            if len(escape) != 4:\n                raise source.error(\"incomplete escape %s\" % escape, len(escape))\n            return LITERAL, int(escape[2:], 16)\n        elif c == \"u\" and source.istext:\n            # unicode escape (exactly four digits)\n            escape += source.getwhile(4, HEXDIGITS)\n            if len(escape) != 6:\n                raise source.error(\"incomplete escape %s\" % escape, len(escape))\n            return LITERAL, int(escape[2:], 16)\n        elif c == \"U\" and source.istext:\n            # unicode escape (exactly eight digits)\n            escape += source.getwhile(8, HEXDIGITS)\n            if len(escape) != 10:\n                raise source.error(\"incomplete escape %s\" % escape, len(escape))\n            c = int(escape[2:], 16)\n            chr(c) # raise ValueError for invalid code\n            return LITERAL, c\n        elif c == \"N\" and source.istext:\n            import unicodedata\n            # named unicode escape e.g. \\N{EM DASH}\n            if not source.match('{'):\n                raise source.error(\"missing {\")\n            charname = source.getuntil('}', 'character name')\n            try:\n                c = ord(unicodedata.lookup(charname))\n            except (KeyError, TypeError):\n                raise source.error(\"undefined character name %r\" % charname,\n                                   len(charname) + len(r'\\N{}')) from None\n            return LITERAL, c\n        elif c in OCTDIGITS:\n            # octal escape (up to three digits)\n            escape += source.getwhile(2, OCTDIGITS)\n            c = int(escape[1:], 8)\n            if c > 0o377:\n                raise source.error('octal escape value %s outside of '\n                                   'range 0-0o377' % escape, len(escape))\n            return LITERAL, c\n        elif c in DIGITS:\n            raise ValueError\n        if len(escape) == 2:\n            if c in ASCIILETTERS:\n                raise source.error('bad escape %s' % escape, len(escape))\n            return LITERAL, ord(escape[1])\n    except ValueError:\n        pass\n    raise source.error(\"bad escape %s\" % escape, len(escape))\n\ndef _escape(source, escape, state):\n    # handle escape code in expression\n    code = CATEGORIES.get(escape)\n    if code:\n        return code\n    code = ESCAPES.get(escape)\n    if code:\n        return code\n    try:\n        c = escape[1:2]\n        if c == \"x\":\n            # hexadecimal escape\n            escape += source.getwhile(2, HEXDIGITS)\n            if len(escape) != 4:\n                raise source.error(\"incomplete escape %s\" % escape, len(escape))\n            return LITERAL, int(escape[2:], 16)\n        elif c == \"u\" and source.istext:\n            # unicode escape (exactly four digits)\n            escape += source.getwhile(4, HEXDIGITS)\n            if len(escape) != 6:\n                raise source.error(\"incomplete escape %s\" % escape, len(escape))\n            return LITERAL, int(escape[2:], 16)\n        elif c == \"U\" and source.istext:\n            # unicode escape (exactly eight digits)\n            escape += source.getwhile(8, HEXDIGITS)\n            if len(escape) != 10:\n                raise source.error(\"incomplete escape %s\" % escape, len(escape))\n            c = int(escape[2:], 16)\n            chr(c) # raise ValueError for invalid code\n            return LITERAL, c\n        elif c == \"N\" and source.istext:\n            import unicodedata\n            # named unicode escape e.g. \\N{EM DASH}\n            if not source.match('{'):\n                raise source.error(\"missing {\")\n            charname = source.getuntil('}', 'character name')\n            try:\n                c = ord(unicodedata.lookup(charname))\n            except (KeyError, TypeError):\n                raise source.error(\"undefined character name %r\" % charname,\n                                   len(charname) + len(r'\\N{}')) from None\n            return LITERAL, c\n        elif c == \"0\":\n            # octal escape\n            escape += source.getwhile(2, OCTDIGITS)\n            return LITERAL, int(escape[1:], 8)\n        elif c in DIGITS:\n            # octal escape *or* decimal group reference (sigh)\n            if source.next in DIGITS:\n                escape += source.get()\n                if (escape[1] in OCTDIGITS and escape[2] in OCTDIGITS and\n                    source.next in OCTDIGITS):\n                    # got three octal digits; this is an octal escape\n                    escape += source.get()\n                    c = int(escape[1:], 8)\n                    if c > 0o377:\n                        raise source.error('octal escape value %s outside of '\n                                           'range 0-0o377' % escape,\n                                           len(escape))\n                    return LITERAL, c\n            # not an octal escape, so this is a group reference\n            group = int(escape[1:])\n            if group < state.groups:\n                if not state.checkgroup(group):\n                    raise source.error(\"cannot refer to an open group\",\n                                       len(escape))\n                state.checklookbehindgroup(group, source)\n                return GROUPREF, group\n            raise source.error(\"invalid group reference %d\" % group, len(escape) - 1)\n        if len(escape) == 2:\n            if c in ASCIILETTERS:\n                raise source.error(\"bad escape %s\" % escape, len(escape))\n            return LITERAL, ord(escape[1])\n    except ValueError:\n        pass\n    raise source.error(\"bad escape %s\" % escape, len(escape))\n\ndef _uniq(items):\n    return list(dict.fromkeys(items))\n\ndef _parse_sub(source, state, verbose, nested):\n    # parse an alternation: a|b|c\n\n    items = []\n    itemsappend = items.append\n    sourcematch = source.match\n    start = source.tell()\n    while True:\n        itemsappend(_parse(source, state, verbose, nested + 1,\n                           not nested and not items))\n        if not sourcematch(\"|\"):\n            break\n        if not nested:\n            verbose = state.flags & SRE_FLAG_VERBOSE\n\n    if len(items) == 1:\n        return items[0]\n\n    subpattern = SubPattern(state)\n\n    # check if all items share a common prefix\n    while True:\n        prefix = None\n        for item in items:\n            if not item:\n                break\n            if prefix is None:\n                prefix = item[0]\n            elif item[0] != prefix:\n                break\n        else:\n            # all subitems start with a common \"prefix\".\n            # move it out of the branch\n            for item in items:\n                del item[0]\n            subpattern.append(prefix)\n            continue # check next one\n        break\n\n    # check if the branch can be replaced by a character set\n    set = []\n    for item in items:\n        if len(item) != 1:\n            break\n        op, av = item[0]\n        if op is LITERAL:\n            set.append((op, av))\n        elif op is IN and av[0][0] is not NEGATE:\n            set.extend(av)\n        else:\n            break\n    else:\n        # we can store this as a character set instead of a\n        # branch (the compiler may optimize this even more)\n        subpattern.append((IN, _uniq(set)))\n        return subpattern\n\n    subpattern.append((BRANCH, (None, items)))\n    return subpattern\n\ndef _parse(source, state, verbose, nested, first=False):\n    # parse a simple pattern\n    subpattern = SubPattern(state)\n\n    # precompute constants into local variables\n    subpatternappend = subpattern.append\n    sourceget = source.get\n    sourcematch = source.match\n    _len = len\n    _ord = ord\n\n    while True:\n\n        this = source.next\n        if this is None:\n            break # end of pattern\n        if this in \"|)\":\n            break # end of subpattern\n        sourceget()\n\n        if verbose:\n            # skip whitespace and comments\n            if this in WHITESPACE:\n                continue\n            if this == \"#\":\n                while True:\n                    this = sourceget()\n                    if this is None or this == \"\\n\":\n                        break\n                continue\n\n        if this[0] == \"\\\\\":\n            code = _escape(source, this, state)\n            subpatternappend(code)\n\n        elif this not in SPECIAL_CHARS:\n            subpatternappend((LITERAL, _ord(this)))\n\n        elif this == \"[\":\n            here = source.tell() - 1\n            # character set\n            set = []\n            setappend = set.append\n##          if sourcematch(\":\"):\n##              pass # handle character classes\n            if source.next == '[':\n                import warnings\n                warnings.warn(\n                    'Possible nested set at position %d' % source.tell(),\n                    FutureWarning, stacklevel=nested + 6\n                )\n            negate = sourcematch(\"^\")\n            # check remaining characters\n            while True:\n                this = sourceget()\n                if this is None:\n                    raise source.error(\"unterminated character set\",\n                                       source.tell() - here)\n                if this == \"]\" and set:\n                    break\n                elif this[0] == \"\\\\\":\n                    code1 = _class_escape(source, this)\n                else:\n                    if set and this in '-&~|' and source.next == this:\n                        import warnings\n                        warnings.warn(\n                            'Possible set %s at position %d' % (\n                                'difference' if this == '-' else\n                                'intersection' if this == '&' else\n                                'symmetric difference' if this == '~' else\n                                'union',\n                                source.tell() - 1),\n                            FutureWarning, stacklevel=nested + 6\n                        )\n                    code1 = LITERAL, _ord(this)\n                if sourcematch(\"-\"):\n                    # potential range\n                    that = sourceget()\n                    if that is None:\n                        raise source.error(\"unterminated character set\",\n                                           source.tell() - here)\n                    if that == \"]\":\n                        if code1[0] is IN:\n                            code1 = code1[1][0]\n                        setappend(code1)\n                        setappend((LITERAL, _ord(\"-\")))\n                        break\n                    if that[0] == \"\\\\\":\n                        code2 = _class_escape(source, that)\n                    else:\n                        if that == '-':\n                            import warnings\n                            warnings.warn(\n                                'Possible set difference at position %d' % (\n                                    source.tell() - 2),\n                                FutureWarning, stacklevel=nested + 6\n                            )\n                        code2 = LITERAL, _ord(that)\n                    if code1[0] != LITERAL or code2[0] != LITERAL:\n                        msg = \"bad character range %s-%s\" % (this, that)\n                        raise source.error(msg, len(this) + 1 + len(that))\n                    lo = code1[1]\n                    hi = code2[1]\n                    if hi < lo:\n                        msg = \"bad character range %s-%s\" % (this, that)\n                        raise source.error(msg, len(this) + 1 + len(that))\n                    setappend((RANGE, (lo, hi)))\n                else:\n                    if code1[0] is IN:\n                        code1 = code1[1][0]\n                    setappend(code1)\n\n            set = _uniq(set)\n            # XXX: <fl> should move set optimization to compiler!\n            if _len(set) == 1 and set[0][0] is LITERAL:\n                # optimization\n                if negate:\n                    subpatternappend((NOT_LITERAL, set[0][1]))\n                else:\n                    subpatternappend(set[0])\n            else:\n                if negate:\n                    set.insert(0, (NEGATE, None))\n                # charmap optimization can't be added here because\n                # global flags still are not known\n                subpatternappend((IN, set))\n\n        elif this in REPEAT_CHARS:\n            # repeat previous item\n            here = source.tell()\n            if this == \"?\":\n                min, max = 0, 1\n            elif this == \"*\":\n                min, max = 0, MAXREPEAT\n\n            elif this == \"+\":\n                min, max = 1, MAXREPEAT\n            elif this == \"{\":\n                if source.next == \"}\":\n                    subpatternappend((LITERAL, _ord(this)))\n                    continue\n\n                min, max = 0, MAXREPEAT\n                lo = hi = \"\"\n                while source.next in DIGITS:\n                    lo += sourceget()\n                if sourcematch(\",\"):\n                    while source.next in DIGITS:\n                        hi += sourceget()\n                else:\n                    hi = lo\n                if not sourcematch(\"}\"):\n                    subpatternappend((LITERAL, _ord(this)))\n                    source.seek(here)\n                    continue\n\n                if lo:\n                    min = int(lo)\n                    if min >= MAXREPEAT:\n                        raise OverflowError(\"the repetition number is too large\")\n                if hi:\n                    max = int(hi)\n                    if max >= MAXREPEAT:\n                        raise OverflowError(\"the repetition number is too large\")\n                    if max < min:\n                        raise source.error(\"min repeat greater than max repeat\",\n                                           source.tell() - here)\n            else:\n                raise AssertionError(\"unsupported quantifier %r\" % (char,))\n            # figure out which item to repeat\n            if subpattern:\n                item = subpattern[-1:]\n            else:\n                item = None\n            if not item or item[0][0] is AT:\n                raise source.error(\"nothing to repeat\",\n                                   source.tell() - here + len(this))\n            if item[0][0] in _REPEATCODES:\n                raise source.error(\"multiple repeat\",\n                                   source.tell() - here + len(this))\n            if item[0][0] is SUBPATTERN:\n                group, add_flags, del_flags, p = item[0][1]\n                if group is None and not add_flags and not del_flags:\n                    item = p\n            if sourcematch(\"?\"):\n                # Non-Greedy Match\n                subpattern[-1] = (MIN_REPEAT, (min, max, item))\n            elif sourcematch(\"+\"):\n                # Possessive Match (Always Greedy)\n                subpattern[-1] = (POSSESSIVE_REPEAT, (min, max, item))\n            else:\n                # Greedy Match\n                subpattern[-1] = (MAX_REPEAT, (min, max, item))\n\n        elif this == \".\":\n            subpatternappend((ANY, None))\n\n        elif this == \"(\":\n            start = source.tell() - 1\n            capture = True\n            atomic = False\n            name = None\n            add_flags = 0\n            del_flags = 0\n            if sourcematch(\"?\"):\n                # options\n                char = sourceget()\n                if char is None:\n                    raise source.error(\"unexpected end of pattern\")\n                if char == \"P\":\n                    # python extensions\n                    if sourcematch(\"<\"):\n                        # named group: skip forward to end of name\n                        name = source.getuntil(\">\", \"group name\")\n                        source.checkgroupname(name, 1, nested)\n                    elif sourcematch(\"=\"):\n                        # named backreference\n                        name = source.getuntil(\")\", \"group name\")\n                        source.checkgroupname(name, 1, nested)\n                        gid = state.groupdict.get(name)\n                        if gid is None:\n                            msg = \"unknown group name %r\" % name\n                            raise source.error(msg, len(name) + 1)\n                        if not state.checkgroup(gid):\n                            raise source.error(\"cannot refer to an open group\",\n                                               len(name) + 1)\n                        state.checklookbehindgroup(gid, source)\n                        subpatternappend((GROUPREF, gid))\n                        continue\n\n                    else:\n                        char = sourceget()\n                        if char is None:\n                            raise source.error(\"unexpected end of pattern\")\n                        raise source.error(\"unknown extension ?P\" + char,\n                                           len(char) + 2)\n                elif char == \":\":\n                    # non-capturing group\n                    capture = False\n                elif char == \"#\":\n                    # comment\n                    while True:\n                        if source.next is None:\n                            raise source.error(\"missing ), unterminated comment\",\n                                               source.tell() - start)\n                        if sourceget() == \")\":\n                            break\n                    continue\n\n                elif char in \"=!<\":\n                    # lookahead assertions\n                    dir = 1\n                    if char == \"<\":\n                        char = sourceget()\n                        if char is None:\n                            raise source.error(\"unexpected end of pattern\")\n                        if char not in \"=!\":\n                            raise source.error(\"unknown extension ?<\" + char,\n                                               len(char) + 2)\n                        dir = -1 # lookbehind\n                        lookbehindgroups = state.lookbehindgroups\n                        if lookbehindgroups is None:\n                            state.lookbehindgroups = state.groups\n                    p = _parse_sub(source, state, verbose, nested + 1)\n                    if dir < 0:\n                        if lookbehindgroups is None:\n                            state.lookbehindgroups = None\n                    if not sourcematch(\")\"):\n                        raise source.error(\"missing ), unterminated subpattern\",\n                                           source.tell() - start)\n                    if char == \"=\":\n                        subpatternappend((ASSERT, (dir, p)))\n                    else:\n                        subpatternappend((ASSERT_NOT, (dir, p)))\n                    continue\n\n                elif char == \"(\":\n                    # conditional backreference group\n                    condname = source.getuntil(\")\", \"group name\")\n                    if condname.isidentifier():\n                        source.checkgroupname(condname, 1, nested)\n                        condgroup = state.groupdict.get(condname)\n                        if condgroup is None:\n                            msg = \"unknown group name %r\" % condname\n                            raise source.error(msg, len(condname) + 1)\n                    else:\n                        try:\n                            condgroup = int(condname)\n                            if condgroup < 0:\n                                raise ValueError\n                        except ValueError:\n                            msg = \"bad character in group name %r\" % condname\n                            raise source.error(msg, len(condname) + 1) from None\n                        if not condgroup:\n                            raise source.error(\"bad group number\",\n                                               len(condname) + 1)\n                        if condgroup >= MAXGROUPS:\n                            msg = \"invalid group reference %d\" % condgroup\n                            raise source.error(msg, len(condname) + 1)\n                        if condgroup not in state.grouprefpos:\n                            state.grouprefpos[condgroup] = (\n                                source.tell() - len(condname) - 1\n                            )\n                        if not (condname.isdecimal() and condname.isascii()):\n                            import warnings\n                            warnings.warn(\n                                \"bad character in group name %s at position %d\" %\n                                (repr(condname) if source.istext else ascii(condname),\n                                 source.tell() - len(condname) - 1),\n                                DeprecationWarning, stacklevel=nested + 6\n                            )\n                    state.checklookbehindgroup(condgroup, source)\n                    item_yes = _parse(source, state, verbose, nested + 1)\n                    if source.match(\"|\"):\n                        item_no = _parse(source, state, verbose, nested + 1)\n                        if source.next == \"|\":\n                            raise source.error(\"conditional backref with more than two branches\")\n                    else:\n                        item_no = None\n                    if not source.match(\")\"):\n                        raise source.error(\"missing ), unterminated subpattern\",\n                                           source.tell() - start)\n                    subpatternappend((GROUPREF_EXISTS, (condgroup, item_yes, item_no)))\n                    continue\n\n                elif char == \">\":\n                    # non-capturing, atomic group\n                    capture = False\n                    atomic = True\n                elif char in FLAGS or char == \"-\":\n                    # flags\n                    flags = _parse_flags(source, state, char)\n                    if flags is None:  # global flags\n                        if not first or subpattern:\n                            raise source.error('global flags not at the start '\n                                               'of the expression',\n                                               source.tell() - start)\n                        verbose = state.flags & SRE_FLAG_VERBOSE\n                        continue\n\n                    add_flags, del_flags = flags\n                    capture = False\n                else:\n                    raise source.error(\"unknown extension ?\" + char,\n                                       len(char) + 1)\n\n            # parse group contents\n            if capture:\n                try:\n                    group = state.opengroup(name)\n                except error as err:\n                    raise source.error(err.msg, len(name) + 1) from None\n            else:\n                group = None\n            sub_verbose = ((verbose or (add_flags & SRE_FLAG_VERBOSE)) and\n                           not (del_flags & SRE_FLAG_VERBOSE))\n            p = _parse_sub(source, state, sub_verbose, nested + 1)\n            if not source.match(\")\"):\n                raise source.error(\"missing ), unterminated subpattern\",\n                                   source.tell() - start)\n            if group is not None:\n                state.closegroup(group, p)\n            if atomic:\n                assert group is None\n                subpatternappend((ATOMIC_GROUP, p))\n            else:\n                subpatternappend((SUBPATTERN, (group, add_flags, del_flags, p)))\n\n        elif this == \"^\":\n            subpatternappend((AT, AT_BEGINNING))\n\n        elif this == \"$\":\n            subpatternappend((AT, AT_END))\n\n        else:\n            raise AssertionError(\"unsupported special character %r\" % (char,))\n\n    # unpack non-capturing groups\n    for i in range(len(subpattern))[::-1]:\n        op, av = subpattern[i]\n        if op is SUBPATTERN:\n            group, add_flags, del_flags, p = av\n            if group is None and not add_flags and not del_flags:\n                subpattern[i: i+1] = p\n\n    return subpattern\n\ndef _parse_flags(source, state, char):\n    sourceget = source.get\n    add_flags = 0\n    del_flags = 0\n    if char != \"-\":\n        while True:\n            flag = FLAGS[char]\n            if source.istext:\n                if char == 'L':\n                    msg = \"bad inline flags: cannot use 'L' flag with a str pattern\"\n                    raise source.error(msg)\n            else:\n                if char == 'u':\n                    msg = \"bad inline flags: cannot use 'u' flag with a bytes pattern\"\n                    raise source.error(msg)\n            add_flags |= flag\n            if (flag & TYPE_FLAGS) and (add_flags & TYPE_FLAGS) != flag:\n                msg = \"bad inline flags: flags 'a', 'u' and 'L' are incompatible\"\n                raise source.error(msg)\n            char = sourceget()\n            if char is None:\n                raise source.error(\"missing -, : or )\")\n            if char in \")-:\":\n                break\n            if char not in FLAGS:\n                msg = \"unknown flag\" if char.isalpha() else \"missing -, : or )\"\n                raise source.error(msg, len(char))\n    if char == \")\":\n        state.flags |= add_flags\n        return None\n    if add_flags & GLOBAL_FLAGS:\n        raise source.error(\"bad inline flags: cannot turn on global flag\", 1)\n    if char == \"-\":\n        char = sourceget()\n        if char is None:\n            raise source.error(\"missing flag\")\n        if char not in FLAGS:\n            msg = \"unknown flag\" if char.isalpha() else \"missing flag\"\n            raise source.error(msg, len(char))\n        while True:\n            flag = FLAGS[char]\n            if flag & TYPE_FLAGS:\n                msg = \"bad inline flags: cannot turn off flags 'a', 'u' and 'L'\"\n                raise source.error(msg)\n            del_flags |= flag\n            char = sourceget()\n            if char is None:\n                raise source.error(\"missing :\")\n            if char == \":\":\n                break\n            if char not in FLAGS:\n                msg = \"unknown flag\" if char.isalpha() else \"missing :\"\n                raise source.error(msg, len(char))\n    assert char == \":\"\n    if del_flags & GLOBAL_FLAGS:\n        raise source.error(\"bad inline flags: cannot turn off global flag\", 1)\n    if add_flags & del_flags:\n        raise source.error(\"bad inline flags: flag turned on and off\", 1)\n    return add_flags, del_flags\n\ndef fix_flags(src, flags):\n    # Check and fix flags according to the type of pattern (str or bytes)\n    if isinstance(src, str):\n        if flags & SRE_FLAG_LOCALE:\n            raise ValueError(\"cannot use LOCALE flag with a str pattern\")\n        if not flags & SRE_FLAG_ASCII:\n            flags |= SRE_FLAG_UNICODE\n        elif flags & SRE_FLAG_UNICODE:\n            raise ValueError(\"ASCII and UNICODE flags are incompatible\")\n    else:\n        if flags & SRE_FLAG_UNICODE:\n            raise ValueError(\"cannot use UNICODE flag with a bytes pattern\")\n        if flags & SRE_FLAG_LOCALE and flags & SRE_FLAG_ASCII:\n            raise ValueError(\"ASCII and LOCALE flags are incompatible\")\n    return flags\n\ndef parse(str, flags=0, state=None):\n    # parse 're' pattern into list of (opcode, argument) tuples\n\n    source = Tokenizer(str)\n\n    if state is None:\n        state = State()\n    state.flags = flags\n    state.str = str\n\n    p = _parse_sub(source, state, flags & SRE_FLAG_VERBOSE, 0)\n    p.state.flags = fix_flags(str, p.state.flags)\n\n    if source.next is not None:\n        assert source.next == \")\"\n        raise source.error(\"unbalanced parenthesis\")\n\n    for g in p.state.grouprefpos:\n        if g >= p.state.groups:\n            msg = \"invalid group reference %d\" % g\n            raise error(msg, str, p.state.grouprefpos[g])\n\n    if flags & SRE_FLAG_DEBUG:\n        p.dump()\n\n    return p\n\ndef parse_template(source, state):\n    # parse 're' replacement string into list of literals and\n    # group references\n    s = Tokenizer(source)\n    sget = s.get\n    groups = []\n    literals = []\n    literal = []\n    lappend = literal.append\n    def addgroup(index, pos):\n        if index > state.groups:\n            raise s.error(\"invalid group reference %d\" % index, pos)\n        if literal:\n            literals.append(''.join(literal))\n            del literal[:]\n        groups.append((len(literals), index))\n        literals.append(None)\n    groupindex = state.groupindex\n    while True:\n        this = sget()\n        if this is None:\n            break # end of replacement string\n        if this[0] == \"\\\\\":\n            # group\n            c = this[1]\n            if c == \"g\":\n                if not s.match(\"<\"):\n                    raise s.error(\"missing <\")\n                name = s.getuntil(\">\", \"group name\")\n                if name.isidentifier():\n                    s.checkgroupname(name, 1, -1)\n                    try:\n                        index = groupindex[name]\n                    except KeyError:\n                        raise IndexError(\"unknown group name %r\" % name) from None\n                else:\n                    try:\n                        index = int(name)\n                        if index < 0:\n                            raise ValueError\n                    except ValueError:\n                        raise s.error(\"bad character in group name %r\" % name,\n                                      len(name) + 1) from None\n                    if index >= MAXGROUPS:\n                        raise s.error(\"invalid group reference %d\" % index,\n                                      len(name) + 1)\n                    if not (name.isdecimal() and name.isascii()):\n                        import warnings\n                        warnings.warn(\n                            \"bad character in group name %s at position %d\" %\n                            (repr(name) if s.istext else ascii(name),\n                             s.tell() - len(name) - 1),\n                            DeprecationWarning, stacklevel=5\n                        )\n                addgroup(index, len(name) + 1)\n            elif c == \"0\":\n                if s.next in OCTDIGITS:\n                    this += sget()\n                    if s.next in OCTDIGITS:\n                        this += sget()\n                lappend(chr(int(this[1:], 8) & 0xff))\n            elif c in DIGITS:\n                isoctal = False\n                if s.next in DIGITS:\n                    this += sget()\n                    if (c in OCTDIGITS and this[2] in OCTDIGITS and\n                        s.next in OCTDIGITS):\n                        this += sget()\n                        isoctal = True\n                        c = int(this[1:], 8)\n                        if c > 0o377:\n                            raise s.error('octal escape value %s outside of '\n                                          'range 0-0o377' % this, len(this))\n                        lappend(chr(c))\n                if not isoctal:\n                    addgroup(int(this[1:]), len(this) - 1)\n            else:\n                try:\n                    this = chr(ESCAPES[this][1])\n                except KeyError:\n                    if c in ASCIILETTERS:\n                        raise s.error('bad escape %s' % this, len(this)) from None\n                lappend(this)\n        else:\n            lappend(this)\n    if literal:\n        literals.append(''.join(literal))\n    if not isinstance(source, str):\n        # The tokenizer implicitly decodes bytes objects as latin-1, we must\n        # therefore re-encode the final representation.\n        literals = [None if s is None else s.encode('latin-1') for s in literals]\n    return groups, literals\n\ndef expand_template(template, match):\n    g = match.group\n    empty = match.string[:0]\n    groups, literals = template\n    literals = literals[:]\n    try:\n        for index, group in groups:\n            literals[index] = g(group) or empty\n    except IndexError:\n        raise error(\"invalid group reference %d\" % index) from None\n    return empty.join(literals)\n",1100],"/home/ma-user/anaconda3/envs/py311/lib/python3.11/socket.py":["# Wrapper module for _socket, providing some additional facilities\n# implemented in Python.\n\n\"\"\"\\\nThis module provides socket operations and some related functions.\nOn Unix, it supports IP (Internet Protocol) and Unix domain sockets.\nOn other systems, it only supports IP. Functions specific for a\nsocket are available as methods of the socket object.\n\nFunctions:\n\nsocket() -- create a new socket object\nsocketpair() -- create a pair of new socket objects [*]\nfromfd() -- create a socket object from an open file descriptor [*]\nsend_fds() -- Send file descriptor to the socket.\nrecv_fds() -- Receive file descriptors from the socket.\nfromshare() -- create a socket object from data received from socket.share() [*]\ngethostname() -- return the current hostname\ngethostbyname() -- map a hostname to its IP number\ngethostbyaddr() -- map an IP number or hostname to DNS info\ngetservbyname() -- map a service name and a protocol name to a port number\ngetprotobyname() -- map a protocol name (e.g. 'tcp') to a number\nntohs(), ntohl() -- convert 16, 32 bit int from network to host byte order\nhtons(), htonl() -- convert 16, 32 bit int from host to network byte order\ninet_aton() -- convert IP addr string (123.45.67.89) to 32-bit packed format\ninet_ntoa() -- convert 32-bit packed format IP to string (123.45.67.89)\nsocket.getdefaulttimeout() -- get the default timeout value\nsocket.setdefaulttimeout() -- set the default timeout value\ncreate_connection() -- connects to an address, with an optional timeout and\n                       optional source address.\n\n [*] not available on all platforms!\n\nSpecial objects:\n\nSocketType -- type object for socket objects\nerror -- exception raised for I/O errors\nhas_ipv6 -- boolean value indicating if IPv6 is supported\n\nIntEnum constants:\n\nAF_INET, AF_UNIX -- socket domains (first argument to socket() call)\nSOCK_STREAM, SOCK_DGRAM, SOCK_RAW -- socket types (second argument)\n\nInteger constants:\n\nMany other constants may be defined; these may be used in calls to\nthe setsockopt() and getsockopt() methods.\n\"\"\"\n\nimport _socket\nfrom _socket import *\n\nimport os, sys, io, selectors\nfrom enum import IntEnum, IntFlag\n\ntry:\n    import errno\nexcept ImportError:\n    errno = None\nEBADF = getattr(errno, 'EBADF', 9)\nEAGAIN = getattr(errno, 'EAGAIN', 11)\nEWOULDBLOCK = getattr(errno, 'EWOULDBLOCK', 11)\n\n__all__ = [\"fromfd\", \"getfqdn\", \"create_connection\", \"create_server\",\n           \"has_dualstack_ipv6\", \"AddressFamily\", \"SocketKind\"]\n__all__.extend(os._get_exports_list(_socket))\n\n# Set up the socket.AF_* socket.SOCK_* constants as members of IntEnums for\n# nicer string representations.\n# Note that _socket only knows about the integer values. The public interface\n# in this module understands the enums and translates them back from integers\n# where needed (e.g. .family property of a socket object).\n\nIntEnum._convert_(\n        'AddressFamily',\n        __name__,\n        lambda C: C.isupper() and C.startswith('AF_'))\n\nIntEnum._convert_(\n        'SocketKind',\n        __name__,\n        lambda C: C.isupper() and C.startswith('SOCK_'))\n\nIntFlag._convert_(\n        'MsgFlag',\n        __name__,\n        lambda C: C.isupper() and C.startswith('MSG_'))\n\nIntFlag._convert_(\n        'AddressInfo',\n        __name__,\n        lambda C: C.isupper() and C.startswith('AI_'))\n\n_LOCALHOST    = '127.0.0.1'\n_LOCALHOST_V6 = '::1'\n\n\ndef _intenum_converter(value, enum_klass):\n    \"\"\"Convert a numeric family value to an IntEnum member.\n\n    If it's not a known member, return the numeric value itself.\n    \"\"\"\n    try:\n        return enum_klass(value)\n    except ValueError:\n        return value\n\n\n# WSA error codes\nif sys.platform.lower().startswith(\"win\"):\n    errorTab = {}\n    errorTab[6] = \"Specified event object handle is invalid.\"\n    errorTab[8] = \"Insufficient memory available.\"\n    errorTab[87] = \"One or more parameters are invalid.\"\n    errorTab[995] = \"Overlapped operation aborted.\"\n    errorTab[996] = \"Overlapped I/O event object not in signaled state.\"\n    errorTab[997] = \"Overlapped operation will complete later.\"\n    errorTab[10004] = \"The operation was interrupted.\"\n    errorTab[10009] = \"A bad file handle was passed.\"\n    errorTab[10013] = \"Permission denied.\"\n    errorTab[10014] = \"A fault occurred on the network??\"  # WSAEFAULT\n    errorTab[10022] = \"An invalid operation was attempted.\"\n    errorTab[10024] = \"Too many open files.\"\n    errorTab[10035] = \"The socket operation would block.\"\n    errorTab[10036] = \"A blocking operation is already in progress.\"\n    errorTab[10037] = \"Operation already in progress.\"\n    errorTab[10038] = \"Socket operation on nonsocket.\"\n    errorTab[10039] = \"Destination address required.\"\n    errorTab[10040] = \"Message too long.\"\n    errorTab[10041] = \"Protocol wrong type for socket.\"\n    errorTab[10042] = \"Bad protocol option.\"\n    errorTab[10043] = \"Protocol not supported.\"\n    errorTab[10044] = \"Socket type not supported.\"\n    errorTab[10045] = \"Operation not supported.\"\n    errorTab[10046] = \"Protocol family not supported.\"\n    errorTab[10047] = \"Address family not supported by protocol family.\"\n    errorTab[10048] = \"The network address is in use.\"\n    errorTab[10049] = \"Cannot assign requested address.\"\n    errorTab[10050] = \"Network is down.\"\n    errorTab[10051] = \"Network is unreachable.\"\n    errorTab[10052] = \"Network dropped connection on reset.\"\n    errorTab[10053] = \"Software caused connection abort.\"\n    errorTab[10054] = \"The connection has been reset.\"\n    errorTab[10055] = \"No buffer space available.\"\n    errorTab[10056] = \"Socket is already connected.\"\n    errorTab[10057] = \"Socket is not connected.\"\n    errorTab[10058] = \"The network has been shut down.\"\n    errorTab[10059] = \"Too many references.\"\n    errorTab[10060] = \"The operation timed out.\"\n    errorTab[10061] = \"Connection refused.\"\n    errorTab[10062] = \"Cannot translate name.\"\n    errorTab[10063] = \"The name is too long.\"\n    errorTab[10064] = \"The host is down.\"\n    errorTab[10065] = \"The host is unreachable.\"\n    errorTab[10066] = \"Directory not empty.\"\n    errorTab[10067] = \"Too many processes.\"\n    errorTab[10068] = \"User quota exceeded.\"\n    errorTab[10069] = \"Disk quota exceeded.\"\n    errorTab[10070] = \"Stale file handle reference.\"\n    errorTab[10071] = \"Item is remote.\"\n    errorTab[10091] = \"Network subsystem is unavailable.\"\n    errorTab[10092] = \"Winsock.dll version out of range.\"\n    errorTab[10093] = \"Successful WSAStartup not yet performed.\"\n    errorTab[10101] = \"Graceful shutdown in progress.\"\n    errorTab[10102] = \"No more results from WSALookupServiceNext.\"\n    errorTab[10103] = \"Call has been canceled.\"\n    errorTab[10104] = \"Procedure call table is invalid.\"\n    errorTab[10105] = \"Service provider is invalid.\"\n    errorTab[10106] = \"Service provider failed to initialize.\"\n    errorTab[10107] = \"System call failure.\"\n    errorTab[10108] = \"Service not found.\"\n    errorTab[10109] = \"Class type not found.\"\n    errorTab[10110] = \"No more results from WSALookupServiceNext.\"\n    errorTab[10111] = \"Call was canceled.\"\n    errorTab[10112] = \"Database query was refused.\"\n    errorTab[11001] = \"Host not found.\"\n    errorTab[11002] = \"Nonauthoritative host not found.\"\n    errorTab[11003] = \"This is a nonrecoverable error.\"\n    errorTab[11004] = \"Valid name, no data record requested type.\"\n    errorTab[11005] = \"QoS receivers.\"\n    errorTab[11006] = \"QoS senders.\"\n    errorTab[11007] = \"No QoS senders.\"\n    errorTab[11008] = \"QoS no receivers.\"\n    errorTab[11009] = \"QoS request confirmed.\"\n    errorTab[11010] = \"QoS admission error.\"\n    errorTab[11011] = \"QoS policy failure.\"\n    errorTab[11012] = \"QoS bad style.\"\n    errorTab[11013] = \"QoS bad object.\"\n    errorTab[11014] = \"QoS traffic control error.\"\n    errorTab[11015] = \"QoS generic error.\"\n    errorTab[11016] = \"QoS service type error.\"\n    errorTab[11017] = \"QoS flowspec error.\"\n    errorTab[11018] = \"Invalid QoS provider buffer.\"\n    errorTab[11019] = \"Invalid QoS filter style.\"\n    errorTab[11020] = \"Invalid QoS filter style.\"\n    errorTab[11021] = \"Incorrect QoS filter count.\"\n    errorTab[11022] = \"Invalid QoS object length.\"\n    errorTab[11023] = \"Incorrect QoS flow count.\"\n    errorTab[11024] = \"Unrecognized QoS object.\"\n    errorTab[11025] = \"Invalid QoS policy object.\"\n    errorTab[11026] = \"Invalid QoS flow descriptor.\"\n    errorTab[11027] = \"Invalid QoS provider-specific flowspec.\"\n    errorTab[11028] = \"Invalid QoS provider-specific filterspec.\"\n    errorTab[11029] = \"Invalid QoS shape discard mode object.\"\n    errorTab[11030] = \"Invalid QoS shaping rate object.\"\n    errorTab[11031] = \"Reserved policy QoS element type.\"\n    __all__.append(\"errorTab\")\n\n\nclass _GiveupOnSendfile(Exception): pass\n\n\nclass socket(_socket.socket):\n\n    \"\"\"A subclass of _socket.socket adding the makefile() method.\"\"\"\n\n    __slots__ = [\"__weakref__\", \"_io_refs\", \"_closed\"]\n\n    def __init__(self, family=-1, type=-1, proto=-1, fileno=None):\n        # For user code address family and type values are IntEnum members, but\n        # for the underlying _socket.socket they're just integers. The\n        # constructor of _socket.socket converts the given argument to an\n        # integer automatically.\n        if fileno is None:\n            if family == -1:\n                family = AF_INET\n            if type == -1:\n                type = SOCK_STREAM\n            if proto == -1:\n                proto = 0\n        _socket.socket.__init__(self, family, type, proto, fileno)\n        self._io_refs = 0\n        self._closed = False\n\n    def __enter__(self):\n        return self\n\n    def __exit__(self, *args):\n        if not self._closed:\n            self.close()\n\n    def __repr__(self):\n        \"\"\"Wrap __repr__() to reveal the real class name and socket\n        address(es).\n        \"\"\"\n        closed = getattr(self, '_closed', False)\n        s = \"<%s.%s%s fd=%i, family=%s, type=%s, proto=%i\" \\\n            % (self.__class__.__module__,\n               self.__class__.__qualname__,\n               \" [closed]\" if closed else \"\",\n               self.fileno(),\n               self.family,\n               self.type,\n               self.proto)\n        if not closed:\n            try:\n                laddr = self.getsockname()\n                if laddr:\n                    s += \", laddr=%s\" % str(laddr)\n            except error:\n                pass\n            try:\n                raddr = self.getpeername()\n                if raddr:\n                    s += \", raddr=%s\" % str(raddr)\n            except error:\n                pass\n        s += '>'\n        return s\n\n    def __getstate__(self):\n        raise TypeError(f\"cannot pickle {self.__class__.__name__!r} object\")\n\n    def dup(self):\n        \"\"\"dup() -> socket object\n\n        Duplicate the socket. Return a new socket object connected to the same\n        system resource. The new socket is non-inheritable.\n        \"\"\"\n        fd = dup(self.fileno())\n        sock = self.__class__(self.family, self.type, self.proto, fileno=fd)\n        sock.settimeout(self.gettimeout())\n        return sock\n\n    def accept(self):\n        \"\"\"accept() -> (socket object, address info)\n\n        Wait for an incoming connection.  Return a new socket\n        representing the connection, and the address of the client.\n        For IP sockets, the address info is a pair (hostaddr, port).\n        \"\"\"\n        fd, addr = self._accept()\n        sock = socket(self.family, self.type, self.proto, fileno=fd)\n        # Issue #7995: if no default timeout is set and the listening\n        # socket had a (non-zero) timeout, force the new socket in blocking\n        # mode to override platform-specific socket flags inheritance.\n        if getdefaulttimeout() is None and self.gettimeout():\n            sock.setblocking(True)\n        return sock, addr\n\n    def makefile(self, mode=\"r\", buffering=None, *,\n                 encoding=None, errors=None, newline=None):\n        \"\"\"makefile(...) -> an I/O stream connected to the socket\n\n        The arguments are as for io.open() after the filename, except the only\n        supported mode values are 'r' (default), 'w' and 'b'.\n        \"\"\"\n        # XXX refactor to share code?\n        if not set(mode) <= {\"r\", \"w\", \"b\"}:\n            raise ValueError(\"invalid mode %r (only r, w, b allowed)\" % (mode,))\n        writing = \"w\" in mode\n        reading = \"r\" in mode or not writing\n        assert reading or writing\n        binary = \"b\" in mode\n        rawmode = \"\"\n        if reading:\n            rawmode += \"r\"\n        if writing:\n            rawmode += \"w\"\n        raw = SocketIO(self, rawmode)\n        self._io_refs += 1\n        if buffering is None:\n            buffering = -1\n        if buffering < 0:\n            buffering = io.DEFAULT_BUFFER_SIZE\n        if buffering == 0:\n            if not binary:\n                raise ValueError(\"unbuffered streams must be binary\")\n            return raw\n        if reading and writing:\n            buffer = io.BufferedRWPair(raw, raw, buffering)\n        elif reading:\n            buffer = io.BufferedReader(raw, buffering)\n        else:\n            assert writing\n            buffer = io.BufferedWriter(raw, buffering)\n        if binary:\n            return buffer\n        encoding = io.text_encoding(encoding)\n        text = io.TextIOWrapper(buffer, encoding, errors, newline)\n        text.mode = mode\n        return text\n\n    if hasattr(os, 'sendfile'):\n\n        def _sendfile_use_sendfile(self, file, offset=0, count=None):\n            self._check_sendfile_params(file, offset, count)\n            sockno = self.fileno()\n            try:\n                fileno = file.fileno()\n            except (AttributeError, io.UnsupportedOperation) as err:\n                raise _GiveupOnSendfile(err)  # not a regular file\n            try:\n                fsize = os.fstat(fileno).st_size\n            except OSError as err:\n                raise _GiveupOnSendfile(err)  # not a regular file\n            if not fsize:\n                return 0  # empty file\n            # Truncate to 1GiB to avoid OverflowError, see bpo-38319.\n            blocksize = min(count or fsize, 2 ** 30)\n            timeout = self.gettimeout()\n            if timeout == 0:\n                raise ValueError(\"non-blocking sockets are not supported\")\n            # poll/select have the advantage of not requiring any\n            # extra file descriptor, contrarily to epoll/kqueue\n            # (also, they require a single syscall).\n            if hasattr(selectors, 'PollSelector'):\n                selector = selectors.PollSelector()\n            else:\n                selector = selectors.SelectSelector()\n            selector.register(sockno, selectors.EVENT_WRITE)\n\n            total_sent = 0\n            # localize variable access to minimize overhead\n            selector_select = selector.select\n            os_sendfile = os.sendfile\n            try:\n                while True:\n                    if timeout and not selector_select(timeout):\n                        raise TimeoutError('timed out')\n                    if count:\n                        blocksize = count - total_sent\n                        if blocksize <= 0:\n                            break\n                    try:\n                        sent = os_sendfile(sockno, fileno, offset, blocksize)\n                    except BlockingIOError:\n                        if not timeout:\n                            # Block until the socket is ready to send some\n                            # data; avoids hogging CPU resources.\n                            selector_select()\n                        continue\n                    except OSError as err:\n                        if total_sent == 0:\n                            # We can get here for different reasons, the main\n                            # one being 'file' is not a regular mmap(2)-like\n                            # file, in which case we'll fall back on using\n                            # plain send().\n                            raise _GiveupOnSendfile(err)\n                        raise err from None\n                    else:\n                        if sent == 0:\n                            break  # EOF\n                        offset += sent\n                        total_sent += sent\n                return total_sent\n            finally:\n                if total_sent > 0 and hasattr(file, 'seek'):\n                    file.seek(offset)\n    else:\n        def _sendfile_use_sendfile(self, file, offset=0, count=None):\n            raise _GiveupOnSendfile(\n                \"os.sendfile() not available on this platform\")\n\n    def _sendfile_use_send(self, file, offset=0, count=None):\n        self._check_sendfile_params(file, offset, count)\n        if self.gettimeout() == 0:\n            raise ValueError(\"non-blocking sockets are not supported\")\n        if offset:\n            file.seek(offset)\n        blocksize = min(count, 8192) if count else 8192\n        total_sent = 0\n        # localize variable access to minimize overhead\n        file_read = file.read\n        sock_send = self.send\n        try:\n            while True:\n                if count:\n                    blocksize = min(count - total_sent, blocksize)\n                    if blocksize <= 0:\n                        break\n                data = memoryview(file_read(blocksize))\n                if not data:\n                    break  # EOF\n                while True:\n                    try:\n                        sent = sock_send(data)\n                    except BlockingIOError:\n                        continue\n                    else:\n                        total_sent += sent\n                        if sent < len(data):\n                            data = data[sent:]\n                        else:\n                            break\n            return total_sent\n        finally:\n            if total_sent > 0 and hasattr(file, 'seek'):\n                file.seek(offset + total_sent)\n\n    def _check_sendfile_params(self, file, offset, count):\n        if 'b' not in getattr(file, 'mode', 'b'):\n            raise ValueError(\"file should be opened in binary mode\")\n        if not self.type & SOCK_STREAM:\n            raise ValueError(\"only SOCK_STREAM type sockets are supported\")\n        if count is not None:\n            if not isinstance(count, int):\n                raise TypeError(\n                    \"count must be a positive integer (got {!r})\".format(count))\n            if count <= 0:\n                raise ValueError(\n                    \"count must be a positive integer (got {!r})\".format(count))\n\n    def sendfile(self, file, offset=0, count=None):\n        \"\"\"sendfile(file[, offset[, count]]) -> sent\n\n        Send a file until EOF is reached by using high-performance\n        os.sendfile() and return the total number of bytes which\n        were sent.\n        *file* must be a regular file object opened in binary mode.\n        If os.sendfile() is not available (e.g. Windows) or file is\n        not a regular file socket.send() will be used instead.\n        *offset* tells from where to start reading the file.\n        If specified, *count* is the total number of bytes to transmit\n        as opposed to sending the file until EOF is reached.\n        File position is updated on return or also in case of error in\n        which case file.tell() can be used to figure out the number of\n        bytes which were sent.\n        The socket must be of SOCK_STREAM type.\n        Non-blocking sockets are not supported.\n        \"\"\"\n        try:\n            return self._sendfile_use_sendfile(file, offset, count)\n        except _GiveupOnSendfile:\n            return self._sendfile_use_send(file, offset, count)\n\n    def _decref_socketios(self):\n        if self._io_refs > 0:\n            self._io_refs -= 1\n        if self._closed:\n            self.close()\n\n    def _real_close(self, _ss=_socket.socket):\n        # This function should not reference any globals. See issue #808164.\n        _ss.close(self)\n\n    def close(self):\n        # This function should not reference any globals. See issue #808164.\n        self._closed = True\n        if self._io_refs <= 0:\n            self._real_close()\n\n    def detach(self):\n        \"\"\"detach() -> file descriptor\n\n        Close the socket object without closing the underlying file descriptor.\n        The object cannot be used after this call, but the file descriptor\n        can be reused for other purposes.  The file descriptor is returned.\n        \"\"\"\n        self._closed = True\n        return super().detach()\n\n    @property\n    def family(self):\n        \"\"\"Read-only access to the address family for this socket.\n        \"\"\"\n        return _intenum_converter(super().family, AddressFamily)\n\n    @property\n    def type(self):\n        \"\"\"Read-only access to the socket type.\n        \"\"\"\n        return _intenum_converter(super().type, SocketKind)\n\n    if os.name == 'nt':\n        def get_inheritable(self):\n            return os.get_handle_inheritable(self.fileno())\n        def set_inheritable(self, inheritable):\n            os.set_handle_inheritable(self.fileno(), inheritable)\n    else:\n        def get_inheritable(self):\n            return os.get_inheritable(self.fileno())\n        def set_inheritable(self, inheritable):\n            os.set_inheritable(self.fileno(), inheritable)\n    get_inheritable.__doc__ = \"Get the inheritable flag of the socket\"\n    set_inheritable.__doc__ = \"Set the inheritable flag of the socket\"\n\ndef fromfd(fd, family, type, proto=0):\n    \"\"\" fromfd(fd, family, type[, proto]) -> socket object\n\n    Create a socket object from a duplicate of the given file\n    descriptor.  The remaining arguments are the same as for socket().\n    \"\"\"\n    nfd = dup(fd)\n    return socket(family, type, proto, nfd)\n\nif hasattr(_socket.socket, \"sendmsg\"):\n    import array\n\n    def send_fds(sock, buffers, fds, flags=0, address=None):\n        \"\"\" send_fds(sock, buffers, fds[, flags[, address]]) -> integer\n\n        Send the list of file descriptors fds over an AF_UNIX socket.\n        \"\"\"\n        return sock.sendmsg(buffers, [(_socket.SOL_SOCKET,\n            _socket.SCM_RIGHTS, array.array(\"i\", fds))])\n    __all__.append(\"send_fds\")\n\nif hasattr(_socket.socket, \"recvmsg\"):\n    import array\n\n    def recv_fds(sock, bufsize, maxfds, flags=0):\n        \"\"\" recv_fds(sock, bufsize, maxfds[, flags]) -> (data, list of file\n        descriptors, msg_flags, address)\n\n        Receive up to maxfds file descriptors returning the message\n        data and a list containing the descriptors.\n        \"\"\"\n        # Array of ints\n        fds = array.array(\"i\")\n        msg, ancdata, flags, addr = sock.recvmsg(bufsize,\n            _socket.CMSG_LEN(maxfds * fds.itemsize))\n        for cmsg_level, cmsg_type, cmsg_data in ancdata:\n            if (cmsg_level == _socket.SOL_SOCKET and cmsg_type == _socket.SCM_RIGHTS):\n                fds.frombytes(cmsg_data[:\n                        len(cmsg_data) - (len(cmsg_data) % fds.itemsize)])\n\n        return msg, list(fds), flags, addr\n    __all__.append(\"recv_fds\")\n\nif hasattr(_socket.socket, \"share\"):\n    def fromshare(info):\n        \"\"\" fromshare(info) -> socket object\n\n        Create a socket object from the bytes object returned by\n        socket.share(pid).\n        \"\"\"\n        return socket(0, 0, 0, info)\n    __all__.append(\"fromshare\")\n\nif hasattr(_socket, \"socketpair\"):\n\n    def socketpair(family=None, type=SOCK_STREAM, proto=0):\n        \"\"\"socketpair([family[, type[, proto]]]) -> (socket object, socket object)\n\n        Create a pair of socket objects from the sockets returned by the platform\n        socketpair() function.\n        The arguments are the same as for socket() except the default family is\n        AF_UNIX if defined on the platform; otherwise, the default is AF_INET.\n        \"\"\"\n        if family is None:\n            try:\n                family = AF_UNIX\n            except NameError:\n                family = AF_INET\n        a, b = _socket.socketpair(family, type, proto)\n        a = socket(family, type, proto, a.detach())\n        b = socket(family, type, proto, b.detach())\n        return a, b\n\nelse:\n\n    # Origin: https://gist.github.com/4325783, by Geert Jansen.  Public domain.\n    def socketpair(family=AF_INET, type=SOCK_STREAM, proto=0):\n        if family == AF_INET:\n            host = _LOCALHOST\n        elif family == AF_INET6:\n            host = _LOCALHOST_V6\n        else:\n            raise ValueError(\"Only AF_INET and AF_INET6 socket address families \"\n                             \"are supported\")\n        if type != SOCK_STREAM:\n            raise ValueError(\"Only SOCK_STREAM socket type is supported\")\n        if proto != 0:\n            raise ValueError(\"Only protocol zero is supported\")\n\n        # We create a connected TCP socket. Note the trick with\n        # setblocking(False) that prevents us from having to create a thread.\n        lsock = socket(family, type, proto)\n        try:\n            lsock.bind((host, 0))\n            lsock.listen()\n            # On IPv6, ignore flow_info and scope_id\n            addr, port = lsock.getsockname()[:2]\n            csock = socket(family, type, proto)\n            try:\n                csock.setblocking(False)\n                try:\n                    csock.connect((addr, port))\n                except (BlockingIOError, InterruptedError):\n                    pass\n                csock.setblocking(True)\n                ssock, _ = lsock.accept()\n            except:\n                csock.close()\n                raise\n        finally:\n            lsock.close()\n        return (ssock, csock)\n    __all__.append(\"socketpair\")\n\nsocketpair.__doc__ = \"\"\"socketpair([family[, type[, proto]]]) -> (socket object, socket object)\nCreate a pair of socket objects from the sockets returned by the platform\nsocketpair() function.\nThe arguments are the same as for socket() except the default family is AF_UNIX\nif defined on the platform; otherwise, the default is AF_INET.\n\"\"\"\n\n_blocking_errnos = { EAGAIN, EWOULDBLOCK }\n\nclass SocketIO(io.RawIOBase):\n\n    \"\"\"Raw I/O implementation for stream sockets.\n\n    This class supports the makefile() method on sockets.  It provides\n    the raw I/O interface on top of a socket object.\n    \"\"\"\n\n    # One might wonder why not let FileIO do the job instead.  There are two\n    # main reasons why FileIO is not adapted:\n    # - it wouldn't work under Windows (where you can't used read() and\n    #   write() on a socket handle)\n    # - it wouldn't work with socket timeouts (FileIO would ignore the\n    #   timeout and consider the socket non-blocking)\n\n    # XXX More docs\n\n    def __init__(self, sock, mode):\n        if mode not in (\"r\", \"w\", \"rw\", \"rb\", \"wb\", \"rwb\"):\n            raise ValueError(\"invalid mode: %r\" % mode)\n        io.RawIOBase.__init__(self)\n        self._sock = sock\n        if \"b\" not in mode:\n            mode += \"b\"\n        self._mode = mode\n        self._reading = \"r\" in mode\n        self._writing = \"w\" in mode\n        self._timeout_occurred = False\n\n    def readinto(self, b):\n        \"\"\"Read up to len(b) bytes into the writable buffer *b* and return\n        the number of bytes read.  If the socket is non-blocking and no bytes\n        are available, None is returned.\n\n        If *b* is non-empty, a 0 return value indicates that the connection\n        was shutdown at the other end.\n        \"\"\"\n        self._checkClosed()\n        self._checkReadable()\n        if self._timeout_occurred:\n            raise OSError(\"cannot read from timed out object\")\n        while True:\n            try:\n                return self._sock.recv_into(b)\n            except timeout:\n                self._timeout_occurred = True\n                raise\n            except error as e:\n                if e.errno in _blocking_errnos:\n                    return None\n                raise\n\n    def write(self, b):\n        \"\"\"Write the given bytes or bytearray object *b* to the socket\n        and return the number of bytes written.  This can be less than\n        len(b) if not all data could be written.  If the socket is\n        non-blocking and no bytes could be written None is returned.\n        \"\"\"\n        self._checkClosed()\n        self._checkWritable()\n        try:\n            return self._sock.send(b)\n        except error as e:\n            # XXX what about EINTR?\n            if e.errno in _blocking_errnos:\n                return None\n            raise\n\n    def readable(self):\n        \"\"\"True if the SocketIO is open for reading.\n        \"\"\"\n        if self.closed:\n            raise ValueError(\"I/O operation on closed socket.\")\n        return self._reading\n\n    def writable(self):\n        \"\"\"True if the SocketIO is open for writing.\n        \"\"\"\n        if self.closed:\n            raise ValueError(\"I/O operation on closed socket.\")\n        return self._writing\n\n    def seekable(self):\n        \"\"\"True if the SocketIO is open for seeking.\n        \"\"\"\n        if self.closed:\n            raise ValueError(\"I/O operation on closed socket.\")\n        return super().seekable()\n\n    def fileno(self):\n        \"\"\"Return the file descriptor of the underlying socket.\n        \"\"\"\n        self._checkClosed()\n        return self._sock.fileno()\n\n    @property\n    def name(self):\n        if not self.closed:\n            return self.fileno()\n        else:\n            return -1\n\n    @property\n    def mode(self):\n        return self._mode\n\n    def close(self):\n        \"\"\"Close the SocketIO object.  This doesn't close the underlying\n        socket, except if all references to it have disappeared.\n        \"\"\"\n        if self.closed:\n            return\n        io.RawIOBase.close(self)\n        self._sock._decref_socketios()\n        self._sock = None\n\n\ndef getfqdn(name=''):\n    \"\"\"Get fully qualified domain name from name.\n\n    An empty argument is interpreted as meaning the local host.\n\n    First the hostname returned by gethostbyaddr() is checked, then\n    possibly existing aliases. In case no FQDN is available and `name`\n    was given, it is returned unchanged. If `name` was empty or '0.0.0.0',\n    hostname from gethostname() is returned.\n    \"\"\"\n    name = name.strip()\n    if not name or name == '0.0.0.0':\n        name = gethostname()\n    try:\n        hostname, aliases, ipaddrs = gethostbyaddr(name)\n    except error:\n        pass\n    else:\n        aliases.insert(0, hostname)\n        for name in aliases:\n            if '.' in name:\n                break\n        else:\n            name = hostname\n    return name\n\n\n_GLOBAL_DEFAULT_TIMEOUT = object()\n\ndef create_connection(address, timeout=_GLOBAL_DEFAULT_TIMEOUT,\n                      source_address=None, *, all_errors=False):\n    \"\"\"Connect to *address* and return the socket object.\n\n    Convenience function.  Connect to *address* (a 2-tuple ``(host,\n    port)``) and return the socket object.  Passing the optional\n    *timeout* parameter will set the timeout on the socket instance\n    before attempting to connect.  If no *timeout* is supplied, the\n    global default timeout setting returned by :func:`getdefaulttimeout`\n    is used.  If *source_address* is set it must be a tuple of (host, port)\n    for the socket to bind as a source address before making the connection.\n    A host of '' or port 0 tells the OS to use the default. When a connection\n    cannot be created, raises the last error if *all_errors* is False,\n    and an ExceptionGroup of all errors if *all_errors* is True.\n    \"\"\"\n\n    host, port = address\n    exceptions = []\n    for res in getaddrinfo(host, port, 0, SOCK_STREAM):\n        af, socktype, proto, canonname, sa = res\n        sock = None\n        try:\n            sock = socket(af, socktype, proto)\n            if timeout is not _GLOBAL_DEFAULT_TIMEOUT:\n                sock.settimeout(timeout)\n            if source_address:\n                sock.bind(source_address)\n            sock.connect(sa)\n            # Break explicitly a reference cycle\n            exceptions.clear()\n            return sock\n\n        except error as exc:\n            if not all_errors:\n                exceptions.clear()  # raise only the last error\n            exceptions.append(exc)\n            if sock is not None:\n                sock.close()\n\n    if len(exceptions):\n        try:\n            if not all_errors:\n                raise exceptions[0]\n            raise ExceptionGroup(\"create_connection failed\", exceptions)\n        finally:\n            # Break explicitly a reference cycle\n            exceptions.clear()\n    else:\n        raise error(\"getaddrinfo returns an empty list\")\n\n\ndef has_dualstack_ipv6():\n    \"\"\"Return True if the platform supports creating a SOCK_STREAM socket\n    which can handle both AF_INET and AF_INET6 (IPv4 / IPv6) connections.\n    \"\"\"\n    if not has_ipv6 \\\n            or not hasattr(_socket, 'IPPROTO_IPV6') \\\n            or not hasattr(_socket, 'IPV6_V6ONLY'):\n        return False\n    try:\n        with socket(AF_INET6, SOCK_STREAM) as sock:\n            sock.setsockopt(IPPROTO_IPV6, IPV6_V6ONLY, 0)\n            return True\n    except error:\n        return False\n\n\ndef create_server(address, *, family=AF_INET, backlog=None, reuse_port=False,\n                  dualstack_ipv6=False):\n    \"\"\"Convenience function which creates a SOCK_STREAM type socket\n    bound to *address* (a 2-tuple (host, port)) and return the socket\n    object.\n\n    *family* should be either AF_INET or AF_INET6.\n    *backlog* is the queue size passed to socket.listen().\n    *reuse_port* dictates whether to use the SO_REUSEPORT socket option.\n    *dualstack_ipv6*: if true and the platform supports it, it will\n    create an AF_INET6 socket able to accept both IPv4 or IPv6\n    connections. When false it will explicitly disable this option on\n    platforms that enable it by default (e.g. Linux).\n\n    >>> with create_server(('', 8000)) as server:\n    ...     while True:\n    ...         conn, addr = server.accept()\n    ...         # handle new connection\n    \"\"\"\n    if reuse_port and not hasattr(_socket, \"SO_REUSEPORT\"):\n        raise ValueError(\"SO_REUSEPORT not supported on this platform\")\n    if dualstack_ipv6:\n        if not has_dualstack_ipv6():\n            raise ValueError(\"dualstack_ipv6 not supported on this platform\")\n        if family != AF_INET6:\n            raise ValueError(\"dualstack_ipv6 requires AF_INET6 family\")\n    sock = socket(family, SOCK_STREAM)\n    try:\n        # Note about Windows. We don't set SO_REUSEADDR because:\n        # 1) It's unnecessary: bind() will succeed even in case of a\n        # previous closed socket on the same address and still in\n        # TIME_WAIT state.\n        # 2) If set, another socket is free to bind() on the same\n        # address, effectively preventing this one from accepting\n        # connections. Also, it may set the process in a state where\n        # it'll no longer respond to any signals or graceful kills.\n        # See: msdn2.microsoft.com/en-us/library/ms740621(VS.85).aspx\n        if os.name not in ('nt', 'cygwin') and \\\n                hasattr(_socket, 'SO_REUSEADDR'):\n            try:\n                sock.setsockopt(SOL_SOCKET, SO_REUSEADDR, 1)\n            except error:\n                # Fail later on bind(), for platforms which may not\n                # support this option.\n                pass\n        if reuse_port:\n            sock.setsockopt(SOL_SOCKET, SO_REUSEPORT, 1)\n        if has_ipv6 and family == AF_INET6:\n            if dualstack_ipv6:\n                sock.setsockopt(IPPROTO_IPV6, IPV6_V6ONLY, 0)\n            elif hasattr(_socket, \"IPV6_V6ONLY\") and \\\n                    hasattr(_socket, \"IPPROTO_IPV6\"):\n                sock.setsockopt(IPPROTO_IPV6, IPV6_V6ONLY, 1)\n        try:\n            sock.bind(address)\n        except error as err:\n            msg = '%s (while attempting to bind on address %r)' % \\\n                (err.strerror, address)\n            raise error(err.errno, msg) from None\n        if backlog is None:\n            sock.listen()\n        else:\n            sock.listen(backlog)\n        return sock\n    except error:\n        sock.close()\n        raise\n\n\ndef getaddrinfo(host, port, family=0, type=0, proto=0, flags=0):\n    \"\"\"Resolve host and port into list of address info entries.\n\n    Translate the host/port argument into a sequence of 5-tuples that contain\n    all the necessary arguments for creating a socket connected to that service.\n    host is a domain name, a string representation of an IPv4/v6 address or\n    None. port is a string service name such as 'http', a numeric port number or\n    None. By passing None as the value of host and port, you can pass NULL to\n    the underlying C API.\n\n    The family, type and proto arguments can be optionally specified in order to\n    narrow the list of addresses returned. Passing zero as a value for each of\n    these arguments selects the full range of results.\n    \"\"\"\n    # We override this function since we want to translate the numeric family\n    # and socket type values to enum constants.\n    addrlist = []\n    for res in _socket.getaddrinfo(host, port, family, type, proto, flags):\n        af, socktype, proto, canonname, sa = res\n        addrlist.append((_intenum_converter(af, AddressFamily),\n                         _intenum_converter(socktype, SocketKind),\n                         proto, canonname, sa))\n    return addrlist\n",966],"/home/ma-user/anaconda3/envs/py311/lib/python3.11/weakref.py":["\"\"\"Weak reference support for Python.\n\nThis module is an implementation of PEP 205:\n\nhttps://peps.python.org/pep-0205/\n\"\"\"\n\n# Naming convention: Variables named \"wr\" are weak reference objects;\n# they are called this instead of \"ref\" to avoid name collisions with\n# the module-global ref() function imported from _weakref.\n\nfrom _weakref import (\n     getweakrefcount,\n     getweakrefs,\n     ref,\n     proxy,\n     CallableProxyType,\n     ProxyType,\n     ReferenceType,\n     _remove_dead_weakref)\n\nfrom _weakrefset import WeakSet, _IterationGuard\n\nimport _collections_abc  # Import after _weakref to avoid circular import.\nimport sys\nimport itertools\n\nProxyTypes = (ProxyType, CallableProxyType)\n\n__all__ = [\"ref\", \"proxy\", \"getweakrefcount\", \"getweakrefs\",\n           \"WeakKeyDictionary\", \"ReferenceType\", \"ProxyType\",\n           \"CallableProxyType\", \"ProxyTypes\", \"WeakValueDictionary\",\n           \"WeakSet\", \"WeakMethod\", \"finalize\"]\n\n\n_collections_abc.MutableSet.register(WeakSet)\n\nclass WeakMethod(ref):\n    \"\"\"\n    A custom `weakref.ref` subclass which simulates a weak reference to\n    a bound method, working around the lifetime problem of bound methods.\n    \"\"\"\n\n    __slots__ = \"_func_ref\", \"_meth_type\", \"_alive\", \"__weakref__\"\n\n    def __new__(cls, meth, callback=None):\n        try:\n            obj = meth.__self__\n            func = meth.__func__\n        except AttributeError:\n            raise TypeError(\"argument should be a bound method, not {}\"\n                            .format(type(meth))) from None\n        def _cb(arg):\n            # The self-weakref trick is needed to avoid creating a reference\n            # cycle.\n            self = self_wr()\n            if self._alive:\n                self._alive = False\n                if callback is not None:\n                    callback(self)\n        self = ref.__new__(cls, obj, _cb)\n        self._func_ref = ref(func, _cb)\n        self._meth_type = type(meth)\n        self._alive = True\n        self_wr = ref(self)\n        return self\n\n    def __call__(self):\n        obj = super().__call__()\n        func = self._func_ref()\n        if obj is None or func is None:\n            return None\n        return self._meth_type(func, obj)\n\n    def __eq__(self, other):\n        if isinstance(other, WeakMethod):\n            if not self._alive or not other._alive:\n                return self is other\n            return ref.__eq__(self, other) and self._func_ref == other._func_ref\n        return NotImplemented\n\n    def __ne__(self, other):\n        if isinstance(other, WeakMethod):\n            if not self._alive or not other._alive:\n                return self is not other\n            return ref.__ne__(self, other) or self._func_ref != other._func_ref\n        return NotImplemented\n\n    __hash__ = ref.__hash__\n\n\nclass WeakValueDictionary(_collections_abc.MutableMapping):\n    \"\"\"Mapping class that references values weakly.\n\n    Entries in the dictionary will be discarded when no strong\n    reference to the value exists anymore\n    \"\"\"\n    # We inherit the constructor without worrying about the input\n    # dictionary; since it uses our .update() method, we get the right\n    # checks (if the other dictionary is a WeakValueDictionary,\n    # objects are unwrapped on the way out, and we always wrap on the\n    # way in).\n\n    def __init__(self, other=(), /, **kw):\n        def remove(wr, selfref=ref(self), _atomic_removal=_remove_dead_weakref):\n            self = selfref()\n            if self is not None:\n                if self._iterating:\n                    self._pending_removals.append(wr.key)\n                else:\n                    # Atomic removal is necessary since this function\n                    # can be called asynchronously by the GC\n                    _atomic_removal(self.data, wr.key)\n        self._remove = remove\n        # A list of keys to be removed\n        self._pending_removals = []\n        self._iterating = set()\n        self.data = {}\n        self.update(other, **kw)\n\n    def _commit_removals(self, _atomic_removal=_remove_dead_weakref):\n        pop = self._pending_removals.pop\n        d = self.data\n        # We shouldn't encounter any KeyError, because this method should\n        # always be called *before* mutating the dict.\n        while True:\n            try:\n                key = pop()\n            except IndexError:\n                return\n            _atomic_removal(d, key)\n\n    def __getitem__(self, key):\n        if self._pending_removals:\n            self._commit_removals()\n        o = self.data[key]()\n        if o is None:\n            raise KeyError(key)\n        else:\n            return o\n\n    def __delitem__(self, key):\n        if self._pending_removals:\n            self._commit_removals()\n        del self.data[key]\n\n    def __len__(self):\n        if self._pending_removals:\n            self._commit_removals()\n        return len(self.data)\n\n    def __contains__(self, key):\n        if self._pending_removals:\n            self._commit_removals()\n        try:\n            o = self.data[key]()\n        except KeyError:\n            return False\n        return o is not None\n\n    def __repr__(self):\n        return \"<%s at %#x>\" % (self.__class__.__name__, id(self))\n\n    def __setitem__(self, key, value):\n        if self._pending_removals:\n            self._commit_removals()\n        self.data[key] = KeyedRef(value, self._remove, key)\n\n    def copy(self):\n        if self._pending_removals:\n            self._commit_removals()\n        new = WeakValueDictionary()\n        with _IterationGuard(self):\n            for key, wr in self.data.items():\n                o = wr()\n                if o is not None:\n                    new[key] = o\n        return new\n\n    __copy__ = copy\n\n    def __deepcopy__(self, memo):\n        from copy import deepcopy\n        if self._pending_removals:\n            self._commit_removals()\n        new = self.__class__()\n        with _IterationGuard(self):\n            for key, wr in self.data.items():\n                o = wr()\n                if o is not None:\n                    new[deepcopy(key, memo)] = o\n        return new\n\n    def get(self, key, default=None):\n        if self._pending_removals:\n            self._commit_removals()\n        try:\n            wr = self.data[key]\n        except KeyError:\n            return default\n        else:\n            o = wr()\n            if o is None:\n                # This should only happen\n                return default\n            else:\n                return o\n\n    def items(self):\n        if self._pending_removals:\n            self._commit_removals()\n        with _IterationGuard(self):\n            for k, wr in self.data.items():\n                v = wr()\n                if v is not None:\n                    yield k, v\n\n    def keys(self):\n        if self._pending_removals:\n            self._commit_removals()\n        with _IterationGuard(self):\n            for k, wr in self.data.items():\n                if wr() is not None:\n                    yield k\n\n    __iter__ = keys\n\n    def itervaluerefs(self):\n        \"\"\"Return an iterator that yields the weak references to the values.\n\n        The references are not guaranteed to be 'live' at the time\n        they are used, so the result of calling the references needs\n        to be checked before being used.  This can be used to avoid\n        creating references that will cause the garbage collector to\n        keep the values around longer than needed.\n\n        \"\"\"\n        if self._pending_removals:\n            self._commit_removals()\n        with _IterationGuard(self):\n            yield from self.data.values()\n\n    def values(self):\n        if self._pending_removals:\n            self._commit_removals()\n        with _IterationGuard(self):\n            for wr in self.data.values():\n                obj = wr()\n                if obj is not None:\n                    yield obj\n\n    def popitem(self):\n        if self._pending_removals:\n            self._commit_removals()\n        while True:\n            key, wr = self.data.popitem()\n            o = wr()\n            if o is not None:\n                return key, o\n\n    def pop(self, key, *args):\n        if self._pending_removals:\n            self._commit_removals()\n        try:\n            o = self.data.pop(key)()\n        except KeyError:\n            o = None\n        if o is None:\n            if args:\n                return args[0]\n            else:\n                raise KeyError(key)\n        else:\n            return o\n\n    def setdefault(self, key, default=None):\n        try:\n            o = self.data[key]()\n        except KeyError:\n            o = None\n        if o is None:\n            if self._pending_removals:\n                self._commit_removals()\n            self.data[key] = KeyedRef(default, self._remove, key)\n            return default\n        else:\n            return o\n\n    def update(self, other=None, /, **kwargs):\n        if self._pending_removals:\n            self._commit_removals()\n        d = self.data\n        if other is not None:\n            if not hasattr(other, \"items\"):\n                other = dict(other)\n            for key, o in other.items():\n                d[key] = KeyedRef(o, self._remove, key)\n        for key, o in kwargs.items():\n            d[key] = KeyedRef(o, self._remove, key)\n\n    def valuerefs(self):\n        \"\"\"Return a list of weak references to the values.\n\n        The references are not guaranteed to be 'live' at the time\n        they are used, so the result of calling the references needs\n        to be checked before being used.  This can be used to avoid\n        creating references that will cause the garbage collector to\n        keep the values around longer than needed.\n\n        \"\"\"\n        if self._pending_removals:\n            self._commit_removals()\n        return list(self.data.values())\n\n    def __ior__(self, other):\n        self.update(other)\n        return self\n\n    def __or__(self, other):\n        if isinstance(other, _collections_abc.Mapping):\n            c = self.copy()\n            c.update(other)\n            return c\n        return NotImplemented\n\n    def __ror__(self, other):\n        if isinstance(other, _collections_abc.Mapping):\n            c = self.__class__()\n            c.update(other)\n            c.update(self)\n            return c\n        return NotImplemented\n\n\nclass KeyedRef(ref):\n    \"\"\"Specialized reference that includes a key corresponding to the value.\n\n    This is used in the WeakValueDictionary to avoid having to create\n    a function object for each key stored in the mapping.  A shared\n    callback object can use the 'key' attribute of a KeyedRef instead\n    of getting a reference to the key from an enclosing scope.\n\n    \"\"\"\n\n    __slots__ = \"key\",\n\n    def __new__(type, ob, callback, key):\n        self = ref.__new__(type, ob, callback)\n        self.key = key\n        return self\n\n    def __init__(self, ob, callback, key):\n        super().__init__(ob, callback)\n\n\nclass WeakKeyDictionary(_collections_abc.MutableMapping):\n    \"\"\" Mapping class that references keys weakly.\n\n    Entries in the dictionary will be discarded when there is no\n    longer a strong reference to the key. This can be used to\n    associate additional data with an object owned by other parts of\n    an application without adding attributes to those objects. This\n    can be especially useful with objects that override attribute\n    accesses.\n    \"\"\"\n\n    def __init__(self, dict=None):\n        self.data = {}\n        def remove(k, selfref=ref(self)):\n            self = selfref()\n            if self is not None:\n                if self._iterating:\n                    self._pending_removals.append(k)\n                else:\n                    try:\n                        del self.data[k]\n                    except KeyError:\n                        pass\n        self._remove = remove\n        # A list of dead weakrefs (keys to be removed)\n        self._pending_removals = []\n        self._iterating = set()\n        self._dirty_len = False\n        if dict is not None:\n            self.update(dict)\n\n    def _commit_removals(self):\n        # NOTE: We don't need to call this method before mutating the dict,\n        # because a dead weakref never compares equal to a live weakref,\n        # even if they happened to refer to equal objects.\n        # However, it means keys may already have been removed.\n        pop = self._pending_removals.pop\n        d = self.data\n        while True:\n            try:\n                key = pop()\n            except IndexError:\n                return\n\n            try:\n                del d[key]\n            except KeyError:\n                pass\n\n    def _scrub_removals(self):\n        d = self.data\n        self._pending_removals = [k for k in self._pending_removals if k in d]\n        self._dirty_len = False\n\n    def __delitem__(self, key):\n        self._dirty_len = True\n        del self.data[ref(key)]\n\n    def __getitem__(self, key):\n        return self.data[ref(key)]\n\n    def __len__(self):\n        if self._dirty_len and self._pending_removals:\n            # self._pending_removals may still contain keys which were\n            # explicitly removed, we have to scrub them (see issue #21173).\n            self._scrub_removals()\n        return len(self.data) - len(self._pending_removals)\n\n    def __repr__(self):\n        return \"<%s at %#x>\" % (self.__class__.__name__, id(self))\n\n    def __setitem__(self, key, value):\n        self.data[ref(key, self._remove)] = value\n\n    def copy(self):\n        new = WeakKeyDictionary()\n        with _IterationGuard(self):\n            for key, value in self.data.items():\n                o = key()\n                if o is not None:\n                    new[o] = value\n        return new\n\n    __copy__ = copy\n\n    def __deepcopy__(self, memo):\n        from copy import deepcopy\n        new = self.__class__()\n        with _IterationGuard(self):\n            for key, value in self.data.items():\n                o = key()\n                if o is not None:\n                    new[o] = deepcopy(value, memo)\n        return new\n\n    def get(self, key, default=None):\n        return self.data.get(ref(key),default)\n\n    def __contains__(self, key):\n        try:\n            wr = ref(key)\n        except TypeError:\n            return False\n        return wr in self.data\n\n    def items(self):\n        with _IterationGuard(self):\n            for wr, value in self.data.items():\n                key = wr()\n                if key is not None:\n                    yield key, value\n\n    def keys(self):\n        with _IterationGuard(self):\n            for wr in self.data:\n                obj = wr()\n                if obj is not None:\n                    yield obj\n\n    __iter__ = keys\n\n    def values(self):\n        with _IterationGuard(self):\n            for wr, value in self.data.items():\n                if wr() is not None:\n                    yield value\n\n    def keyrefs(self):\n        \"\"\"Return a list of weak references to the keys.\n\n        The references are not guaranteed to be 'live' at the time\n        they are used, so the result of calling the references needs\n        to be checked before being used.  This can be used to avoid\n        creating references that will cause the garbage collector to\n        keep the keys around longer than needed.\n\n        \"\"\"\n        return list(self.data)\n\n    def popitem(self):\n        self._dirty_len = True\n        while True:\n            key, value = self.data.popitem()\n            o = key()\n            if o is not None:\n                return o, value\n\n    def pop(self, key, *args):\n        self._dirty_len = True\n        return self.data.pop(ref(key), *args)\n\n    def setdefault(self, key, default=None):\n        return self.data.setdefault(ref(key, self._remove),default)\n\n    def update(self, dict=None, /, **kwargs):\n        d = self.data\n        if dict is not None:\n            if not hasattr(dict, \"items\"):\n                dict = type({})(dict)\n            for key, value in dict.items():\n                d[ref(key, self._remove)] = value\n        if len(kwargs):\n            self.update(kwargs)\n\n    def __ior__(self, other):\n        self.update(other)\n        return self\n\n    def __or__(self, other):\n        if isinstance(other, _collections_abc.Mapping):\n            c = self.copy()\n            c.update(other)\n            return c\n        return NotImplemented\n\n    def __ror__(self, other):\n        if isinstance(other, _collections_abc.Mapping):\n            c = self.__class__()\n            c.update(other)\n            c.update(self)\n            return c\n        return NotImplemented\n\n\nclass finalize:\n    \"\"\"Class for finalization of weakrefable objects\n\n    finalize(obj, func, *args, **kwargs) returns a callable finalizer\n    object which will be called when obj is garbage collected. The\n    first time the finalizer is called it evaluates func(*arg, **kwargs)\n    and returns the result. After this the finalizer is dead, and\n    calling it just returns None.\n\n    When the program exits any remaining finalizers for which the\n    atexit attribute is true will be run in reverse order of creation.\n    By default atexit is true.\n    \"\"\"\n\n    # Finalizer objects don't have any state of their own.  They are\n    # just used as keys to lookup _Info objects in the registry.  This\n    # ensures that they cannot be part of a ref-cycle.\n\n    __slots__ = ()\n    _registry = {}\n    _shutdown = False\n    _index_iter = itertools.count()\n    _dirty = False\n    _registered_with_atexit = False\n\n    class _Info:\n        __slots__ = (\"weakref\", \"func\", \"args\", \"kwargs\", \"atexit\", \"index\")\n\n    def __init__(self, obj, func, /, *args, **kwargs):\n        if not self._registered_with_atexit:\n            # We may register the exit function more than once because\n            # of a thread race, but that is harmless\n            import atexit\n            atexit.register(self._exitfunc)\n            finalize._registered_with_atexit = True\n        info = self._Info()\n        info.weakref = ref(obj, self)\n        info.func = func\n        info.args = args\n        info.kwargs = kwargs or None\n        info.atexit = True\n        info.index = next(self._index_iter)\n        self._registry[self] = info\n        finalize._dirty = True\n\n    def __call__(self, _=None):\n        \"\"\"If alive then mark as dead and return func(*args, **kwargs);\n        otherwise return None\"\"\"\n        info = self._registry.pop(self, None)\n        if info and not self._shutdown:\n            return info.func(*info.args, **(info.kwargs or {}))\n\n    def detach(self):\n        \"\"\"If alive then mark as dead and return (obj, func, args, kwargs);\n        otherwise return None\"\"\"\n        info = self._registry.get(self)\n        obj = info and info.weakref()\n        if obj is not None and self._registry.pop(self, None):\n            return (obj, info.func, info.args, info.kwargs or {})\n\n    def peek(self):\n        \"\"\"If alive then return (obj, func, args, kwargs);\n        otherwise return None\"\"\"\n        info = self._registry.get(self)\n        obj = info and info.weakref()\n        if obj is not None:\n            return (obj, info.func, info.args, info.kwargs or {})\n\n    @property\n    def alive(self):\n        \"\"\"Whether finalizer is alive\"\"\"\n        return self in self._registry\n\n    @property\n    def atexit(self):\n        \"\"\"Whether finalizer should be called at exit\"\"\"\n        info = self._registry.get(self)\n        return bool(info) and info.atexit\n\n    @atexit.setter\n    def atexit(self, value):\n        info = self._registry.get(self)\n        if info:\n            info.atexit = bool(value)\n\n    def __repr__(self):\n        info = self._registry.get(self)\n        obj = info and info.weakref()\n        if obj is None:\n            return '<%s object at %#x; dead>' % (type(self).__name__, id(self))\n        else:\n            return '<%s object at %#x; for %r at %#x>' % \\\n                (type(self).__name__, id(self), type(obj).__name__, id(obj))\n\n    @classmethod\n    def _select_for_exit(cls):\n        # Return live finalizers marked for exit, oldest first\n        L = [(f,i) for (f,i) in cls._registry.items() if i.atexit]\n        L.sort(key=lambda item:item[1].index)\n        return [f for (f,i) in L]\n\n    @classmethod\n    def _exitfunc(cls):\n        # At shutdown invoke finalizers for which atexit is true.\n        # This is called once all other non-daemonic threads have been\n        # joined.\n        reenable_gc = False\n        try:\n            if cls._registry:\n                import gc\n                if gc.isenabled():\n                    reenable_gc = True\n                    gc.disable()\n                pending = None\n                while True:\n                    if pending is None or finalize._dirty:\n                        pending = cls._select_for_exit()\n                        finalize._dirty = False\n                    if not pending:\n                        break\n                    f = pending.pop()\n                    try:\n                        # gc is disabled, so (assuming no daemonic\n                        # threads) the following is the only line in\n                        # this function which might trigger creation\n                        # of a new finalizer\n                        f()\n                    except Exception:\n                        sys.excepthook(*sys.exc_info())\n                    assert f not in cls._registry\n        finally:\n            # prevent any more finalizers from executing during shutdown\n            finalize._shutdown = True\n            if reenable_gc:\n                gc.enable()\n",674],"/home/ma-user/anaconda3/envs/py311/lib/python3.11/signal.py":["import _signal\nfrom _signal import *\nfrom enum import IntEnum as _IntEnum\n\n_globals = globals()\n\n_IntEnum._convert_(\n        'Signals', __name__,\n        lambda name:\n            name.isupper()\n            and (name.startswith('SIG') and not name.startswith('SIG_'))\n            or name.startswith('CTRL_'))\n\n_IntEnum._convert_(\n        'Handlers', __name__,\n        lambda name: name in ('SIG_DFL', 'SIG_IGN'))\n\nif 'pthread_sigmask' in _globals:\n    _IntEnum._convert_(\n            'Sigmasks', __name__,\n            lambda name: name in ('SIG_BLOCK', 'SIG_UNBLOCK', 'SIG_SETMASK'))\n\n\ndef _int_to_enum(value, enum_klass):\n    \"\"\"Convert a numeric value to an IntEnum member.\n    If it's not a known member, return the numeric value itself.\n    \"\"\"\n    try:\n        return enum_klass(value)\n    except ValueError:\n        return value\n\n\ndef _enum_to_int(value):\n    \"\"\"Convert an IntEnum member to a numeric value.\n    If it's not an IntEnum member return the value itself.\n    \"\"\"\n    try:\n        return int(value)\n    except (ValueError, TypeError):\n        return value\n\n\n# Similar to functools.wraps(), but only assign __doc__.\n# __module__ should be preserved,\n# __name__ and __qualname__ are already fine,\n# __annotations__ is not set.\ndef _wraps(wrapped):\n    def decorator(wrapper):\n        wrapper.__doc__ = wrapped.__doc__\n        return wrapper\n    return decorator\n\n@_wraps(_signal.signal)\ndef signal(signalnum, handler):\n    handler = _signal.signal(_enum_to_int(signalnum), _enum_to_int(handler))\n    return _int_to_enum(handler, Handlers)\n\n\n@_wraps(_signal.getsignal)\ndef getsignal(signalnum):\n    handler = _signal.getsignal(signalnum)\n    return _int_to_enum(handler, Handlers)\n\n\nif 'pthread_sigmask' in _globals:\n    @_wraps(_signal.pthread_sigmask)\n    def pthread_sigmask(how, mask):\n        sigs_set = _signal.pthread_sigmask(how, mask)\n        return set(_int_to_enum(x, Signals) for x in sigs_set)\n\n\nif 'sigpending' in _globals:\n    @_wraps(_signal.sigpending)\n    def sigpending():\n        return {_int_to_enum(x, Signals) for x in _signal.sigpending()}\n\n\nif 'sigwait' in _globals:\n    @_wraps(_signal.sigwait)\n    def sigwait(sigset):\n        retsig = _signal.sigwait(sigset)\n        return _int_to_enum(retsig, Signals)\n\n\nif 'valid_signals' in _globals:\n    @_wraps(_signal.valid_signals)\n    def valid_signals():\n        return {_int_to_enum(x, Signals) for x in _signal.valid_signals()}\n\n\ndel _globals, _wraps\n",92],"/home/ma-user/anaconda3/envs/py311/lib/python3.11/subprocess.py":["# subprocess - Subprocesses with accessible I/O streams\n#\n# For more information about this module, see PEP 324.\n#\n# Copyright (c) 2003-2005 by Peter Astrand <astrand@lysator.liu.se>\n#\n# Licensed to PSF under a Contributor Agreement.\n\nr\"\"\"Subprocesses with accessible I/O streams\n\nThis module allows you to spawn processes, connect to their\ninput/output/error pipes, and obtain their return codes.\n\nFor a complete description of this module see the Python documentation.\n\nMain API\n========\nrun(...): Runs a command, waits for it to complete, then returns a\n          CompletedProcess instance.\nPopen(...): A class for flexibly executing a command in a new process\n\nConstants\n---------\nDEVNULL: Special value that indicates that os.devnull should be used\nPIPE:    Special value that indicates a pipe should be created\nSTDOUT:  Special value that indicates that stderr should go to stdout\n\n\nOlder API\n=========\ncall(...): Runs a command, waits for it to complete, then returns\n    the return code.\ncheck_call(...): Same as call() but raises CalledProcessError()\n    if return code is not 0\ncheck_output(...): Same as check_call() but returns the contents of\n    stdout instead of a return code\ngetoutput(...): Runs a command in the shell, waits for it to complete,\n    then returns the output\ngetstatusoutput(...): Runs a command in the shell, waits for it to complete,\n    then returns a (exitcode, output) tuple\n\"\"\"\n\nimport builtins\nimport errno\nimport io\nimport locale\nimport os\nimport time\nimport signal\nimport sys\nimport threading\nimport warnings\nimport contextlib\nfrom time import monotonic as _time\nimport types\n\ntry:\n    import fcntl\nexcept ImportError:\n    fcntl = None\n\n\n__all__ = [\"Popen\", \"PIPE\", \"STDOUT\", \"call\", \"check_call\", \"getstatusoutput\",\n           \"getoutput\", \"check_output\", \"run\", \"CalledProcessError\", \"DEVNULL\",\n           \"SubprocessError\", \"TimeoutExpired\", \"CompletedProcess\"]\n           # NOTE: We intentionally exclude list2cmdline as it is\n           # considered an internal implementation detail.  issue10838.\n\n# use presence of msvcrt to detect Windows-like platforms (see bpo-8110)\ntry:\n    import msvcrt\nexcept ModuleNotFoundError:\n    _mswindows = False\nelse:\n    _mswindows = True\n\n# wasm32-emscripten and wasm32-wasi do not support processes\n_can_fork_exec = sys.platform not in {\"emscripten\", \"wasi\"}\n\nif _mswindows:\n    import _winapi\n    from _winapi import (CREATE_NEW_CONSOLE, CREATE_NEW_PROCESS_GROUP,\n                         STD_INPUT_HANDLE, STD_OUTPUT_HANDLE,\n                         STD_ERROR_HANDLE, SW_HIDE,\n                         STARTF_USESTDHANDLES, STARTF_USESHOWWINDOW,\n                         ABOVE_NORMAL_PRIORITY_CLASS, BELOW_NORMAL_PRIORITY_CLASS,\n                         HIGH_PRIORITY_CLASS, IDLE_PRIORITY_CLASS,\n                         NORMAL_PRIORITY_CLASS, REALTIME_PRIORITY_CLASS,\n                         CREATE_NO_WINDOW, DETACHED_PROCESS,\n                         CREATE_DEFAULT_ERROR_MODE, CREATE_BREAKAWAY_FROM_JOB)\n\n    __all__.extend([\"CREATE_NEW_CONSOLE\", \"CREATE_NEW_PROCESS_GROUP\",\n                    \"STD_INPUT_HANDLE\", \"STD_OUTPUT_HANDLE\",\n                    \"STD_ERROR_HANDLE\", \"SW_HIDE\",\n                    \"STARTF_USESTDHANDLES\", \"STARTF_USESHOWWINDOW\",\n                    \"STARTUPINFO\",\n                    \"ABOVE_NORMAL_PRIORITY_CLASS\", \"BELOW_NORMAL_PRIORITY_CLASS\",\n                    \"HIGH_PRIORITY_CLASS\", \"IDLE_PRIORITY_CLASS\",\n                    \"NORMAL_PRIORITY_CLASS\", \"REALTIME_PRIORITY_CLASS\",\n                    \"CREATE_NO_WINDOW\", \"DETACHED_PROCESS\",\n                    \"CREATE_DEFAULT_ERROR_MODE\", \"CREATE_BREAKAWAY_FROM_JOB\"])\nelse:\n    if _can_fork_exec:\n        from _posixsubprocess import fork_exec as _fork_exec\n        # used in methods that are called by __del__\n        _waitpid = os.waitpid\n        _waitstatus_to_exitcode = os.waitstatus_to_exitcode\n        _WIFSTOPPED = os.WIFSTOPPED\n        _WSTOPSIG = os.WSTOPSIG\n        _WNOHANG = os.WNOHANG\n    else:\n        _fork_exec = None\n        _waitpid = None\n        _waitstatus_to_exitcode = None\n        _WIFSTOPPED = None\n        _WSTOPSIG = None\n        _WNOHANG = None\n    import select\n    import selectors\n\n\n# Exception classes used by this module.\nclass SubprocessError(Exception): pass\n\n\nclass CalledProcessError(SubprocessError):\n    \"\"\"Raised when run() is called with check=True and the process\n    returns a non-zero exit status.\n\n    Attributes:\n      cmd, returncode, stdout, stderr, output\n    \"\"\"\n    def __init__(self, returncode, cmd, output=None, stderr=None):\n        self.returncode = returncode\n        self.cmd = cmd\n        self.output = output\n        self.stderr = stderr\n\n    def __str__(self):\n        if self.returncode and self.returncode < 0:\n            try:\n                return \"Command '%s' died with %r.\" % (\n                        self.cmd, signal.Signals(-self.returncode))\n            except ValueError:\n                return \"Command '%s' died with unknown signal %d.\" % (\n                        self.cmd, -self.returncode)\n        else:\n            return \"Command '%s' returned non-zero exit status %d.\" % (\n                    self.cmd, self.returncode)\n\n    @property\n    def stdout(self):\n        \"\"\"Alias for output attribute, to match stderr\"\"\"\n        return self.output\n\n    @stdout.setter\n    def stdout(self, value):\n        # There's no obvious reason to set this, but allow it anyway so\n        # .stdout is a transparent alias for .output\n        self.output = value\n\n\nclass TimeoutExpired(SubprocessError):\n    \"\"\"This exception is raised when the timeout expires while waiting for a\n    child process.\n\n    Attributes:\n        cmd, output, stdout, stderr, timeout\n    \"\"\"\n    def __init__(self, cmd, timeout, output=None, stderr=None):\n        self.cmd = cmd\n        self.timeout = timeout\n        self.output = output\n        self.stderr = stderr\n\n    def __str__(self):\n        return (\"Command '%s' timed out after %s seconds\" %\n                (self.cmd, self.timeout))\n\n    @property\n    def stdout(self):\n        return self.output\n\n    @stdout.setter\n    def stdout(self, value):\n        # There's no obvious reason to set this, but allow it anyway so\n        # .stdout is a transparent alias for .output\n        self.output = value\n\n\nif _mswindows:\n    class STARTUPINFO:\n        def __init__(self, *, dwFlags=0, hStdInput=None, hStdOutput=None,\n                     hStdError=None, wShowWindow=0, lpAttributeList=None):\n            self.dwFlags = dwFlags\n            self.hStdInput = hStdInput\n            self.hStdOutput = hStdOutput\n            self.hStdError = hStdError\n            self.wShowWindow = wShowWindow\n            self.lpAttributeList = lpAttributeList or {\"handle_list\": []}\n\n        def copy(self):\n            attr_list = self.lpAttributeList.copy()\n            if 'handle_list' in attr_list:\n                attr_list['handle_list'] = list(attr_list['handle_list'])\n\n            return STARTUPINFO(dwFlags=self.dwFlags,\n                               hStdInput=self.hStdInput,\n                               hStdOutput=self.hStdOutput,\n                               hStdError=self.hStdError,\n                               wShowWindow=self.wShowWindow,\n                               lpAttributeList=attr_list)\n\n\n    class Handle(int):\n        closed = False\n\n        def Close(self, CloseHandle=_winapi.CloseHandle):\n            if not self.closed:\n                self.closed = True\n                CloseHandle(self)\n\n        def Detach(self):\n            if not self.closed:\n                self.closed = True\n                return int(self)\n            raise ValueError(\"already closed\")\n\n        def __repr__(self):\n            return \"%s(%d)\" % (self.__class__.__name__, int(self))\n\n        __del__ = Close\nelse:\n    # When select or poll has indicated that the file is writable,\n    # we can write up to _PIPE_BUF bytes without risk of blocking.\n    # POSIX defines PIPE_BUF as >= 512.\n    _PIPE_BUF = getattr(select, 'PIPE_BUF', 512)\n\n    # poll/select have the advantage of not requiring any extra file\n    # descriptor, contrarily to epoll/kqueue (also, they require a single\n    # syscall).\n    if hasattr(selectors, 'PollSelector'):\n        _PopenSelector = selectors.PollSelector\n    else:\n        _PopenSelector = selectors.SelectSelector\n\n\nif _mswindows:\n    # On Windows we just need to close `Popen._handle` when we no longer need\n    # it, so that the kernel can free it. `Popen._handle` gets closed\n    # implicitly when the `Popen` instance is finalized (see `Handle.__del__`,\n    # which is calling `CloseHandle` as requested in [1]), so there is nothing\n    # for `_cleanup` to do.\n    #\n    # [1] https://docs.microsoft.com/en-us/windows/desktop/ProcThread/\n    # creating-processes\n    _active = None\n\n    def _cleanup():\n        pass\nelse:\n    # This lists holds Popen instances for which the underlying process had not\n    # exited at the time its __del__ method got called: those processes are\n    # wait()ed for synchronously from _cleanup() when a new Popen object is\n    # created, to avoid zombie processes.\n    _active = []\n\n    def _cleanup():\n        if _active is None:\n            return\n        for inst in _active[:]:\n            res = inst._internal_poll(_deadstate=sys.maxsize)\n            if res is not None:\n                try:\n                    _active.remove(inst)\n                except ValueError:\n                    # This can happen if two threads create a new Popen instance.\n                    # It's harmless that it was already removed, so ignore.\n                    pass\n\nPIPE = -1\nSTDOUT = -2\nDEVNULL = -3\n\n\n# XXX This function is only used by multiprocessing and the test suite,\n# but it's here so that it can be imported when Python is compiled without\n# threads.\n\ndef _optim_args_from_interpreter_flags():\n    \"\"\"Return a list of command-line arguments reproducing the current\n    optimization settings in sys.flags.\"\"\"\n    args = []\n    value = sys.flags.optimize\n    if value > 0:\n        args.append('-' + 'O' * value)\n    return args\n\n\ndef _args_from_interpreter_flags():\n    \"\"\"Return a list of command-line arguments reproducing the current\n    settings in sys.flags, sys.warnoptions and sys._xoptions.\"\"\"\n    flag_opt_map = {\n        'debug': 'd',\n        # 'inspect': 'i',\n        # 'interactive': 'i',\n        'dont_write_bytecode': 'B',\n        'no_site': 'S',\n        'verbose': 'v',\n        'bytes_warning': 'b',\n        'quiet': 'q',\n        # -O is handled in _optim_args_from_interpreter_flags()\n    }\n    args = _optim_args_from_interpreter_flags()\n    for flag, opt in flag_opt_map.items():\n        v = getattr(sys.flags, flag)\n        if v > 0:\n            args.append('-' + opt * v)\n\n    if sys.flags.isolated:\n        args.append('-I')\n    else:\n        if sys.flags.ignore_environment:\n            args.append('-E')\n        if sys.flags.no_user_site:\n            args.append('-s')\n        if sys.flags.safe_path:\n            args.append('-P')\n\n    # -W options\n    warnopts = sys.warnoptions[:]\n    xoptions = getattr(sys, '_xoptions', {})\n    bytes_warning = sys.flags.bytes_warning\n    dev_mode = sys.flags.dev_mode\n\n    if bytes_warning > 1:\n        warnopts.remove(\"error::BytesWarning\")\n    elif bytes_warning:\n        warnopts.remove(\"default::BytesWarning\")\n    if dev_mode:\n        warnopts.remove('default')\n    for opt in warnopts:\n        args.append('-W' + opt)\n\n    # -X options\n    if dev_mode:\n        args.extend(('-X', 'dev'))\n    for opt in ('faulthandler', 'tracemalloc', 'importtime',\n                'showrefcount', 'utf8'):\n        if opt in xoptions:\n            value = xoptions[opt]\n            if value is True:\n                arg = opt\n            else:\n                arg = '%s=%s' % (opt, value)\n            args.extend(('-X', arg))\n\n    return args\n\n\ndef _text_encoding():\n    # Return default text encoding and emit EncodingWarning if\n    # sys.flags.warn_default_encoding is true.\n    if sys.flags.warn_default_encoding:\n        f = sys._getframe()\n        filename = f.f_code.co_filename\n        stacklevel = 2\n        while f := f.f_back:\n            if f.f_code.co_filename != filename:\n                break\n            stacklevel += 1\n        warnings.warn(\"'encoding' argument not specified.\",\n                      EncodingWarning, stacklevel)\n\n    if sys.flags.utf8_mode:\n        return \"utf-8\"\n    else:\n        return locale.getencoding()\n\n\ndef call(*popenargs, timeout=None, **kwargs):\n    \"\"\"Run command with arguments.  Wait for command to complete or\n    timeout, then return the returncode attribute.\n\n    The arguments are the same as for the Popen constructor.  Example:\n\n    retcode = call([\"ls\", \"-l\"])\n    \"\"\"\n    with Popen(*popenargs, **kwargs) as p:\n        try:\n            return p.wait(timeout=timeout)\n        except:  # Including KeyboardInterrupt, wait handled that.\n            p.kill()\n            # We don't call p.wait() again as p.__exit__ does that for us.\n            raise\n\n\ndef check_call(*popenargs, **kwargs):\n    \"\"\"Run command with arguments.  Wait for command to complete.  If\n    the exit code was zero then return, otherwise raise\n    CalledProcessError.  The CalledProcessError object will have the\n    return code in the returncode attribute.\n\n    The arguments are the same as for the call function.  Example:\n\n    check_call([\"ls\", \"-l\"])\n    \"\"\"\n    retcode = call(*popenargs, **kwargs)\n    if retcode:\n        cmd = kwargs.get(\"args\")\n        if cmd is None:\n            cmd = popenargs[0]\n        raise CalledProcessError(retcode, cmd)\n    return 0\n\n\ndef check_output(*popenargs, timeout=None, **kwargs):\n    r\"\"\"Run command with arguments and return its output.\n\n    If the exit code was non-zero it raises a CalledProcessError.  The\n    CalledProcessError object will have the return code in the returncode\n    attribute and output in the output attribute.\n\n    The arguments are the same as for the Popen constructor.  Example:\n\n    >>> check_output([\"ls\", \"-l\", \"/dev/null\"])\n    b'crw-rw-rw- 1 root root 1, 3 Oct 18  2007 /dev/null\\n'\n\n    The stdout argument is not allowed as it is used internally.\n    To capture standard error in the result, use stderr=STDOUT.\n\n    >>> check_output([\"/bin/sh\", \"-c\",\n    ...               \"ls -l non_existent_file ; exit 0\"],\n    ...              stderr=STDOUT)\n    b'ls: non_existent_file: No such file or directory\\n'\n\n    There is an additional optional argument, \"input\", allowing you to\n    pass a string to the subprocess's stdin.  If you use this argument\n    you may not also use the Popen constructor's \"stdin\" argument, as\n    it too will be used internally.  Example:\n\n    >>> check_output([\"sed\", \"-e\", \"s/foo/bar/\"],\n    ...              input=b\"when in the course of fooman events\\n\")\n    b'when in the course of barman events\\n'\n\n    By default, all communication is in bytes, and therefore any \"input\"\n    should be bytes, and the return value will be bytes.  If in text mode,\n    any \"input\" should be a string, and the return value will be a string\n    decoded according to locale encoding, or by \"encoding\" if set. Text mode\n    is triggered by setting any of text, encoding, errors or universal_newlines.\n    \"\"\"\n    for kw in ('stdout', 'check'):\n        if kw in kwargs:\n            raise ValueError(f'{kw} argument not allowed, it will be overridden.')\n\n    if 'input' in kwargs and kwargs['input'] is None:\n        # Explicitly passing input=None was previously equivalent to passing an\n        # empty string. That is maintained here for backwards compatibility.\n        if kwargs.get('universal_newlines') or kwargs.get('text'):\n            empty = ''\n        else:\n            empty = b''\n        kwargs['input'] = empty\n\n    return run(*popenargs, stdout=PIPE, timeout=timeout, check=True,\n               **kwargs).stdout\n\n\nclass CompletedProcess(object):\n    \"\"\"A process that has finished running.\n\n    This is returned by run().\n\n    Attributes:\n      args: The list or str args passed to run().\n      returncode: The exit code of the process, negative for signals.\n      stdout: The standard output (None if not captured).\n      stderr: The standard error (None if not captured).\n    \"\"\"\n    def __init__(self, args, returncode, stdout=None, stderr=None):\n        self.args = args\n        self.returncode = returncode\n        self.stdout = stdout\n        self.stderr = stderr\n\n    def __repr__(self):\n        args = ['args={!r}'.format(self.args),\n                'returncode={!r}'.format(self.returncode)]\n        if self.stdout is not None:\n            args.append('stdout={!r}'.format(self.stdout))\n        if self.stderr is not None:\n            args.append('stderr={!r}'.format(self.stderr))\n        return \"{}({})\".format(type(self).__name__, ', '.join(args))\n\n    __class_getitem__ = classmethod(types.GenericAlias)\n\n\n    def check_returncode(self):\n        \"\"\"Raise CalledProcessError if the exit code is non-zero.\"\"\"\n        if self.returncode:\n            raise CalledProcessError(self.returncode, self.args, self.stdout,\n                                     self.stderr)\n\n\ndef run(*popenargs,\n        input=None, capture_output=False, timeout=None, check=False, **kwargs):\n    \"\"\"Run command with arguments and return a CompletedProcess instance.\n\n    The returned instance will have attributes args, returncode, stdout and\n    stderr. By default, stdout and stderr are not captured, and those attributes\n    will be None. Pass stdout=PIPE and/or stderr=PIPE in order to capture them.\n\n    If check is True and the exit code was non-zero, it raises a\n    CalledProcessError. The CalledProcessError object will have the return code\n    in the returncode attribute, and output & stderr attributes if those streams\n    were captured.\n\n    If timeout is given, and the process takes too long, a TimeoutExpired\n    exception will be raised.\n\n    There is an optional argument \"input\", allowing you to\n    pass bytes or a string to the subprocess's stdin.  If you use this argument\n    you may not also use the Popen constructor's \"stdin\" argument, as\n    it will be used internally.\n\n    By default, all communication is in bytes, and therefore any \"input\" should\n    be bytes, and the stdout and stderr will be bytes. If in text mode, any\n    \"input\" should be a string, and stdout and stderr will be strings decoded\n    according to locale encoding, or by \"encoding\" if set. Text mode is\n    triggered by setting any of text, encoding, errors or universal_newlines.\n\n    The other arguments are the same as for the Popen constructor.\n    \"\"\"\n    if input is not None:\n        if kwargs.get('stdin') is not None:\n            raise ValueError('stdin and input arguments may not both be used.')\n        kwargs['stdin'] = PIPE\n\n    if capture_output:\n        if kwargs.get('stdout') is not None or kwargs.get('stderr') is not None:\n            raise ValueError('stdout and stderr arguments may not be used '\n                             'with capture_output.')\n        kwargs['stdout'] = PIPE\n        kwargs['stderr'] = PIPE\n\n    with Popen(*popenargs, **kwargs) as process:\n        try:\n            stdout, stderr = process.communicate(input, timeout=timeout)\n        except TimeoutExpired as exc:\n            process.kill()\n            if _mswindows:\n                # Windows accumulates the output in a single blocking\n                # read() call run on child threads, with the timeout\n                # being done in a join() on those threads.  communicate()\n                # _after_ kill() is required to collect that and add it\n                # to the exception.\n                exc.stdout, exc.stderr = process.communicate()\n            else:\n                # POSIX _communicate already populated the output so\n                # far into the TimeoutExpired exception.\n                process.wait()\n            raise\n        except:  # Including KeyboardInterrupt, communicate handled that.\n            process.kill()\n            # We don't call process.wait() as .__exit__ does that for us.\n            raise\n        retcode = process.poll()\n        if check and retcode:\n            raise CalledProcessError(retcode, process.args,\n                                     output=stdout, stderr=stderr)\n    return CompletedProcess(process.args, retcode, stdout, stderr)\n\n\ndef list2cmdline(seq):\n    \"\"\"\n    Translate a sequence of arguments into a command line\n    string, using the same rules as the MS C runtime:\n\n    1) Arguments are delimited by white space, which is either a\n       space or a tab.\n\n    2) A string surrounded by double quotation marks is\n       interpreted as a single argument, regardless of white space\n       contained within.  A quoted string can be embedded in an\n       argument.\n\n    3) A double quotation mark preceded by a backslash is\n       interpreted as a literal double quotation mark.\n\n    4) Backslashes are interpreted literally, unless they\n       immediately precede a double quotation mark.\n\n    5) If backslashes immediately precede a double quotation mark,\n       every pair of backslashes is interpreted as a literal\n       backslash.  If the number of backslashes is odd, the last\n       backslash escapes the next double quotation mark as\n       described in rule 3.\n    \"\"\"\n\n    # See\n    # http://msdn.microsoft.com/en-us/library/17w5ykft.aspx\n    # or search http://msdn.microsoft.com for\n    # \"Parsing C++ Command-Line Arguments\"\n    result = []\n    needquote = False\n    for arg in map(os.fsdecode, seq):\n        bs_buf = []\n\n        # Add a space to separate this argument from the others\n        if result:\n            result.append(' ')\n\n        needquote = (\" \" in arg) or (\"\\t\" in arg) or not arg\n        if needquote:\n            result.append('\"')\n\n        for c in arg:\n            if c == '\\\\':\n                # Don't know if we need to double yet.\n                bs_buf.append(c)\n            elif c == '\"':\n                # Double backslashes.\n                result.append('\\\\' * len(bs_buf)*2)\n                bs_buf = []\n                result.append('\\\\\"')\n            else:\n                # Normal char\n                if bs_buf:\n                    result.extend(bs_buf)\n                    bs_buf = []\n                result.append(c)\n\n        # Add remaining backslashes, if any.\n        if bs_buf:\n            result.extend(bs_buf)\n\n        if needquote:\n            result.extend(bs_buf)\n            result.append('\"')\n\n    return ''.join(result)\n\n\n# Various tools for executing commands and looking at their output and status.\n#\n\ndef getstatusoutput(cmd, *, encoding=None, errors=None):\n    \"\"\"Return (exitcode, output) of executing cmd in a shell.\n\n    Execute the string 'cmd' in a shell with 'check_output' and\n    return a 2-tuple (status, output). The locale encoding is used\n    to decode the output and process newlines.\n\n    A trailing newline is stripped from the output.\n    The exit status for the command can be interpreted\n    according to the rules for the function 'wait'. Example:\n\n    >>> import subprocess\n    >>> subprocess.getstatusoutput('ls /bin/ls')\n    (0, '/bin/ls')\n    >>> subprocess.getstatusoutput('cat /bin/junk')\n    (1, 'cat: /bin/junk: No such file or directory')\n    >>> subprocess.getstatusoutput('/bin/junk')\n    (127, 'sh: /bin/junk: not found')\n    >>> subprocess.getstatusoutput('/bin/kill $$')\n    (-15, '')\n    \"\"\"\n    try:\n        data = check_output(cmd, shell=True, text=True, stderr=STDOUT,\n                            encoding=encoding, errors=errors)\n        exitcode = 0\n    except CalledProcessError as ex:\n        data = ex.output\n        exitcode = ex.returncode\n    if data[-1:] == '\\n':\n        data = data[:-1]\n    return exitcode, data\n\ndef getoutput(cmd, *, encoding=None, errors=None):\n    \"\"\"Return output (stdout or stderr) of executing cmd in a shell.\n\n    Like getstatusoutput(), except the exit status is ignored and the return\n    value is a string containing the command's output.  Example:\n\n    >>> import subprocess\n    >>> subprocess.getoutput('ls /bin/ls')\n    '/bin/ls'\n    \"\"\"\n    return getstatusoutput(cmd, encoding=encoding, errors=errors)[1]\n\n\n\ndef _use_posix_spawn():\n    \"\"\"Check if posix_spawn() can be used for subprocess.\n\n    subprocess requires a posix_spawn() implementation that properly reports\n    errors to the parent process, & sets errno on the following failures:\n\n    * Process attribute actions failed.\n    * File actions failed.\n    * exec() failed.\n\n    Prefer an implementation which can use vfork() in some cases for best\n    performance.\n    \"\"\"\n    if _mswindows or not hasattr(os, 'posix_spawn'):\n        # os.posix_spawn() is not available\n        return False\n\n    if sys.platform in ('darwin', 'sunos5'):\n        # posix_spawn() is a syscall on both macOS and Solaris,\n        # and properly reports errors\n        return True\n\n    # Check libc name and runtime libc version\n    try:\n        ver = os.confstr('CS_GNU_LIBC_VERSION')\n        # parse 'glibc 2.28' as ('glibc', (2, 28))\n        parts = ver.split(maxsplit=1)\n        if len(parts) != 2:\n            # reject unknown format\n            raise ValueError\n        libc = parts[0]\n        version = tuple(map(int, parts[1].split('.')))\n\n        if sys.platform == 'linux' and libc == 'glibc' and version >= (2, 24):\n            # glibc 2.24 has a new Linux posix_spawn implementation using vfork\n            # which properly reports errors to the parent process.\n            return True\n        # Note: Don't use the implementation in earlier glibc because it doesn't\n        # use vfork (even if glibc 2.26 added a pipe to properly report errors\n        # to the parent process).\n    except (AttributeError, ValueError, OSError):\n        # os.confstr() or CS_GNU_LIBC_VERSION value not available\n        pass\n\n    # By default, assume that posix_spawn() does not properly report errors.\n    return False\n\n\n# These are primarily fail-safe knobs for negatives. A True value does not\n# guarantee the given libc/syscall API will be used.\n_USE_POSIX_SPAWN = _use_posix_spawn()\n_USE_VFORK = True\n\n\nclass Popen:\n    \"\"\" Execute a child program in a new process.\n\n    For a complete description of the arguments see the Python documentation.\n\n    Arguments:\n      args: A string, or a sequence of program arguments.\n\n      bufsize: supplied as the buffering argument to the open() function when\n          creating the stdin/stdout/stderr pipe file objects\n\n      executable: A replacement program to execute.\n\n      stdin, stdout and stderr: These specify the executed programs' standard\n          input, standard output and standard error file handles, respectively.\n\n      preexec_fn: (POSIX only) An object to be called in the child process\n          just before the child is executed.\n\n      close_fds: Controls closing or inheriting of file descriptors.\n\n      shell: If true, the command will be executed through the shell.\n\n      cwd: Sets the current directory before the child is executed.\n\n      env: Defines the environment variables for the new process.\n\n      text: If true, decode stdin, stdout and stderr using the given encoding\n          (if set) or the system default otherwise.\n\n      universal_newlines: Alias of text, provided for backwards compatibility.\n\n      startupinfo and creationflags (Windows only)\n\n      restore_signals (POSIX only)\n\n      start_new_session (POSIX only)\n\n      process_group (POSIX only)\n\n      group (POSIX only)\n\n      extra_groups (POSIX only)\n\n      user (POSIX only)\n\n      umask (POSIX only)\n\n      pass_fds (POSIX only)\n\n      encoding and errors: Text mode encoding and error handling to use for\n          file objects stdin, stdout and stderr.\n\n    Attributes:\n        stdin, stdout, stderr, pid, returncode\n    \"\"\"\n    _child_created = False  # Set here since __del__ checks it\n\n    def __init__(self, args, bufsize=-1, executable=None,\n                 stdin=None, stdout=None, stderr=None,\n                 preexec_fn=None, close_fds=True,\n                 shell=False, cwd=None, env=None, universal_newlines=None,\n                 startupinfo=None, creationflags=0,\n                 restore_signals=True, start_new_session=False,\n                 pass_fds=(), *, user=None, group=None, extra_groups=None,\n                 encoding=None, errors=None, text=None, umask=-1, pipesize=-1,\n                 process_group=None):\n        \"\"\"Create new Popen instance.\"\"\"\n        if not _can_fork_exec:\n            raise OSError(\n                errno.ENOTSUP, f\"{sys.platform} does not support processes.\"\n            )\n\n        _cleanup()\n        # Held while anything is calling waitpid before returncode has been\n        # updated to prevent clobbering returncode if wait() or poll() are\n        # called from multiple threads at once.  After acquiring the lock,\n        # code must re-check self.returncode to see if another thread just\n        # finished a waitpid() call.\n        self._waitpid_lock = threading.Lock()\n\n        self._input = None\n        self._communication_started = False\n        if bufsize is None:\n            bufsize = -1  # Restore default\n        if not isinstance(bufsize, int):\n            raise TypeError(\"bufsize must be an integer\")\n\n        if pipesize is None:\n            pipesize = -1  # Restore default\n        if not isinstance(pipesize, int):\n            raise TypeError(\"pipesize must be an integer\")\n\n        if _mswindows:\n            if preexec_fn is not None:\n                raise ValueError(\"preexec_fn is not supported on Windows \"\n                                 \"platforms\")\n        else:\n            # POSIX\n            if pass_fds and not close_fds:\n                warnings.warn(\"pass_fds overriding close_fds.\", RuntimeWarning)\n                close_fds = True\n            if startupinfo is not None:\n                raise ValueError(\"startupinfo is only supported on Windows \"\n                                 \"platforms\")\n            if creationflags != 0:\n                raise ValueError(\"creationflags is only supported on Windows \"\n                                 \"platforms\")\n\n        self.args = args\n        self.stdin = None\n        self.stdout = None\n        self.stderr = None\n        self.pid = None\n        self.returncode = None\n        self.encoding = encoding\n        self.errors = errors\n        self.pipesize = pipesize\n\n        # Validate the combinations of text and universal_newlines\n        if (text is not None and universal_newlines is not None\n            and bool(universal_newlines) != bool(text)):\n            raise SubprocessError('Cannot disambiguate when both text '\n                                  'and universal_newlines are supplied but '\n                                  'different. Pass one or the other.')\n\n        # Input and output objects. The general principle is like\n        # this:\n        #\n        # Parent                   Child\n        # ------                   -----\n        # p2cwrite   ---stdin--->  p2cread\n        # c2pread    <--stdout---  c2pwrite\n        # errread    <--stderr---  errwrite\n        #\n        # On POSIX, the child objects are file descriptors.  On\n        # Windows, these are Windows file handles.  The parent objects\n        # are file descriptors on both platforms.  The parent objects\n        # are -1 when not using PIPEs. The child objects are -1\n        # when not redirecting.\n\n        (p2cread, p2cwrite,\n         c2pread, c2pwrite,\n         errread, errwrite) = self._get_handles(stdin, stdout, stderr)\n\n        # We wrap OS handles *before* launching the child, otherwise a\n        # quickly terminating child could make our fds unwrappable\n        # (see #8458).\n\n        if _mswindows:\n            if p2cwrite != -1:\n                p2cwrite = msvcrt.open_osfhandle(p2cwrite.Detach(), 0)\n            if c2pread != -1:\n                c2pread = msvcrt.open_osfhandle(c2pread.Detach(), 0)\n            if errread != -1:\n                errread = msvcrt.open_osfhandle(errread.Detach(), 0)\n\n        self.text_mode = encoding or errors or text or universal_newlines\n        if self.text_mode and encoding is None:\n            self.encoding = encoding = _text_encoding()\n\n        # How long to resume waiting on a child after the first ^C.\n        # There is no right value for this.  The purpose is to be polite\n        # yet remain good for interactive users trying to exit a tool.\n        self._sigint_wait_secs = 0.25  # 1/xkcd221.getRandomNumber()\n\n        self._closed_child_pipe_fds = False\n\n        if self.text_mode:\n            if bufsize == 1:\n                line_buffering = True\n                # Use the default buffer size for the underlying binary streams\n                # since they don't support line buffering.\n                bufsize = -1\n            else:\n                line_buffering = False\n\n        if process_group is None:\n            process_group = -1  # The internal APIs are int-only\n\n        gid = None\n        if group is not None:\n            if not hasattr(os, 'setregid'):\n                raise ValueError(\"The 'group' parameter is not supported on the \"\n                                 \"current platform\")\n\n            elif isinstance(group, str):\n                try:\n                    import grp\n                except ImportError:\n                    raise ValueError(\"The group parameter cannot be a string \"\n                                     \"on systems without the grp module\")\n\n                gid = grp.getgrnam(group).gr_gid\n            elif isinstance(group, int):\n                gid = group\n            else:\n                raise TypeError(\"Group must be a string or an integer, not {}\"\n                                .format(type(group)))\n\n            if gid < 0:\n                raise ValueError(f\"Group ID cannot be negative, got {gid}\")\n\n        gids = None\n        if extra_groups is not None:\n            if not hasattr(os, 'setgroups'):\n                raise ValueError(\"The 'extra_groups' parameter is not \"\n                                 \"supported on the current platform\")\n\n            elif isinstance(extra_groups, str):\n                raise ValueError(\"Groups must be a list, not a string\")\n\n            gids = []\n            for extra_group in extra_groups:\n                if isinstance(extra_group, str):\n                    try:\n                        import grp\n                    except ImportError:\n                        raise ValueError(\"Items in extra_groups cannot be \"\n                                         \"strings on systems without the \"\n                                         \"grp module\")\n\n                    gids.append(grp.getgrnam(extra_group).gr_gid)\n                elif isinstance(extra_group, int):\n                    gids.append(extra_group)\n                else:\n                    raise TypeError(\"Items in extra_groups must be a string \"\n                                    \"or integer, not {}\"\n                                    .format(type(extra_group)))\n\n            # make sure that the gids are all positive here so we can do less\n            # checking in the C code\n            for gid_check in gids:\n                if gid_check < 0:\n                    raise ValueError(f\"Group ID cannot be negative, got {gid_check}\")\n\n        uid = None\n        if user is not None:\n            if not hasattr(os, 'setreuid'):\n                raise ValueError(\"The 'user' parameter is not supported on \"\n                                 \"the current platform\")\n\n            elif isinstance(user, str):\n                try:\n                    import pwd\n                except ImportError:\n                    raise ValueError(\"The user parameter cannot be a string \"\n                                     \"on systems without the pwd module\")\n                uid = pwd.getpwnam(user).pw_uid\n            elif isinstance(user, int):\n                uid = user\n            else:\n                raise TypeError(\"User must be a string or an integer\")\n\n            if uid < 0:\n                raise ValueError(f\"User ID cannot be negative, got {uid}\")\n\n        try:\n            if p2cwrite != -1:\n                self.stdin = io.open(p2cwrite, 'wb', bufsize)\n                if self.text_mode:\n                    self.stdin = io.TextIOWrapper(self.stdin, write_through=True,\n                            line_buffering=line_buffering,\n                            encoding=encoding, errors=errors)\n            if c2pread != -1:\n                self.stdout = io.open(c2pread, 'rb', bufsize)\n                if self.text_mode:\n                    self.stdout = io.TextIOWrapper(self.stdout,\n                            encoding=encoding, errors=errors)\n            if errread != -1:\n                self.stderr = io.open(errread, 'rb', bufsize)\n                if self.text_mode:\n                    self.stderr = io.TextIOWrapper(self.stderr,\n                            encoding=encoding, errors=errors)\n\n            self._execute_child(args, executable, preexec_fn, close_fds,\n                                pass_fds, cwd, env,\n                                startupinfo, creationflags, shell,\n                                p2cread, p2cwrite,\n                                c2pread, c2pwrite,\n                                errread, errwrite,\n                                restore_signals,\n                                gid, gids, uid, umask,\n                                start_new_session, process_group)\n        except:\n            # Cleanup if the child failed starting.\n            for f in filter(None, (self.stdin, self.stdout, self.stderr)):\n                try:\n                    f.close()\n                except OSError:\n                    pass  # Ignore EBADF or other errors.\n\n            if not self._closed_child_pipe_fds:\n                to_close = []\n                if stdin == PIPE:\n                    to_close.append(p2cread)\n                if stdout == PIPE:\n                    to_close.append(c2pwrite)\n                if stderr == PIPE:\n                    to_close.append(errwrite)\n                if hasattr(self, '_devnull'):\n                    to_close.append(self._devnull)\n                for fd in to_close:\n                    try:\n                        if _mswindows and isinstance(fd, Handle):\n                            fd.Close()\n                        else:\n                            os.close(fd)\n                    except OSError:\n                        pass\n\n            raise\n\n    def __repr__(self):\n        obj_repr = (\n            f\"<{self.__class__.__name__}: \"\n            f\"returncode: {self.returncode} args: {self.args!r}>\"\n        )\n        if len(obj_repr) > 80:\n            obj_repr = obj_repr[:76] + \"...>\"\n        return obj_repr\n\n    __class_getitem__ = classmethod(types.GenericAlias)\n\n    @property\n    def universal_newlines(self):\n        # universal_newlines as retained as an alias of text_mode for API\n        # compatibility. bpo-31756\n        return self.text_mode\n\n    @universal_newlines.setter\n    def universal_newlines(self, universal_newlines):\n        self.text_mode = bool(universal_newlines)\n\n    def _translate_newlines(self, data, encoding, errors):\n        data = data.decode(encoding, errors)\n        return data.replace(\"\\r\\n\", \"\\n\").replace(\"\\r\", \"\\n\")\n\n    def __enter__(self):\n        return self\n\n    def __exit__(self, exc_type, value, traceback):\n        if self.stdout:\n            self.stdout.close()\n        if self.stderr:\n            self.stderr.close()\n        try:  # Flushing a BufferedWriter may raise an error\n            if self.stdin:\n                self.stdin.close()\n        finally:\n            if exc_type == KeyboardInterrupt:\n                # https://bugs.python.org/issue25942\n                # In the case of a KeyboardInterrupt we assume the SIGINT\n                # was also already sent to our child processes.  We can't\n                # block indefinitely as that is not user friendly.\n                # If we have not already waited a brief amount of time in\n                # an interrupted .wait() or .communicate() call, do so here\n                # for consistency.\n                if self._sigint_wait_secs > 0:\n                    try:\n                        self._wait(timeout=self._sigint_wait_secs)\n                    except TimeoutExpired:\n                        pass\n                self._sigint_wait_secs = 0  # Note that this has been done.\n                return  # resume the KeyboardInterrupt\n\n            # Wait for the process to terminate, to avoid zombies.\n            self.wait()\n\n    def __del__(self, _maxsize=sys.maxsize, _warn=warnings.warn):\n        if not self._child_created:\n            # We didn't get to successfully create a child process.\n            return\n        if self.returncode is None:\n            # Not reading subprocess exit status creates a zombie process which\n            # is only destroyed at the parent python process exit\n            _warn(\"subprocess %s is still running\" % self.pid,\n                  ResourceWarning, source=self)\n        # In case the child hasn't been waited on, check if it's done.\n        self._internal_poll(_deadstate=_maxsize)\n        if self.returncode is None and _active is not None:\n            # Child is still running, keep us alive until we can wait on it.\n            _active.append(self)\n\n    def _get_devnull(self):\n        if not hasattr(self, '_devnull'):\n            self._devnull = os.open(os.devnull, os.O_RDWR)\n        return self._devnull\n\n    def _stdin_write(self, input):\n        if input:\n            try:\n                self.stdin.write(input)\n            except BrokenPipeError:\n                pass  # communicate() must ignore broken pipe errors.\n            except OSError as exc:\n                if exc.errno == errno.EINVAL:\n                    # bpo-19612, bpo-30418: On Windows, stdin.write() fails\n                    # with EINVAL if the child process exited or if the child\n                    # process is still running but closed the pipe.\n                    pass\n                else:\n                    raise\n\n        try:\n            self.stdin.close()\n        except BrokenPipeError:\n            pass  # communicate() must ignore broken pipe errors.\n        except OSError as exc:\n            if exc.errno == errno.EINVAL:\n                pass\n            else:\n                raise\n\n    def communicate(self, input=None, timeout=None):\n        \"\"\"Interact with process: Send data to stdin and close it.\n        Read data from stdout and stderr, until end-of-file is\n        reached.  Wait for process to terminate.\n\n        The optional \"input\" argument should be data to be sent to the\n        child process, or None, if no data should be sent to the child.\n        communicate() returns a tuple (stdout, stderr).\n\n        By default, all communication is in bytes, and therefore any\n        \"input\" should be bytes, and the (stdout, stderr) will be bytes.\n        If in text mode (indicated by self.text_mode), any \"input\" should\n        be a string, and (stdout, stderr) will be strings decoded\n        according to locale encoding, or by \"encoding\" if set. Text mode\n        is triggered by setting any of text, encoding, errors or\n        universal_newlines.\n        \"\"\"\n\n        if self._communication_started and input:\n            raise ValueError(\"Cannot send input after starting communication\")\n\n        # Optimization: If we are not worried about timeouts, we haven't\n        # started communicating, and we have one or zero pipes, using select()\n        # or threads is unnecessary.\n        if (timeout is None and not self._communication_started and\n            [self.stdin, self.stdout, self.stderr].count(None) >= 2):\n            stdout = None\n            stderr = None\n            if self.stdin:\n                self._stdin_write(input)\n            elif self.stdout:\n                stdout = self.stdout.read()\n                self.stdout.close()\n            elif self.stderr:\n                stderr = self.stderr.read()\n                self.stderr.close()\n            self.wait()\n        else:\n            if timeout is not None:\n                endtime = _time() + timeout\n            else:\n                endtime = None\n\n            try:\n                stdout, stderr = self._communicate(input, endtime, timeout)\n            except KeyboardInterrupt:\n                # https://bugs.python.org/issue25942\n                # See the detailed comment in .wait().\n                if timeout is not None:\n                    sigint_timeout = min(self._sigint_wait_secs,\n                                         self._remaining_time(endtime))\n                else:\n                    sigint_timeout = self._sigint_wait_secs\n                self._sigint_wait_secs = 0  # nothing else should wait.\n                try:\n                    self._wait(timeout=sigint_timeout)\n                except TimeoutExpired:\n                    pass\n                raise  # resume the KeyboardInterrupt\n\n            finally:\n                self._communication_started = True\n\n            sts = self.wait(timeout=self._remaining_time(endtime))\n\n        return (stdout, stderr)\n\n\n    def poll(self):\n        \"\"\"Check if child process has terminated. Set and return returncode\n        attribute.\"\"\"\n        return self._internal_poll()\n\n\n    def _remaining_time(self, endtime):\n        \"\"\"Convenience for _communicate when computing timeouts.\"\"\"\n        if endtime is None:\n            return None\n        else:\n            return endtime - _time()\n\n\n    def _check_timeout(self, endtime, orig_timeout, stdout_seq, stderr_seq,\n                       skip_check_and_raise=False):\n        \"\"\"Convenience for checking if a timeout has expired.\"\"\"\n        if endtime is None:\n            return\n        if skip_check_and_raise or _time() > endtime:\n            raise TimeoutExpired(\n                    self.args, orig_timeout,\n                    output=b''.join(stdout_seq) if stdout_seq else None,\n                    stderr=b''.join(stderr_seq) if stderr_seq else None)\n\n\n    def wait(self, timeout=None):\n        \"\"\"Wait for child process to terminate; returns self.returncode.\"\"\"\n        if timeout is not None:\n            endtime = _time() + timeout\n        try:\n            return self._wait(timeout=timeout)\n        except KeyboardInterrupt:\n            # https://bugs.python.org/issue25942\n            # The first keyboard interrupt waits briefly for the child to\n            # exit under the common assumption that it also received the ^C\n            # generated SIGINT and will exit rapidly.\n            if timeout is not None:\n                sigint_timeout = min(self._sigint_wait_secs,\n                                     self._remaining_time(endtime))\n            else:\n                sigint_timeout = self._sigint_wait_secs\n            self._sigint_wait_secs = 0  # nothing else should wait.\n            try:\n                self._wait(timeout=sigint_timeout)\n            except TimeoutExpired:\n                pass\n            raise  # resume the KeyboardInterrupt\n\n    def _close_pipe_fds(self,\n                        p2cread, p2cwrite,\n                        c2pread, c2pwrite,\n                        errread, errwrite):\n        # self._devnull is not always defined.\n        devnull_fd = getattr(self, '_devnull', None)\n\n        with contextlib.ExitStack() as stack:\n            if _mswindows:\n                if p2cread != -1:\n                    stack.callback(p2cread.Close)\n                if c2pwrite != -1:\n                    stack.callback(c2pwrite.Close)\n                if errwrite != -1:\n                    stack.callback(errwrite.Close)\n            else:\n                if p2cread != -1 and p2cwrite != -1 and p2cread != devnull_fd:\n                    stack.callback(os.close, p2cread)\n                if c2pwrite != -1 and c2pread != -1 and c2pwrite != devnull_fd:\n                    stack.callback(os.close, c2pwrite)\n                if errwrite != -1 and errread != -1 and errwrite != devnull_fd:\n                    stack.callback(os.close, errwrite)\n\n            if devnull_fd is not None:\n                stack.callback(os.close, devnull_fd)\n\n        # Prevent a double close of these handles/fds from __init__ on error.\n        self._closed_child_pipe_fds = True\n\n    if _mswindows:\n        #\n        # Windows methods\n        #\n        def _get_handles(self, stdin, stdout, stderr):\n            \"\"\"Construct and return tuple with IO objects:\n            p2cread, p2cwrite, c2pread, c2pwrite, errread, errwrite\n            \"\"\"\n            if stdin is None and stdout is None and stderr is None:\n                return (-1, -1, -1, -1, -1, -1)\n\n            p2cread, p2cwrite = -1, -1\n            c2pread, c2pwrite = -1, -1\n            errread, errwrite = -1, -1\n\n            if stdin is None:\n                p2cread = _winapi.GetStdHandle(_winapi.STD_INPUT_HANDLE)\n                if p2cread is None:\n                    p2cread, _ = _winapi.CreatePipe(None, 0)\n                    p2cread = Handle(p2cread)\n                    _winapi.CloseHandle(_)\n            elif stdin == PIPE:\n                p2cread, p2cwrite = _winapi.CreatePipe(None, 0)\n                p2cread, p2cwrite = Handle(p2cread), Handle(p2cwrite)\n            elif stdin == DEVNULL:\n                p2cread = msvcrt.get_osfhandle(self._get_devnull())\n            elif isinstance(stdin, int):\n                p2cread = msvcrt.get_osfhandle(stdin)\n            else:\n                # Assuming file-like object\n                p2cread = msvcrt.get_osfhandle(stdin.fileno())\n            p2cread = self._make_inheritable(p2cread)\n\n            if stdout is None:\n                c2pwrite = _winapi.GetStdHandle(_winapi.STD_OUTPUT_HANDLE)\n                if c2pwrite is None:\n                    _, c2pwrite = _winapi.CreatePipe(None, 0)\n                    c2pwrite = Handle(c2pwrite)\n                    _winapi.CloseHandle(_)\n            elif stdout == PIPE:\n                c2pread, c2pwrite = _winapi.CreatePipe(None, 0)\n                c2pread, c2pwrite = Handle(c2pread), Handle(c2pwrite)\n            elif stdout == DEVNULL:\n                c2pwrite = msvcrt.get_osfhandle(self._get_devnull())\n            elif isinstance(stdout, int):\n                c2pwrite = msvcrt.get_osfhandle(stdout)\n            else:\n                # Assuming file-like object\n                c2pwrite = msvcrt.get_osfhandle(stdout.fileno())\n            c2pwrite = self._make_inheritable(c2pwrite)\n\n            if stderr is None:\n                errwrite = _winapi.GetStdHandle(_winapi.STD_ERROR_HANDLE)\n                if errwrite is None:\n                    _, errwrite = _winapi.CreatePipe(None, 0)\n                    errwrite = Handle(errwrite)\n                    _winapi.CloseHandle(_)\n            elif stderr == PIPE:\n                errread, errwrite = _winapi.CreatePipe(None, 0)\n                errread, errwrite = Handle(errread), Handle(errwrite)\n            elif stderr == STDOUT:\n                errwrite = c2pwrite\n            elif stderr == DEVNULL:\n                errwrite = msvcrt.get_osfhandle(self._get_devnull())\n            elif isinstance(stderr, int):\n                errwrite = msvcrt.get_osfhandle(stderr)\n            else:\n                # Assuming file-like object\n                errwrite = msvcrt.get_osfhandle(stderr.fileno())\n            errwrite = self._make_inheritable(errwrite)\n\n            return (p2cread, p2cwrite,\n                    c2pread, c2pwrite,\n                    errread, errwrite)\n\n\n        def _make_inheritable(self, handle):\n            \"\"\"Return a duplicate of handle, which is inheritable\"\"\"\n            h = _winapi.DuplicateHandle(\n                _winapi.GetCurrentProcess(), handle,\n                _winapi.GetCurrentProcess(), 0, 1,\n                _winapi.DUPLICATE_SAME_ACCESS)\n            return Handle(h)\n\n\n        def _filter_handle_list(self, handle_list):\n            \"\"\"Filter out console handles that can't be used\n            in lpAttributeList[\"handle_list\"] and make sure the list\n            isn't empty. This also removes duplicate handles.\"\"\"\n            # An handle with it's lowest two bits set might be a special console\n            # handle that if passed in lpAttributeList[\"handle_list\"], will\n            # cause it to fail.\n            return list({handle for handle in handle_list\n                         if handle & 0x3 != 0x3\n                         or _winapi.GetFileType(handle) !=\n                            _winapi.FILE_TYPE_CHAR})\n\n\n        def _execute_child(self, args, executable, preexec_fn, close_fds,\n                           pass_fds, cwd, env,\n                           startupinfo, creationflags, shell,\n                           p2cread, p2cwrite,\n                           c2pread, c2pwrite,\n                           errread, errwrite,\n                           unused_restore_signals,\n                           unused_gid, unused_gids, unused_uid,\n                           unused_umask,\n                           unused_start_new_session, unused_process_group):\n            \"\"\"Execute program (MS Windows version)\"\"\"\n\n            assert not pass_fds, \"pass_fds not supported on Windows.\"\n\n            if isinstance(args, str):\n                pass\n            elif isinstance(args, bytes):\n                if shell:\n                    raise TypeError('bytes args is not allowed on Windows')\n                args = list2cmdline([args])\n            elif isinstance(args, os.PathLike):\n                if shell:\n                    raise TypeError('path-like args is not allowed when '\n                                    'shell is true')\n                args = list2cmdline([args])\n            else:\n                args = list2cmdline(args)\n\n            if executable is not None:\n                executable = os.fsdecode(executable)\n\n            # Process startup details\n            if startupinfo is None:\n                startupinfo = STARTUPINFO()\n            else:\n                # bpo-34044: Copy STARTUPINFO since it is modified above,\n                # so the caller can reuse it multiple times.\n                startupinfo = startupinfo.copy()\n\n            use_std_handles = -1 not in (p2cread, c2pwrite, errwrite)\n            if use_std_handles:\n                startupinfo.dwFlags |= _winapi.STARTF_USESTDHANDLES\n                startupinfo.hStdInput = p2cread\n                startupinfo.hStdOutput = c2pwrite\n                startupinfo.hStdError = errwrite\n\n            attribute_list = startupinfo.lpAttributeList\n            have_handle_list = bool(attribute_list and\n                                    \"handle_list\" in attribute_list and\n                                    attribute_list[\"handle_list\"])\n\n            # If we were given an handle_list or need to create one\n            if have_handle_list or (use_std_handles and close_fds):\n                if attribute_list is None:\n                    attribute_list = startupinfo.lpAttributeList = {}\n                handle_list = attribute_list[\"handle_list\"] = \\\n                    list(attribute_list.get(\"handle_list\", []))\n\n                if use_std_handles:\n                    handle_list += [int(p2cread), int(c2pwrite), int(errwrite)]\n\n                handle_list[:] = self._filter_handle_list(handle_list)\n\n                if handle_list:\n                    if not close_fds:\n                        warnings.warn(\"startupinfo.lpAttributeList['handle_list'] \"\n                                      \"overriding close_fds\", RuntimeWarning)\n\n                    # When using the handle_list we always request to inherit\n                    # handles but the only handles that will be inherited are\n                    # the ones in the handle_list\n                    close_fds = False\n\n            if shell:\n                startupinfo.dwFlags |= _winapi.STARTF_USESHOWWINDOW\n                startupinfo.wShowWindow = _winapi.SW_HIDE\n                comspec = os.environ.get(\"COMSPEC\", \"cmd.exe\")\n                args = '{} /c \"{}\"'.format (comspec, args)\n\n            if cwd is not None:\n                cwd = os.fsdecode(cwd)\n\n            sys.audit(\"subprocess.Popen\", executable, args, cwd, env)\n\n            # Start the process\n            try:\n                hp, ht, pid, tid = _winapi.CreateProcess(executable, args,\n                                         # no special security\n                                         None, None,\n                                         int(not close_fds),\n                                         creationflags,\n                                         env,\n                                         cwd,\n                                         startupinfo)\n            finally:\n                # Child is launched. Close the parent's copy of those pipe\n                # handles that only the child should have open.  You need\n                # to make sure that no handles to the write end of the\n                # output pipe are maintained in this process or else the\n                # pipe will not close when the child process exits and the\n                # ReadFile will hang.\n                self._close_pipe_fds(p2cread, p2cwrite,\n                                     c2pread, c2pwrite,\n                                     errread, errwrite)\n\n            # Retain the process handle, but close the thread handle\n            self._child_created = True\n            self._handle = Handle(hp)\n            self.pid = pid\n            _winapi.CloseHandle(ht)\n\n        def _internal_poll(self, _deadstate=None,\n                _WaitForSingleObject=_winapi.WaitForSingleObject,\n                _WAIT_OBJECT_0=_winapi.WAIT_OBJECT_0,\n                _GetExitCodeProcess=_winapi.GetExitCodeProcess):\n            \"\"\"Check if child process has terminated.  Returns returncode\n            attribute.\n\n            This method is called by __del__, so it can only refer to objects\n            in its local scope.\n\n            \"\"\"\n            if self.returncode is None:\n                if _WaitForSingleObject(self._handle, 0) == _WAIT_OBJECT_0:\n                    self.returncode = _GetExitCodeProcess(self._handle)\n            return self.returncode\n\n\n        def _wait(self, timeout):\n            \"\"\"Internal implementation of wait() on Windows.\"\"\"\n            if timeout is None:\n                timeout_millis = _winapi.INFINITE\n            else:\n                timeout_millis = int(timeout * 1000)\n            if self.returncode is None:\n                # API note: Returns immediately if timeout_millis == 0.\n                result = _winapi.WaitForSingleObject(self._handle,\n                                                     timeout_millis)\n                if result == _winapi.WAIT_TIMEOUT:\n                    raise TimeoutExpired(self.args, timeout)\n                self.returncode = _winapi.GetExitCodeProcess(self._handle)\n            return self.returncode\n\n\n        def _readerthread(self, fh, buffer):\n            buffer.append(fh.read())\n            fh.close()\n\n\n        def _communicate(self, input, endtime, orig_timeout):\n            # Start reader threads feeding into a list hanging off of this\n            # object, unless they've already been started.\n            if self.stdout and not hasattr(self, \"_stdout_buff\"):\n                self._stdout_buff = []\n                self.stdout_thread = \\\n                        threading.Thread(target=self._readerthread,\n                                         args=(self.stdout, self._stdout_buff))\n                self.stdout_thread.daemon = True\n                self.stdout_thread.start()\n            if self.stderr and not hasattr(self, \"_stderr_buff\"):\n                self._stderr_buff = []\n                self.stderr_thread = \\\n                        threading.Thread(target=self._readerthread,\n                                         args=(self.stderr, self._stderr_buff))\n                self.stderr_thread.daemon = True\n                self.stderr_thread.start()\n\n            if self.stdin:\n                self._stdin_write(input)\n\n            # Wait for the reader threads, or time out.  If we time out, the\n            # threads remain reading and the fds left open in case the user\n            # calls communicate again.\n            if self.stdout is not None:\n                self.stdout_thread.join(self._remaining_time(endtime))\n                if self.stdout_thread.is_alive():\n                    raise TimeoutExpired(self.args, orig_timeout)\n            if self.stderr is not None:\n                self.stderr_thread.join(self._remaining_time(endtime))\n                if self.stderr_thread.is_alive():\n                    raise TimeoutExpired(self.args, orig_timeout)\n\n            # Collect the output from and close both pipes, now that we know\n            # both have been read successfully.\n            stdout = None\n            stderr = None\n            if self.stdout:\n                stdout = self._stdout_buff\n                self.stdout.close()\n            if self.stderr:\n                stderr = self._stderr_buff\n                self.stderr.close()\n\n            # All data exchanged.  Translate lists into strings.\n            stdout = stdout[0] if stdout else None\n            stderr = stderr[0] if stderr else None\n\n            return (stdout, stderr)\n\n        def send_signal(self, sig):\n            \"\"\"Send a signal to the process.\"\"\"\n            # Don't signal a process that we know has already died.\n            if self.returncode is not None:\n                return\n            if sig == signal.SIGTERM:\n                self.terminate()\n            elif sig == signal.CTRL_C_EVENT:\n                os.kill(self.pid, signal.CTRL_C_EVENT)\n            elif sig == signal.CTRL_BREAK_EVENT:\n                os.kill(self.pid, signal.CTRL_BREAK_EVENT)\n            else:\n                raise ValueError(\"Unsupported signal: {}\".format(sig))\n\n        def terminate(self):\n            \"\"\"Terminates the process.\"\"\"\n            # Don't terminate a process that we know has already died.\n            if self.returncode is not None:\n                return\n            try:\n                _winapi.TerminateProcess(self._handle, 1)\n            except PermissionError:\n                # ERROR_ACCESS_DENIED (winerror 5) is received when the\n                # process already died.\n                rc = _winapi.GetExitCodeProcess(self._handle)\n                if rc == _winapi.STILL_ACTIVE:\n                    raise\n                self.returncode = rc\n\n        kill = terminate\n\n    else:\n        #\n        # POSIX methods\n        #\n        def _get_handles(self, stdin, stdout, stderr):\n            \"\"\"Construct and return tuple with IO objects:\n            p2cread, p2cwrite, c2pread, c2pwrite, errread, errwrite\n            \"\"\"\n            p2cread, p2cwrite = -1, -1\n            c2pread, c2pwrite = -1, -1\n            errread, errwrite = -1, -1\n\n            if stdin is None:\n                pass\n            elif stdin == PIPE:\n                p2cread, p2cwrite = os.pipe()\n                if self.pipesize > 0 and hasattr(fcntl, \"F_SETPIPE_SZ\"):\n                    fcntl.fcntl(p2cwrite, fcntl.F_SETPIPE_SZ, self.pipesize)\n            elif stdin == DEVNULL:\n                p2cread = self._get_devnull()\n            elif isinstance(stdin, int):\n                p2cread = stdin\n            else:\n                # Assuming file-like object\n                p2cread = stdin.fileno()\n\n            if stdout is None:\n                pass\n            elif stdout == PIPE:\n                c2pread, c2pwrite = os.pipe()\n                if self.pipesize > 0 and hasattr(fcntl, \"F_SETPIPE_SZ\"):\n                    fcntl.fcntl(c2pwrite, fcntl.F_SETPIPE_SZ, self.pipesize)\n            elif stdout == DEVNULL:\n                c2pwrite = self._get_devnull()\n            elif isinstance(stdout, int):\n                c2pwrite = stdout\n            else:\n                # Assuming file-like object\n                c2pwrite = stdout.fileno()\n\n            if stderr is None:\n                pass\n            elif stderr == PIPE:\n                errread, errwrite = os.pipe()\n                if self.pipesize > 0 and hasattr(fcntl, \"F_SETPIPE_SZ\"):\n                    fcntl.fcntl(errwrite, fcntl.F_SETPIPE_SZ, self.pipesize)\n            elif stderr == STDOUT:\n                if c2pwrite != -1:\n                    errwrite = c2pwrite\n                else: # child's stdout is not set, use parent's stdout\n                    errwrite = sys.__stdout__.fileno()\n            elif stderr == DEVNULL:\n                errwrite = self._get_devnull()\n            elif isinstance(stderr, int):\n                errwrite = stderr\n            else:\n                # Assuming file-like object\n                errwrite = stderr.fileno()\n\n            return (p2cread, p2cwrite,\n                    c2pread, c2pwrite,\n                    errread, errwrite)\n\n\n        def _posix_spawn(self, args, executable, env, restore_signals,\n                         p2cread, p2cwrite,\n                         c2pread, c2pwrite,\n                         errread, errwrite):\n            \"\"\"Execute program using os.posix_spawn().\"\"\"\n            if env is None:\n                env = os.environ\n\n            kwargs = {}\n            if restore_signals:\n                # See _Py_RestoreSignals() in Python/pylifecycle.c\n                sigset = []\n                for signame in ('SIGPIPE', 'SIGXFZ', 'SIGXFSZ'):\n                    signum = getattr(signal, signame, None)\n                    if signum is not None:\n                        sigset.append(signum)\n                kwargs['setsigdef'] = sigset\n\n            file_actions = []\n            for fd in (p2cwrite, c2pread, errread):\n                if fd != -1:\n                    file_actions.append((os.POSIX_SPAWN_CLOSE, fd))\n            for fd, fd2 in (\n                (p2cread, 0),\n                (c2pwrite, 1),\n                (errwrite, 2),\n            ):\n                if fd != -1:\n                    file_actions.append((os.POSIX_SPAWN_DUP2, fd, fd2))\n            if file_actions:\n                kwargs['file_actions'] = file_actions\n\n            self.pid = os.posix_spawn(executable, args, env, **kwargs)\n            self._child_created = True\n\n            self._close_pipe_fds(p2cread, p2cwrite,\n                                 c2pread, c2pwrite,\n                                 errread, errwrite)\n\n        def _execute_child(self, args, executable, preexec_fn, close_fds,\n                           pass_fds, cwd, env,\n                           startupinfo, creationflags, shell,\n                           p2cread, p2cwrite,\n                           c2pread, c2pwrite,\n                           errread, errwrite,\n                           restore_signals,\n                           gid, gids, uid, umask,\n                           start_new_session, process_group):\n            \"\"\"Execute program (POSIX version)\"\"\"\n\n            if isinstance(args, (str, bytes)):\n                args = [args]\n            elif isinstance(args, os.PathLike):\n                if shell:\n                    raise TypeError('path-like args is not allowed when '\n                                    'shell is true')\n                args = [args]\n            else:\n                args = list(args)\n\n            if shell:\n                # On Android the default shell is at '/system/bin/sh'.\n                unix_shell = ('/system/bin/sh' if\n                          hasattr(sys, 'getandroidapilevel') else '/bin/sh')\n                args = [unix_shell, \"-c\"] + args\n                if executable:\n                    args[0] = executable\n\n            if executable is None:\n                executable = args[0]\n\n            sys.audit(\"subprocess.Popen\", executable, args, cwd, env)\n\n            if (_USE_POSIX_SPAWN\n                    and os.path.dirname(executable)\n                    and preexec_fn is None\n                    and not close_fds\n                    and not pass_fds\n                    and cwd is None\n                    and (p2cread == -1 or p2cread > 2)\n                    and (c2pwrite == -1 or c2pwrite > 2)\n                    and (errwrite == -1 or errwrite > 2)\n                    and not start_new_session\n                    and process_group == -1\n                    and gid is None\n                    and gids is None\n                    and uid is None\n                    and umask < 0):\n                self._posix_spawn(args, executable, env, restore_signals,\n                                  p2cread, p2cwrite,\n                                  c2pread, c2pwrite,\n                                  errread, errwrite)\n                return\n\n            orig_executable = executable\n\n            # For transferring possible exec failure from child to parent.\n            # Data format: \"exception name:hex errno:description\"\n            # Pickle is not used; it is complex and involves memory allocation.\n            errpipe_read, errpipe_write = os.pipe()\n            # errpipe_write must not be in the standard io 0, 1, or 2 fd range.\n            low_fds_to_close = []\n            while errpipe_write < 3:\n                low_fds_to_close.append(errpipe_write)\n                errpipe_write = os.dup(errpipe_write)\n            for low_fd in low_fds_to_close:\n                os.close(low_fd)\n            try:\n                try:\n                    # We must avoid complex work that could involve\n                    # malloc or free in the child process to avoid\n                    # potential deadlocks, thus we do all this here.\n                    # and pass it to fork_exec()\n\n                    if env is not None:\n                        env_list = []\n                        for k, v in env.items():\n                            k = os.fsencode(k)\n                            if b'=' in k:\n                                raise ValueError(\"illegal environment variable name\")\n                            env_list.append(k + b'=' + os.fsencode(v))\n                    else:\n                        env_list = None  # Use execv instead of execve.\n                    executable = os.fsencode(executable)\n                    if os.path.dirname(executable):\n                        executable_list = (executable,)\n                    else:\n                        # This matches the behavior of os._execvpe().\n                        executable_list = tuple(\n                            os.path.join(os.fsencode(dir), executable)\n                            for dir in os.get_exec_path(env))\n                    fds_to_keep = set(pass_fds)\n                    fds_to_keep.add(errpipe_write)\n                    self.pid = _fork_exec(\n                            args, executable_list,\n                            close_fds, tuple(sorted(map(int, fds_to_keep))),\n                            cwd, env_list,\n                            p2cread, p2cwrite, c2pread, c2pwrite,\n                            errread, errwrite,\n                            errpipe_read, errpipe_write,\n                            restore_signals, start_new_session,\n                            process_group, gid, gids, uid, umask,\n                            preexec_fn, _USE_VFORK)\n                    self._child_created = True\n                finally:\n                    # be sure the FD is closed no matter what\n                    os.close(errpipe_write)\n\n                self._close_pipe_fds(p2cread, p2cwrite,\n                                     c2pread, c2pwrite,\n                                     errread, errwrite)\n\n                # Wait for exec to fail or succeed; possibly raising an\n                # exception (limited in size)\n                errpipe_data = bytearray()\n                while True:\n                    part = os.read(errpipe_read, 50000)\n                    errpipe_data += part\n                    if not part or len(errpipe_data) > 50000:\n                        break\n            finally:\n                # be sure the FD is closed no matter what\n                os.close(errpipe_read)\n\n            if errpipe_data:\n                try:\n                    pid, sts = os.waitpid(self.pid, 0)\n                    if pid == self.pid:\n                        self._handle_exitstatus(sts)\n                    else:\n                        self.returncode = sys.maxsize\n                except ChildProcessError:\n                    pass\n\n                try:\n                    exception_name, hex_errno, err_msg = (\n                            errpipe_data.split(b':', 2))\n                    # The encoding here should match the encoding\n                    # written in by the subprocess implementations\n                    # like _posixsubprocess\n                    err_msg = err_msg.decode()\n                except ValueError:\n                    exception_name = b'SubprocessError'\n                    hex_errno = b'0'\n                    err_msg = 'Bad exception data from child: {!r}'.format(\n                                  bytes(errpipe_data))\n                child_exception_type = getattr(\n                        builtins, exception_name.decode('ascii'),\n                        SubprocessError)\n                if issubclass(child_exception_type, OSError) and hex_errno:\n                    errno_num = int(hex_errno, 16)\n                    child_exec_never_called = (err_msg == \"noexec\")\n                    if child_exec_never_called:\n                        err_msg = \"\"\n                        # The error must be from chdir(cwd).\n                        err_filename = cwd\n                    else:\n                        err_filename = orig_executable\n                    if errno_num != 0:\n                        err_msg = os.strerror(errno_num)\n                    raise child_exception_type(errno_num, err_msg, err_filename)\n                raise child_exception_type(err_msg)\n\n\n        def _handle_exitstatus(self, sts,\n                               _waitstatus_to_exitcode=_waitstatus_to_exitcode,\n                               _WIFSTOPPED=_WIFSTOPPED,\n                               _WSTOPSIG=_WSTOPSIG):\n            \"\"\"All callers to this function MUST hold self._waitpid_lock.\"\"\"\n            # This method is called (indirectly) by __del__, so it cannot\n            # refer to anything outside of its local scope.\n            if _WIFSTOPPED(sts):\n                self.returncode = -_WSTOPSIG(sts)\n            else:\n                self.returncode = _waitstatus_to_exitcode(sts)\n\n        def _internal_poll(self, _deadstate=None, _waitpid=_waitpid,\n                _WNOHANG=_WNOHANG, _ECHILD=errno.ECHILD):\n            \"\"\"Check if child process has terminated.  Returns returncode\n            attribute.\n\n            This method is called by __del__, so it cannot reference anything\n            outside of the local scope (nor can any methods it calls).\n\n            \"\"\"\n            if self.returncode is None:\n                if not self._waitpid_lock.acquire(False):\n                    # Something else is busy calling waitpid.  Don't allow two\n                    # at once.  We know nothing yet.\n                    return None\n                try:\n                    if self.returncode is not None:\n                        return self.returncode  # Another thread waited.\n                    pid, sts = _waitpid(self.pid, _WNOHANG)\n                    if pid == self.pid:\n                        self._handle_exitstatus(sts)\n                except OSError as e:\n                    if _deadstate is not None:\n                        self.returncode = _deadstate\n                    elif e.errno == _ECHILD:\n                        # This happens if SIGCLD is set to be ignored or\n                        # waiting for child processes has otherwise been\n                        # disabled for our process.  This child is dead, we\n                        # can't get the status.\n                        # http://bugs.python.org/issue15756\n                        self.returncode = 0\n                finally:\n                    self._waitpid_lock.release()\n            return self.returncode\n\n\n        def _try_wait(self, wait_flags):\n            \"\"\"All callers to this function MUST hold self._waitpid_lock.\"\"\"\n            try:\n                (pid, sts) = os.waitpid(self.pid, wait_flags)\n            except ChildProcessError:\n                # This happens if SIGCLD is set to be ignored or waiting\n                # for child processes has otherwise been disabled for our\n                # process.  This child is dead, we can't get the status.\n                pid = self.pid\n                sts = 0\n            return (pid, sts)\n\n\n        def _wait(self, timeout):\n            \"\"\"Internal implementation of wait() on POSIX.\"\"\"\n            if self.returncode is not None:\n                return self.returncode\n\n            if timeout is not None:\n                endtime = _time() + timeout\n                # Enter a busy loop if we have a timeout.  This busy loop was\n                # cribbed from Lib/threading.py in Thread.wait() at r71065.\n                delay = 0.0005 # 500 us -> initial delay of 1 ms\n                while True:\n                    if self._waitpid_lock.acquire(False):\n                        try:\n                            if self.returncode is not None:\n                                break  # Another thread waited.\n                            (pid, sts) = self._try_wait(os.WNOHANG)\n                            assert pid == self.pid or pid == 0\n                            if pid == self.pid:\n                                self._handle_exitstatus(sts)\n                                break\n                        finally:\n                            self._waitpid_lock.release()\n                    remaining = self._remaining_time(endtime)\n                    if remaining <= 0:\n                        raise TimeoutExpired(self.args, timeout)\n                    delay = min(delay * 2, remaining, .05)\n                    time.sleep(delay)\n            else:\n                while self.returncode is None:\n                    with self._waitpid_lock:\n                        if self.returncode is not None:\n                            break  # Another thread waited.\n                        (pid, sts) = self._try_wait(0)\n                        # Check the pid and loop as waitpid has been known to\n                        # return 0 even without WNOHANG in odd situations.\n                        # http://bugs.python.org/issue14396.\n                        if pid == self.pid:\n                            self._handle_exitstatus(sts)\n            return self.returncode\n\n\n        def _communicate(self, input, endtime, orig_timeout):\n            if self.stdin and not self._communication_started:\n                # Flush stdio buffer.  This might block, if the user has\n                # been writing to .stdin in an uncontrolled fashion.\n                try:\n                    self.stdin.flush()\n                except BrokenPipeError:\n                    pass  # communicate() must ignore BrokenPipeError.\n                if not input:\n                    try:\n                        self.stdin.close()\n                    except BrokenPipeError:\n                        pass  # communicate() must ignore BrokenPipeError.\n\n            stdout = None\n            stderr = None\n\n            # Only create this mapping if we haven't already.\n            if not self._communication_started:\n                self._fileobj2output = {}\n                if self.stdout:\n                    self._fileobj2output[self.stdout] = []\n                if self.stderr:\n                    self._fileobj2output[self.stderr] = []\n\n            if self.stdout:\n                stdout = self._fileobj2output[self.stdout]\n            if self.stderr:\n                stderr = self._fileobj2output[self.stderr]\n\n            self._save_input(input)\n\n            if self._input:\n                input_view = memoryview(self._input)\n\n            with _PopenSelector() as selector:\n                if self.stdin and input:\n                    selector.register(self.stdin, selectors.EVENT_WRITE)\n                if self.stdout and not self.stdout.closed:\n                    selector.register(self.stdout, selectors.EVENT_READ)\n                if self.stderr and not self.stderr.closed:\n                    selector.register(self.stderr, selectors.EVENT_READ)\n\n                while selector.get_map():\n                    timeout = self._remaining_time(endtime)\n                    if timeout is not None and timeout < 0:\n                        self._check_timeout(endtime, orig_timeout,\n                                            stdout, stderr,\n                                            skip_check_and_raise=True)\n                        raise RuntimeError(  # Impossible :)\n                            '_check_timeout(..., skip_check_and_raise=True) '\n                            'failed to raise TimeoutExpired.')\n\n                    ready = selector.select(timeout)\n                    self._check_timeout(endtime, orig_timeout, stdout, stderr)\n\n                    # XXX Rewrite these to use non-blocking I/O on the file\n                    # objects; they are no longer using C stdio!\n\n                    for key, events in ready:\n                        if key.fileobj is self.stdin:\n                            chunk = input_view[self._input_offset :\n                                               self._input_offset + _PIPE_BUF]\n                            try:\n                                self._input_offset += os.write(key.fd, chunk)\n                            except BrokenPipeError:\n                                selector.unregister(key.fileobj)\n                                key.fileobj.close()\n                            else:\n                                if self._input_offset >= len(self._input):\n                                    selector.unregister(key.fileobj)\n                                    key.fileobj.close()\n                        elif key.fileobj in (self.stdout, self.stderr):\n                            data = os.read(key.fd, 32768)\n                            if not data:\n                                selector.unregister(key.fileobj)\n                                key.fileobj.close()\n                            self._fileobj2output[key.fileobj].append(data)\n\n            self.wait(timeout=self._remaining_time(endtime))\n\n            # All data exchanged.  Translate lists into strings.\n            if stdout is not None:\n                stdout = b''.join(stdout)\n            if stderr is not None:\n                stderr = b''.join(stderr)\n\n            # Translate newlines, if requested.\n            # This also turns bytes into strings.\n            if self.text_mode:\n                if stdout is not None:\n                    stdout = self._translate_newlines(stdout,\n                                                      self.stdout.encoding,\n                                                      self.stdout.errors)\n                if stderr is not None:\n                    stderr = self._translate_newlines(stderr,\n                                                      self.stderr.encoding,\n                                                      self.stderr.errors)\n\n            return (stdout, stderr)\n\n\n        def _save_input(self, input):\n            # This method is called from the _communicate_with_*() methods\n            # so that if we time out while communicating, we can continue\n            # sending input if we retry.\n            if self.stdin and self._input is None:\n                self._input_offset = 0\n                self._input = input\n                if input is not None and self.text_mode:\n                    self._input = self._input.encode(self.stdin.encoding,\n                                                     self.stdin.errors)\n\n\n        def send_signal(self, sig):\n            \"\"\"Send a signal to the process.\"\"\"\n            # bpo-38630: Polling reduces the risk of sending a signal to the\n            # wrong process if the process completed, the Popen.returncode\n            # attribute is still None, and the pid has been reassigned\n            # (recycled) to a new different process. This race condition can\n            # happens in two cases.\n            #\n            # Case 1. Thread A calls Popen.poll(), thread B calls\n            # Popen.send_signal(). In thread A, waitpid() succeed and returns\n            # the exit status. Thread B calls kill() because poll() in thread A\n            # did not set returncode yet. Calling poll() in thread B prevents\n            # the race condition thanks to Popen._waitpid_lock.\n            #\n            # Case 2. waitpid(pid, 0) has been called directly, without\n            # using Popen methods: returncode is still None is this case.\n            # Calling Popen.poll() will set returncode to a default value,\n            # since waitpid() fails with ProcessLookupError.\n            self.poll()\n            if self.returncode is not None:\n                # Skip signalling a process that we know has already died.\n                return\n\n            # The race condition can still happen if the race condition\n            # described above happens between the returncode test\n            # and the kill() call.\n            try:\n                os.kill(self.pid, sig)\n            except ProcessLookupError:\n                # Suppress the race condition error; bpo-40550.\n                pass\n\n        def terminate(self):\n            \"\"\"Terminate the process with SIGTERM\n            \"\"\"\n            self.send_signal(signal.SIGTERM)\n\n        def kill(self):\n            \"\"\"Kill the process with SIGKILL\n            \"\"\"\n            self.send_signal(signal.SIGKILL)\n",2158],"/home/ma-user/anaconda3/envs/py311/lib/python3.11/logging/__init__.py":["# Copyright 2001-2019 by Vinay Sajip. All Rights Reserved.\n#\n# Permission to use, copy, modify, and distribute this software and its\n# documentation for any purpose and without fee is hereby granted,\n# provided that the above copyright notice appear in all copies and that\n# both that copyright notice and this permission notice appear in\n# supporting documentation, and that the name of Vinay Sajip\n# not be used in advertising or publicity pertaining to distribution\n# of the software without specific, written prior permission.\n# VINAY SAJIP DISCLAIMS ALL WARRANTIES WITH REGARD TO THIS SOFTWARE, INCLUDING\n# ALL IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS. IN NO EVENT SHALL\n# VINAY SAJIP BE LIABLE FOR ANY SPECIAL, INDIRECT OR CONSEQUENTIAL DAMAGES OR\n# ANY DAMAGES WHATSOEVER RESULTING FROM LOSS OF USE, DATA OR PROFITS, WHETHER\n# IN AN ACTION OF CONTRACT, NEGLIGENCE OR OTHER TORTIOUS ACTION, ARISING OUT\n# OF OR IN CONNECTION WITH THE USE OR PERFORMANCE OF THIS SOFTWARE.\n\n\"\"\"\nLogging package for Python. Based on PEP 282 and comments thereto in\ncomp.lang.python.\n\nCopyright (C) 2001-2019 Vinay Sajip. All Rights Reserved.\n\nTo use, simply 'import logging' and log away!\n\"\"\"\n\nimport sys, os, time, io, re, traceback, warnings, weakref, collections.abc\n\nfrom types import GenericAlias\nfrom string import Template\nfrom string import Formatter as StrFormatter\n\n\n__all__ = ['BASIC_FORMAT', 'BufferingFormatter', 'CRITICAL', 'DEBUG', 'ERROR',\n           'FATAL', 'FileHandler', 'Filter', 'Formatter', 'Handler', 'INFO',\n           'LogRecord', 'Logger', 'LoggerAdapter', 'NOTSET', 'NullHandler',\n           'StreamHandler', 'WARN', 'WARNING', 'addLevelName', 'basicConfig',\n           'captureWarnings', 'critical', 'debug', 'disable', 'error',\n           'exception', 'fatal', 'getLevelName', 'getLogger', 'getLoggerClass',\n           'info', 'log', 'makeLogRecord', 'setLoggerClass', 'shutdown',\n           'warn', 'warning', 'getLogRecordFactory', 'setLogRecordFactory',\n           'lastResort', 'raiseExceptions', 'getLevelNamesMapping']\n\nimport threading\n\n__author__  = \"Vinay Sajip <vinay_sajip@red-dove.com>\"\n__status__  = \"production\"\n# The following module attributes are no longer updated.\n__version__ = \"0.5.1.2\"\n__date__    = \"07 February 2010\"\n\n#---------------------------------------------------------------------------\n#   Miscellaneous module data\n#---------------------------------------------------------------------------\n\n#\n#_startTime is used as the base when calculating the relative time of events\n#\n_startTime = time.time()\n\n#\n#raiseExceptions is used to see if exceptions during handling should be\n#propagated\n#\nraiseExceptions = True\n\n#\n# If you don't want threading information in the log, set this to zero\n#\nlogThreads = True\n\n#\n# If you don't want multiprocessing information in the log, set this to zero\n#\nlogMultiprocessing = True\n\n#\n# If you don't want process information in the log, set this to zero\n#\nlogProcesses = True\n\n#---------------------------------------------------------------------------\n#   Level related stuff\n#---------------------------------------------------------------------------\n#\n# Default levels and level names, these can be replaced with any positive set\n# of values having corresponding names. There is a pseudo-level, NOTSET, which\n# is only really there as a lower limit for user-defined levels. Handlers and\n# loggers are initialized with NOTSET so that they will log all messages, even\n# at user-defined levels.\n#\n\nCRITICAL = 50\nFATAL = CRITICAL\nERROR = 40\nWARNING = 30\nWARN = WARNING\nINFO = 20\nDEBUG = 10\nNOTSET = 0\n\n_levelToName = {\n    CRITICAL: 'CRITICAL',\n    ERROR: 'ERROR',\n    WARNING: 'WARNING',\n    INFO: 'INFO',\n    DEBUG: 'DEBUG',\n    NOTSET: 'NOTSET',\n}\n_nameToLevel = {\n    'CRITICAL': CRITICAL,\n    'FATAL': FATAL,\n    'ERROR': ERROR,\n    'WARN': WARNING,\n    'WARNING': WARNING,\n    'INFO': INFO,\n    'DEBUG': DEBUG,\n    'NOTSET': NOTSET,\n}\n\ndef getLevelNamesMapping():\n    return _nameToLevel.copy()\n\ndef getLevelName(level):\n    \"\"\"\n    Return the textual or numeric representation of logging level 'level'.\n\n    If the level is one of the predefined levels (CRITICAL, ERROR, WARNING,\n    INFO, DEBUG) then you get the corresponding string. If you have\n    associated levels with names using addLevelName then the name you have\n    associated with 'level' is returned.\n\n    If a numeric value corresponding to one of the defined levels is passed\n    in, the corresponding string representation is returned.\n\n    If a string representation of the level is passed in, the corresponding\n    numeric value is returned.\n\n    If no matching numeric or string value is passed in, the string\n    'Level %s' % level is returned.\n    \"\"\"\n    # See Issues #22386, #27937 and #29220 for why it's this way\n    result = _levelToName.get(level)\n    if result is not None:\n        return result\n    result = _nameToLevel.get(level)\n    if result is not None:\n        return result\n    return \"Level %s\" % level\n\ndef addLevelName(level, levelName):\n    \"\"\"\n    Associate 'levelName' with 'level'.\n\n    This is used when converting levels to text during message formatting.\n    \"\"\"\n    _acquireLock()\n    try:    #unlikely to cause an exception, but you never know...\n        _levelToName[level] = levelName\n        _nameToLevel[levelName] = level\n    finally:\n        _releaseLock()\n\nif hasattr(sys, \"_getframe\"):\n    currentframe = lambda: sys._getframe(1)\nelse: #pragma: no cover\n    def currentframe():\n        \"\"\"Return the frame object for the caller's stack frame.\"\"\"\n        try:\n            raise Exception\n        except Exception:\n            return sys.exc_info()[2].tb_frame.f_back\n\n#\n# _srcfile is used when walking the stack to check when we've got the first\n# caller stack frame, by skipping frames whose filename is that of this\n# module's source. It therefore should contain the filename of this module's\n# source file.\n#\n# Ordinarily we would use __file__ for this, but frozen modules don't always\n# have __file__ set, for some reason (see Issue #21736). Thus, we get the\n# filename from a handy code object from a function defined in this module.\n# (There's no particular reason for picking addLevelName.)\n#\n\n_srcfile = os.path.normcase(addLevelName.__code__.co_filename)\n\n# _srcfile is only used in conjunction with sys._getframe().\n# Setting _srcfile to None will prevent findCaller() from being called. This\n# way, you can avoid the overhead of fetching caller information.\n\n# The following is based on warnings._is_internal_frame. It makes sure that\n# frames of the import mechanism are skipped when logging at module level and\n# using a stacklevel value greater than one.\ndef _is_internal_frame(frame):\n    \"\"\"Signal whether the frame is a CPython or logging module internal.\"\"\"\n    filename = os.path.normcase(frame.f_code.co_filename)\n    return filename == _srcfile or (\n        \"importlib\" in filename and \"_bootstrap\" in filename\n    )\n\n\ndef _checkLevel(level):\n    if isinstance(level, int):\n        rv = level\n    elif str(level) == level:\n        if level not in _nameToLevel:\n            raise ValueError(\"Unknown level: %r\" % level)\n        rv = _nameToLevel[level]\n    else:\n        raise TypeError(\"Level not an integer or a valid string: %r\"\n                        % (level,))\n    return rv\n\n#---------------------------------------------------------------------------\n#   Thread-related stuff\n#---------------------------------------------------------------------------\n\n#\n#_lock is used to serialize access to shared data structures in this module.\n#This needs to be an RLock because fileConfig() creates and configures\n#Handlers, and so might arbitrary user threads. Since Handler code updates the\n#shared dictionary _handlers, it needs to acquire the lock. But if configuring,\n#the lock would already have been acquired - so we need an RLock.\n#The same argument applies to Loggers and Manager.loggerDict.\n#\n_lock = threading.RLock()\n\ndef _acquireLock():\n    \"\"\"\n    Acquire the module-level lock for serializing access to shared data.\n\n    This should be released with _releaseLock().\n    \"\"\"\n    if _lock:\n        _lock.acquire()\n\ndef _releaseLock():\n    \"\"\"\n    Release the module-level lock acquired by calling _acquireLock().\n    \"\"\"\n    if _lock:\n        _lock.release()\n\n\n# Prevent a held logging lock from blocking a child from logging.\n\nif not hasattr(os, 'register_at_fork'):  # Windows and friends.\n    def _register_at_fork_reinit_lock(instance):\n        pass  # no-op when os.register_at_fork does not exist.\nelse:\n    # A collection of instances with a _at_fork_reinit method (logging.Handler)\n    # to be called in the child after forking.  The weakref avoids us keeping\n    # discarded Handler instances alive.\n    _at_fork_reinit_lock_weakset = weakref.WeakSet()\n\n    def _register_at_fork_reinit_lock(instance):\n        _acquireLock()\n        try:\n            _at_fork_reinit_lock_weakset.add(instance)\n        finally:\n            _releaseLock()\n\n    def _after_at_fork_child_reinit_locks():\n        for handler in _at_fork_reinit_lock_weakset:\n            handler._at_fork_reinit()\n\n        # _acquireLock() was called in the parent before forking.\n        # The lock is reinitialized to unlocked state.\n        _lock._at_fork_reinit()\n\n    os.register_at_fork(before=_acquireLock,\n                        after_in_child=_after_at_fork_child_reinit_locks,\n                        after_in_parent=_releaseLock)\n\n\n#---------------------------------------------------------------------------\n#   The logging record\n#---------------------------------------------------------------------------\n\nclass LogRecord(object):\n    \"\"\"\n    A LogRecord instance represents an event being logged.\n\n    LogRecord instances are created every time something is logged. They\n    contain all the information pertinent to the event being logged. The\n    main information passed in is in msg and args, which are combined\n    using str(msg) % args to create the message field of the record. The\n    record also includes information such as when the record was created,\n    the source line where the logging call was made, and any exception\n    information to be logged.\n    \"\"\"\n    def __init__(self, name, level, pathname, lineno,\n                 msg, args, exc_info, func=None, sinfo=None, **kwargs):\n        \"\"\"\n        Initialize a logging record with interesting information.\n        \"\"\"\n        ct = time.time()\n        self.name = name\n        self.msg = msg\n        #\n        # The following statement allows passing of a dictionary as a sole\n        # argument, so that you can do something like\n        #  logging.debug(\"a %(a)d b %(b)s\", {'a':1, 'b':2})\n        # Suggested by Stefan Behnel.\n        # Note that without the test for args[0], we get a problem because\n        # during formatting, we test to see if the arg is present using\n        # 'if self.args:'. If the event being logged is e.g. 'Value is %d'\n        # and if the passed arg fails 'if self.args:' then no formatting\n        # is done. For example, logger.warning('Value is %d', 0) would log\n        # 'Value is %d' instead of 'Value is 0'.\n        # For the use case of passing a dictionary, this should not be a\n        # problem.\n        # Issue #21172: a request was made to relax the isinstance check\n        # to hasattr(args[0], '__getitem__'). However, the docs on string\n        # formatting still seem to suggest a mapping object is required.\n        # Thus, while not removing the isinstance check, it does now look\n        # for collections.abc.Mapping rather than, as before, dict.\n        if (args and len(args) == 1 and isinstance(args[0], collections.abc.Mapping)\n            and args[0]):\n            args = args[0]\n        self.args = args\n        self.levelname = getLevelName(level)\n        self.levelno = level\n        self.pathname = pathname\n        try:\n            self.filename = os.path.basename(pathname)\n            self.module = os.path.splitext(self.filename)[0]\n        except (TypeError, ValueError, AttributeError):\n            self.filename = pathname\n            self.module = \"Unknown module\"\n        self.exc_info = exc_info\n        self.exc_text = None      # used to cache the traceback text\n        self.stack_info = sinfo\n        self.lineno = lineno\n        self.funcName = func\n        self.created = ct\n        self.msecs = int((ct - int(ct)) * 1000) + 0.0  # see gh-89047\n        self.relativeCreated = (self.created - _startTime) * 1000\n        if logThreads:\n            self.thread = threading.get_ident()\n            self.threadName = threading.current_thread().name\n        else: # pragma: no cover\n            self.thread = None\n            self.threadName = None\n        if not logMultiprocessing: # pragma: no cover\n            self.processName = None\n        else:\n            self.processName = 'MainProcess'\n            mp = sys.modules.get('multiprocessing')\n            if mp is not None:\n                # Errors may occur if multiprocessing has not finished loading\n                # yet - e.g. if a custom import hook causes third-party code\n                # to run when multiprocessing calls import. See issue 8200\n                # for an example\n                try:\n                    self.processName = mp.current_process().name\n                except Exception: #pragma: no cover\n                    pass\n        if logProcesses and hasattr(os, 'getpid'):\n            self.process = os.getpid()\n        else:\n            self.process = None\n\n    def __repr__(self):\n        return '<LogRecord: %s, %s, %s, %s, \"%s\">'%(self.name, self.levelno,\n            self.pathname, self.lineno, self.msg)\n\n    def getMessage(self):\n        \"\"\"\n        Return the message for this LogRecord.\n\n        Return the message for this LogRecord after merging any user-supplied\n        arguments with the message.\n        \"\"\"\n        msg = str(self.msg)\n        if self.args:\n            msg = msg % self.args\n        return msg\n\n#\n#   Determine which class to use when instantiating log records.\n#\n_logRecordFactory = LogRecord\n\ndef setLogRecordFactory(factory):\n    \"\"\"\n    Set the factory to be used when instantiating a log record.\n\n    :param factory: A callable which will be called to instantiate\n    a log record.\n    \"\"\"\n    global _logRecordFactory\n    _logRecordFactory = factory\n\ndef getLogRecordFactory():\n    \"\"\"\n    Return the factory to be used when instantiating a log record.\n    \"\"\"\n\n    return _logRecordFactory\n\ndef makeLogRecord(dict):\n    \"\"\"\n    Make a LogRecord whose attributes are defined by the specified dictionary,\n    This function is useful for converting a logging event received over\n    a socket connection (which is sent as a dictionary) into a LogRecord\n    instance.\n    \"\"\"\n    rv = _logRecordFactory(None, None, \"\", 0, \"\", (), None, None)\n    rv.__dict__.update(dict)\n    return rv\n\n\n#---------------------------------------------------------------------------\n#   Formatter classes and functions\n#---------------------------------------------------------------------------\n_str_formatter = StrFormatter()\ndel StrFormatter\n\n\nclass PercentStyle(object):\n\n    default_format = '%(message)s'\n    asctime_format = '%(asctime)s'\n    asctime_search = '%(asctime)'\n    validation_pattern = re.compile(r'%\\(\\w+\\)[#0+ -]*(\\*|\\d+)?(\\.(\\*|\\d+))?[diouxefgcrsa%]', re.I)\n\n    def __init__(self, fmt, *, defaults=None):\n        self._fmt = fmt or self.default_format\n        self._defaults = defaults\n\n    def usesTime(self):\n        return self._fmt.find(self.asctime_search) >= 0\n\n    def validate(self):\n        \"\"\"Validate the input format, ensure it matches the correct style\"\"\"\n        if not self.validation_pattern.search(self._fmt):\n            raise ValueError(\"Invalid format '%s' for '%s' style\" % (self._fmt, self.default_format[0]))\n\n    def _format(self, record):\n        if defaults := self._defaults:\n            values = defaults | record.__dict__\n        else:\n            values = record.__dict__\n        return self._fmt % values\n\n    def format(self, record):\n        try:\n            return self._format(record)\n        except KeyError as e:\n            raise ValueError('Formatting field not found in record: %s' % e)\n\n\nclass StrFormatStyle(PercentStyle):\n    default_format = '{message}'\n    asctime_format = '{asctime}'\n    asctime_search = '{asctime'\n\n    fmt_spec = re.compile(r'^(.?[<>=^])?[+ -]?#?0?(\\d+|{\\w+})?[,_]?(\\.(\\d+|{\\w+}))?[bcdefgnosx%]?$', re.I)\n    field_spec = re.compile(r'^(\\d+|\\w+)(\\.\\w+|\\[[^]]+\\])*$')\n\n    def _format(self, record):\n        if defaults := self._defaults:\n            values = defaults | record.__dict__\n        else:\n            values = record.__dict__\n        return self._fmt.format(**values)\n\n    def validate(self):\n        \"\"\"Validate the input format, ensure it is the correct string formatting style\"\"\"\n        fields = set()\n        try:\n            for _, fieldname, spec, conversion in _str_formatter.parse(self._fmt):\n                if fieldname:\n                    if not self.field_spec.match(fieldname):\n                        raise ValueError('invalid field name/expression: %r' % fieldname)\n                    fields.add(fieldname)\n                if conversion and conversion not in 'rsa':\n                    raise ValueError('invalid conversion: %r' % conversion)\n                if spec and not self.fmt_spec.match(spec):\n                    raise ValueError('bad specifier: %r' % spec)\n        except ValueError as e:\n            raise ValueError('invalid format: %s' % e)\n        if not fields:\n            raise ValueError('invalid format: no fields')\n\n\nclass StringTemplateStyle(PercentStyle):\n    default_format = '${message}'\n    asctime_format = '${asctime}'\n    asctime_search = '${asctime}'\n\n    def __init__(self, *args, **kwargs):\n        super().__init__(*args, **kwargs)\n        self._tpl = Template(self._fmt)\n\n    def usesTime(self):\n        fmt = self._fmt\n        return fmt.find('$asctime') >= 0 or fmt.find(self.asctime_format) >= 0\n\n    def validate(self):\n        pattern = Template.pattern\n        fields = set()\n        for m in pattern.finditer(self._fmt):\n            d = m.groupdict()\n            if d['named']:\n                fields.add(d['named'])\n            elif d['braced']:\n                fields.add(d['braced'])\n            elif m.group(0) == '$':\n                raise ValueError('invalid format: bare \\'$\\' not allowed')\n        if not fields:\n            raise ValueError('invalid format: no fields')\n\n    def _format(self, record):\n        if defaults := self._defaults:\n            values = defaults | record.__dict__\n        else:\n            values = record.__dict__\n        return self._tpl.substitute(**values)\n\n\nBASIC_FORMAT = \"%(levelname)s:%(name)s:%(message)s\"\n\n_STYLES = {\n    '%': (PercentStyle, BASIC_FORMAT),\n    '{': (StrFormatStyle, '{levelname}:{name}:{message}'),\n    '$': (StringTemplateStyle, '${levelname}:${name}:${message}'),\n}\n\nclass Formatter(object):\n    \"\"\"\n    Formatter instances are used to convert a LogRecord to text.\n\n    Formatters need to know how a LogRecord is constructed. They are\n    responsible for converting a LogRecord to (usually) a string which can\n    be interpreted by either a human or an external system. The base Formatter\n    allows a formatting string to be specified. If none is supplied, the\n    style-dependent default value, \"%(message)s\", \"{message}\", or\n    \"${message}\", is used.\n\n    The Formatter can be initialized with a format string which makes use of\n    knowledge of the LogRecord attributes - e.g. the default value mentioned\n    above makes use of the fact that the user's message and arguments are pre-\n    formatted into a LogRecord's message attribute. Currently, the useful\n    attributes in a LogRecord are described by:\n\n    %(name)s            Name of the logger (logging channel)\n    %(levelno)s         Numeric logging level for the message (DEBUG, INFO,\n                        WARNING, ERROR, CRITICAL)\n    %(levelname)s       Text logging level for the message (\"DEBUG\", \"INFO\",\n                        \"WARNING\", \"ERROR\", \"CRITICAL\")\n    %(pathname)s        Full pathname of the source file where the logging\n                        call was issued (if available)\n    %(filename)s        Filename portion of pathname\n    %(module)s          Module (name portion of filename)\n    %(lineno)d          Source line number where the logging call was issued\n                        (if available)\n    %(funcName)s        Function name\n    %(created)f         Time when the LogRecord was created (time.time()\n                        return value)\n    %(asctime)s         Textual time when the LogRecord was created\n    %(msecs)d           Millisecond portion of the creation time\n    %(relativeCreated)d Time in milliseconds when the LogRecord was created,\n                        relative to the time the logging module was loaded\n                        (typically at application startup time)\n    %(thread)d          Thread ID (if available)\n    %(threadName)s      Thread name (if available)\n    %(process)d         Process ID (if available)\n    %(message)s         The result of record.getMessage(), computed just as\n                        the record is emitted\n    \"\"\"\n\n    converter = time.localtime\n\n    def __init__(self, fmt=None, datefmt=None, style='%', validate=True, *,\n                 defaults=None):\n        \"\"\"\n        Initialize the formatter with specified format strings.\n\n        Initialize the formatter either with the specified format string, or a\n        default as described above. Allow for specialized date formatting with\n        the optional datefmt argument. If datefmt is omitted, you get an\n        ISO8601-like (or RFC 3339-like) format.\n\n        Use a style parameter of '%', '{' or '$' to specify that you want to\n        use one of %-formatting, :meth:`str.format` (``{}``) formatting or\n        :class:`string.Template` formatting in your format string.\n\n        .. versionchanged:: 3.2\n           Added the ``style`` parameter.\n        \"\"\"\n        if style not in _STYLES:\n            raise ValueError('Style must be one of: %s' % ','.join(\n                             _STYLES.keys()))\n        self._style = _STYLES[style][0](fmt, defaults=defaults)\n        if validate:\n            self._style.validate()\n\n        self._fmt = self._style._fmt\n        self.datefmt = datefmt\n\n    default_time_format = '%Y-%m-%d %H:%M:%S'\n    default_msec_format = '%s,%03d'\n\n    def formatTime(self, record, datefmt=None):\n        \"\"\"\n        Return the creation time of the specified LogRecord as formatted text.\n\n        This method should be called from format() by a formatter which\n        wants to make use of a formatted time. This method can be overridden\n        in formatters to provide for any specific requirement, but the\n        basic behaviour is as follows: if datefmt (a string) is specified,\n        it is used with time.strftime() to format the creation time of the\n        record. Otherwise, an ISO8601-like (or RFC 3339-like) format is used.\n        The resulting string is returned. This function uses a user-configurable\n        function to convert the creation time to a tuple. By default,\n        time.localtime() is used; to change this for a particular formatter\n        instance, set the 'converter' attribute to a function with the same\n        signature as time.localtime() or time.gmtime(). To change it for all\n        formatters, for example if you want all logging times to be shown in GMT,\n        set the 'converter' attribute in the Formatter class.\n        \"\"\"\n        ct = self.converter(record.created)\n        if datefmt:\n            s = time.strftime(datefmt, ct)\n        else:\n            s = time.strftime(self.default_time_format, ct)\n            if self.default_msec_format:\n                s = self.default_msec_format % (s, record.msecs)\n        return s\n\n    def formatException(self, ei):\n        \"\"\"\n        Format and return the specified exception information as a string.\n\n        This default implementation just uses\n        traceback.print_exception()\n        \"\"\"\n        sio = io.StringIO()\n        tb = ei[2]\n        # See issues #9427, #1553375. Commented out for now.\n        #if getattr(self, 'fullstack', False):\n        #    traceback.print_stack(tb.tb_frame.f_back, file=sio)\n        traceback.print_exception(ei[0], ei[1], tb, None, sio)\n        s = sio.getvalue()\n        sio.close()\n        if s[-1:] == \"\\n\":\n            s = s[:-1]\n        return s\n\n    def usesTime(self):\n        \"\"\"\n        Check if the format uses the creation time of the record.\n        \"\"\"\n        return self._style.usesTime()\n\n    def formatMessage(self, record):\n        return self._style.format(record)\n\n    def formatStack(self, stack_info):\n        \"\"\"\n        This method is provided as an extension point for specialized\n        formatting of stack information.\n\n        The input data is a string as returned from a call to\n        :func:`traceback.print_stack`, but with the last trailing newline\n        removed.\n\n        The base implementation just returns the value passed in.\n        \"\"\"\n        return stack_info\n\n    def format(self, record):\n        \"\"\"\n        Format the specified record as text.\n\n        The record's attribute dictionary is used as the operand to a\n        string formatting operation which yields the returned string.\n        Before formatting the dictionary, a couple of preparatory steps\n        are carried out. The message attribute of the record is computed\n        using LogRecord.getMessage(). If the formatting string uses the\n        time (as determined by a call to usesTime(), formatTime() is\n        called to format the event time. If there is exception information,\n        it is formatted using formatException() and appended to the message.\n        \"\"\"\n        record.message = record.getMessage()\n        if self.usesTime():\n            record.asctime = self.formatTime(record, self.datefmt)\n        s = self.formatMessage(record)\n        if record.exc_info:\n            # Cache the traceback text to avoid converting it multiple times\n            # (it's constant anyway)\n            if not record.exc_text:\n                record.exc_text = self.formatException(record.exc_info)\n        if record.exc_text:\n            if s[-1:] != \"\\n\":\n                s = s + \"\\n\"\n            s = s + record.exc_text\n        if record.stack_info:\n            if s[-1:] != \"\\n\":\n                s = s + \"\\n\"\n            s = s + self.formatStack(record.stack_info)\n        return s\n\n#\n#   The default formatter to use when no other is specified\n#\n_defaultFormatter = Formatter()\n\nclass BufferingFormatter(object):\n    \"\"\"\n    A formatter suitable for formatting a number of records.\n    \"\"\"\n    def __init__(self, linefmt=None):\n        \"\"\"\n        Optionally specify a formatter which will be used to format each\n        individual record.\n        \"\"\"\n        if linefmt:\n            self.linefmt = linefmt\n        else:\n            self.linefmt = _defaultFormatter\n\n    def formatHeader(self, records):\n        \"\"\"\n        Return the header string for the specified records.\n        \"\"\"\n        return \"\"\n\n    def formatFooter(self, records):\n        \"\"\"\n        Return the footer string for the specified records.\n        \"\"\"\n        return \"\"\n\n    def format(self, records):\n        \"\"\"\n        Format the specified records and return the result as a string.\n        \"\"\"\n        rv = \"\"\n        if len(records) > 0:\n            rv = rv + self.formatHeader(records)\n            for record in records:\n                rv = rv + self.linefmt.format(record)\n            rv = rv + self.formatFooter(records)\n        return rv\n\n#---------------------------------------------------------------------------\n#   Filter classes and functions\n#---------------------------------------------------------------------------\n\nclass Filter(object):\n    \"\"\"\n    Filter instances are used to perform arbitrary filtering of LogRecords.\n\n    Loggers and Handlers can optionally use Filter instances to filter\n    records as desired. The base filter class only allows events which are\n    below a certain point in the logger hierarchy. For example, a filter\n    initialized with \"A.B\" will allow events logged by loggers \"A.B\",\n    \"A.B.C\", \"A.B.C.D\", \"A.B.D\" etc. but not \"A.BB\", \"B.A.B\" etc. If\n    initialized with the empty string, all events are passed.\n    \"\"\"\n    def __init__(self, name=''):\n        \"\"\"\n        Initialize a filter.\n\n        Initialize with the name of the logger which, together with its\n        children, will have its events allowed through the filter. If no\n        name is specified, allow every event.\n        \"\"\"\n        self.name = name\n        self.nlen = len(name)\n\n    def filter(self, record):\n        \"\"\"\n        Determine if the specified record is to be logged.\n\n        Returns True if the record should be logged, or False otherwise.\n        If deemed appropriate, the record may be modified in-place.\n        \"\"\"\n        if self.nlen == 0:\n            return True\n        elif self.name == record.name:\n            return True\n        elif record.name.find(self.name, 0, self.nlen) != 0:\n            return False\n        return (record.name[self.nlen] == \".\")\n\nclass Filterer(object):\n    \"\"\"\n    A base class for loggers and handlers which allows them to share\n    common code.\n    \"\"\"\n    def __init__(self):\n        \"\"\"\n        Initialize the list of filters to be an empty list.\n        \"\"\"\n        self.filters = []\n\n    def addFilter(self, filter):\n        \"\"\"\n        Add the specified filter to this handler.\n        \"\"\"\n        if not (filter in self.filters):\n            self.filters.append(filter)\n\n    def removeFilter(self, filter):\n        \"\"\"\n        Remove the specified filter from this handler.\n        \"\"\"\n        if filter in self.filters:\n            self.filters.remove(filter)\n\n    def filter(self, record):\n        \"\"\"\n        Determine if a record is loggable by consulting all the filters.\n\n        The default is to allow the record to be logged; any filter can veto\n        this and the record is then dropped. Returns a zero value if a record\n        is to be dropped, else non-zero.\n\n        .. versionchanged:: 3.2\n\n           Allow filters to be just callables.\n        \"\"\"\n        rv = True\n        for f in self.filters:\n            if hasattr(f, 'filter'):\n                result = f.filter(record)\n            else:\n                result = f(record) # assume callable - will raise if not\n            if not result:\n                rv = False\n                break\n        return rv\n\n#---------------------------------------------------------------------------\n#   Handler classes and functions\n#---------------------------------------------------------------------------\n\n_handlers = weakref.WeakValueDictionary()  #map of handler names to handlers\n_handlerList = [] # added to allow handlers to be removed in reverse of order initialized\n\ndef _removeHandlerRef(wr):\n    \"\"\"\n    Remove a handler reference from the internal cleanup list.\n    \"\"\"\n    # This function can be called during module teardown, when globals are\n    # set to None. It can also be called from another thread. So we need to\n    # pre-emptively grab the necessary globals and check if they're None,\n    # to prevent race conditions and failures during interpreter shutdown.\n    acquire, release, handlers = _acquireLock, _releaseLock, _handlerList\n    if acquire and release and handlers:\n        acquire()\n        try:\n            handlers.remove(wr)\n        except ValueError:\n            pass\n        finally:\n            release()\n\ndef _addHandlerRef(handler):\n    \"\"\"\n    Add a handler to the internal cleanup list using a weak reference.\n    \"\"\"\n    _acquireLock()\n    try:\n        _handlerList.append(weakref.ref(handler, _removeHandlerRef))\n    finally:\n        _releaseLock()\n\nclass Handler(Filterer):\n    \"\"\"\n    Handler instances dispatch logging events to specific destinations.\n\n    The base handler class. Acts as a placeholder which defines the Handler\n    interface. Handlers can optionally use Formatter instances to format\n    records as desired. By default, no formatter is specified; in this case,\n    the 'raw' message as determined by record.message is logged.\n    \"\"\"\n    def __init__(self, level=NOTSET):\n        \"\"\"\n        Initializes the instance - basically setting the formatter to None\n        and the filter list to empty.\n        \"\"\"\n        Filterer.__init__(self)\n        self._name = None\n        self.level = _checkLevel(level)\n        self.formatter = None\n        self._closed = False\n        # Add the handler to the global _handlerList (for cleanup on shutdown)\n        _addHandlerRef(self)\n        self.createLock()\n\n    def get_name(self):\n        return self._name\n\n    def set_name(self, name):\n        _acquireLock()\n        try:\n            if self._name in _handlers:\n                del _handlers[self._name]\n            self._name = name\n            if name:\n                _handlers[name] = self\n        finally:\n            _releaseLock()\n\n    name = property(get_name, set_name)\n\n    def createLock(self):\n        \"\"\"\n        Acquire a thread lock for serializing access to the underlying I/O.\n        \"\"\"\n        self.lock = threading.RLock()\n        _register_at_fork_reinit_lock(self)\n\n    def _at_fork_reinit(self):\n        self.lock._at_fork_reinit()\n\n    def acquire(self):\n        \"\"\"\n        Acquire the I/O thread lock.\n        \"\"\"\n        if self.lock:\n            self.lock.acquire()\n\n    def release(self):\n        \"\"\"\n        Release the I/O thread lock.\n        \"\"\"\n        if self.lock:\n            self.lock.release()\n\n    def setLevel(self, level):\n        \"\"\"\n        Set the logging level of this handler.  level must be an int or a str.\n        \"\"\"\n        self.level = _checkLevel(level)\n\n    def format(self, record):\n        \"\"\"\n        Format the specified record.\n\n        If a formatter is set, use it. Otherwise, use the default formatter\n        for the module.\n        \"\"\"\n        if self.formatter:\n            fmt = self.formatter\n        else:\n            fmt = _defaultFormatter\n        return fmt.format(record)\n\n    def emit(self, record):\n        \"\"\"\n        Do whatever it takes to actually log the specified logging record.\n\n        This version is intended to be implemented by subclasses and so\n        raises a NotImplementedError.\n        \"\"\"\n        raise NotImplementedError('emit must be implemented '\n                                  'by Handler subclasses')\n\n    def handle(self, record):\n        \"\"\"\n        Conditionally emit the specified logging record.\n\n        Emission depends on filters which may have been added to the handler.\n        Wrap the actual emission of the record with acquisition/release of\n        the I/O thread lock. Returns whether the filter passed the record for\n        emission.\n        \"\"\"\n        rv = self.filter(record)\n        if rv:\n            self.acquire()\n            try:\n                self.emit(record)\n            finally:\n                self.release()\n        return rv\n\n    def setFormatter(self, fmt):\n        \"\"\"\n        Set the formatter for this handler.\n        \"\"\"\n        self.formatter = fmt\n\n    def flush(self):\n        \"\"\"\n        Ensure all logging output has been flushed.\n\n        This version does nothing and is intended to be implemented by\n        subclasses.\n        \"\"\"\n        pass\n\n    def close(self):\n        \"\"\"\n        Tidy up any resources used by the handler.\n\n        This version removes the handler from an internal map of handlers,\n        _handlers, which is used for handler lookup by name. Subclasses\n        should ensure that this gets called from overridden close()\n        methods.\n        \"\"\"\n        #get the module data lock, as we're updating a shared structure.\n        _acquireLock()\n        try:    #unlikely to raise an exception, but you never know...\n            self._closed = True\n            if self._name and self._name in _handlers:\n                del _handlers[self._name]\n        finally:\n            _releaseLock()\n\n    def handleError(self, record):\n        \"\"\"\n        Handle errors which occur during an emit() call.\n\n        This method should be called from handlers when an exception is\n        encountered during an emit() call. If raiseExceptions is false,\n        exceptions get silently ignored. This is what is mostly wanted\n        for a logging system - most users will not care about errors in\n        the logging system, they are more interested in application errors.\n        You could, however, replace this with a custom handler if you wish.\n        The record which was being processed is passed in to this method.\n        \"\"\"\n        if raiseExceptions and sys.stderr:  # see issue 13807\n            t, v, tb = sys.exc_info()\n            try:\n                sys.stderr.write('--- Logging error ---\\n')\n                traceback.print_exception(t, v, tb, None, sys.stderr)\n                sys.stderr.write('Call stack:\\n')\n                # Walk the stack frame up until we're out of logging,\n                # so as to print the calling context.\n                frame = tb.tb_frame\n                while (frame and os.path.dirname(frame.f_code.co_filename) ==\n                       __path__[0]):\n                    frame = frame.f_back\n                if frame:\n                    traceback.print_stack(frame, file=sys.stderr)\n                else:\n                    # couldn't find the right stack frame, for some reason\n                    sys.stderr.write('Logged from file %s, line %s\\n' % (\n                                     record.filename, record.lineno))\n                # Issue 18671: output logging message and arguments\n                try:\n                    sys.stderr.write('Message: %r\\n'\n                                     'Arguments: %s\\n' % (record.msg,\n                                                          record.args))\n                except RecursionError:  # See issue 36272\n                    raise\n                except Exception:\n                    sys.stderr.write('Unable to print the message and arguments'\n                                     ' - possible formatting error.\\nUse the'\n                                     ' traceback above to help find the error.\\n'\n                                    )\n            except OSError: #pragma: no cover\n                pass    # see issue 5971\n            finally:\n                del t, v, tb\n\n    def __repr__(self):\n        level = getLevelName(self.level)\n        return '<%s (%s)>' % (self.__class__.__name__, level)\n\nclass StreamHandler(Handler):\n    \"\"\"\n    A handler class which writes logging records, appropriately formatted,\n    to a stream. Note that this class does not close the stream, as\n    sys.stdout or sys.stderr may be used.\n    \"\"\"\n\n    terminator = '\\n'\n\n    def __init__(self, stream=None):\n        \"\"\"\n        Initialize the handler.\n\n        If stream is not specified, sys.stderr is used.\n        \"\"\"\n        Handler.__init__(self)\n        if stream is None:\n            stream = sys.stderr\n        self.stream = stream\n\n    def flush(self):\n        \"\"\"\n        Flushes the stream.\n        \"\"\"\n        self.acquire()\n        try:\n            if self.stream and hasattr(self.stream, \"flush\"):\n                self.stream.flush()\n        finally:\n            self.release()\n\n    def emit(self, record):\n        \"\"\"\n        Emit a record.\n\n        If a formatter is specified, it is used to format the record.\n        The record is then written to the stream with a trailing newline.  If\n        exception information is present, it is formatted using\n        traceback.print_exception and appended to the stream.  If the stream\n        has an 'encoding' attribute, it is used to determine how to do the\n        output to the stream.\n        \"\"\"\n        try:\n            msg = self.format(record)\n            stream = self.stream\n            # issue 35046: merged two stream.writes into one.\n            stream.write(msg + self.terminator)\n            self.flush()\n        except RecursionError:  # See issue 36272\n            raise\n        except Exception:\n            self.handleError(record)\n\n    def setStream(self, stream):\n        \"\"\"\n        Sets the StreamHandler's stream to the specified value,\n        if it is different.\n\n        Returns the old stream, if the stream was changed, or None\n        if it wasn't.\n        \"\"\"\n        if stream is self.stream:\n            result = None\n        else:\n            result = self.stream\n            self.acquire()\n            try:\n                self.flush()\n                self.stream = stream\n            finally:\n                self.release()\n        return result\n\n    def __repr__(self):\n        level = getLevelName(self.level)\n        name = getattr(self.stream, 'name', '')\n        #  bpo-36015: name can be an int\n        name = str(name)\n        if name:\n            name += ' '\n        return '<%s %s(%s)>' % (self.__class__.__name__, name, level)\n\n    __class_getitem__ = classmethod(GenericAlias)\n\n\nclass FileHandler(StreamHandler):\n    \"\"\"\n    A handler class which writes formatted logging records to disk files.\n    \"\"\"\n    def __init__(self, filename, mode='a', encoding=None, delay=False, errors=None):\n        \"\"\"\n        Open the specified file and use it as the stream for logging.\n        \"\"\"\n        # Issue #27493: add support for Path objects to be passed in\n        filename = os.fspath(filename)\n        #keep the absolute path, otherwise derived classes which use this\n        #may come a cropper when the current directory changes\n        self.baseFilename = os.path.abspath(filename)\n        self.mode = mode\n        self.encoding = encoding\n        if \"b\" not in mode:\n            self.encoding = io.text_encoding(encoding)\n        self.errors = errors\n        self.delay = delay\n        # bpo-26789: FileHandler keeps a reference to the builtin open()\n        # function to be able to open or reopen the file during Python\n        # finalization.\n        self._builtin_open = open\n        if delay:\n            #We don't open the stream, but we still need to call the\n            #Handler constructor to set level, formatter, lock etc.\n            Handler.__init__(self)\n            self.stream = None\n        else:\n            StreamHandler.__init__(self, self._open())\n\n    def close(self):\n        \"\"\"\n        Closes the stream.\n        \"\"\"\n        self.acquire()\n        try:\n            try:\n                if self.stream:\n                    try:\n                        self.flush()\n                    finally:\n                        stream = self.stream\n                        self.stream = None\n                        if hasattr(stream, \"close\"):\n                            stream.close()\n            finally:\n                # Issue #19523: call unconditionally to\n                # prevent a handler leak when delay is set\n                # Also see Issue #42378: we also rely on\n                # self._closed being set to True there\n                StreamHandler.close(self)\n        finally:\n            self.release()\n\n    def _open(self):\n        \"\"\"\n        Open the current base file with the (original) mode and encoding.\n        Return the resulting stream.\n        \"\"\"\n        open_func = self._builtin_open\n        return open_func(self.baseFilename, self.mode,\n                         encoding=self.encoding, errors=self.errors)\n\n    def emit(self, record):\n        \"\"\"\n        Emit a record.\n\n        If the stream was not opened because 'delay' was specified in the\n        constructor, open it before calling the superclass's emit.\n\n        If stream is not open, current mode is 'w' and `_closed=True`, record\n        will not be emitted (see Issue #42378).\n        \"\"\"\n        if self.stream is None:\n            if self.mode != 'w' or not self._closed:\n                self.stream = self._open()\n        if self.stream:\n            StreamHandler.emit(self, record)\n\n    def __repr__(self):\n        level = getLevelName(self.level)\n        return '<%s %s (%s)>' % (self.__class__.__name__, self.baseFilename, level)\n\n\nclass _StderrHandler(StreamHandler):\n    \"\"\"\n    This class is like a StreamHandler using sys.stderr, but always uses\n    whatever sys.stderr is currently set to rather than the value of\n    sys.stderr at handler construction time.\n    \"\"\"\n    def __init__(self, level=NOTSET):\n        \"\"\"\n        Initialize the handler.\n        \"\"\"\n        Handler.__init__(self, level)\n\n    @property\n    def stream(self):\n        return sys.stderr\n\n\n_defaultLastResort = _StderrHandler(WARNING)\nlastResort = _defaultLastResort\n\n#---------------------------------------------------------------------------\n#   Manager classes and functions\n#---------------------------------------------------------------------------\n\nclass PlaceHolder(object):\n    \"\"\"\n    PlaceHolder instances are used in the Manager logger hierarchy to take\n    the place of nodes for which no loggers have been defined. This class is\n    intended for internal use only and not as part of the public API.\n    \"\"\"\n    def __init__(self, alogger):\n        \"\"\"\n        Initialize with the specified logger being a child of this placeholder.\n        \"\"\"\n        self.loggerMap = { alogger : None }\n\n    def append(self, alogger):\n        \"\"\"\n        Add the specified logger as a child of this placeholder.\n        \"\"\"\n        if alogger not in self.loggerMap:\n            self.loggerMap[alogger] = None\n\n#\n#   Determine which class to use when instantiating loggers.\n#\n\ndef setLoggerClass(klass):\n    \"\"\"\n    Set the class to be used when instantiating a logger. The class should\n    define __init__() such that only a name argument is required, and the\n    __init__() should call Logger.__init__()\n    \"\"\"\n    if klass != Logger:\n        if not issubclass(klass, Logger):\n            raise TypeError(\"logger not derived from logging.Logger: \"\n                            + klass.__name__)\n    global _loggerClass\n    _loggerClass = klass\n\ndef getLoggerClass():\n    \"\"\"\n    Return the class to be used when instantiating a logger.\n    \"\"\"\n    return _loggerClass\n\nclass Manager(object):\n    \"\"\"\n    There is [under normal circumstances] just one Manager instance, which\n    holds the hierarchy of loggers.\n    \"\"\"\n    def __init__(self, rootnode):\n        \"\"\"\n        Initialize the manager with the root node of the logger hierarchy.\n        \"\"\"\n        self.root = rootnode\n        self.disable = 0\n        self.emittedNoHandlerWarning = False\n        self.loggerDict = {}\n        self.loggerClass = None\n        self.logRecordFactory = None\n\n    @property\n    def disable(self):\n        return self._disable\n\n    @disable.setter\n    def disable(self, value):\n        self._disable = _checkLevel(value)\n\n    def getLogger(self, name):\n        \"\"\"\n        Get a logger with the specified name (channel name), creating it\n        if it doesn't yet exist. This name is a dot-separated hierarchical\n        name, such as \"a\", \"a.b\", \"a.b.c\" or similar.\n\n        If a PlaceHolder existed for the specified name [i.e. the logger\n        didn't exist but a child of it did], replace it with the created\n        logger and fix up the parent/child references which pointed to the\n        placeholder to now point to the logger.\n        \"\"\"\n        rv = None\n        if not isinstance(name, str):\n            raise TypeError('A logger name must be a string')\n        _acquireLock()\n        try:\n            if name in self.loggerDict:\n                rv = self.loggerDict[name]\n                if isinstance(rv, PlaceHolder):\n                    ph = rv\n                    rv = (self.loggerClass or _loggerClass)(name)\n                    rv.manager = self\n                    self.loggerDict[name] = rv\n                    self._fixupChildren(ph, rv)\n                    self._fixupParents(rv)\n            else:\n                rv = (self.loggerClass or _loggerClass)(name)\n                rv.manager = self\n                self.loggerDict[name] = rv\n                self._fixupParents(rv)\n        finally:\n            _releaseLock()\n        return rv\n\n    def setLoggerClass(self, klass):\n        \"\"\"\n        Set the class to be used when instantiating a logger with this Manager.\n        \"\"\"\n        if klass != Logger:\n            if not issubclass(klass, Logger):\n                raise TypeError(\"logger not derived from logging.Logger: \"\n                                + klass.__name__)\n        self.loggerClass = klass\n\n    def setLogRecordFactory(self, factory):\n        \"\"\"\n        Set the factory to be used when instantiating a log record with this\n        Manager.\n        \"\"\"\n        self.logRecordFactory = factory\n\n    def _fixupParents(self, alogger):\n        \"\"\"\n        Ensure that there are either loggers or placeholders all the way\n        from the specified logger to the root of the logger hierarchy.\n        \"\"\"\n        name = alogger.name\n        i = name.rfind(\".\")\n        rv = None\n        while (i > 0) and not rv:\n            substr = name[:i]\n            if substr not in self.loggerDict:\n                self.loggerDict[substr] = PlaceHolder(alogger)\n            else:\n                obj = self.loggerDict[substr]\n                if isinstance(obj, Logger):\n                    rv = obj\n                else:\n                    assert isinstance(obj, PlaceHolder)\n                    obj.append(alogger)\n            i = name.rfind(\".\", 0, i - 1)\n        if not rv:\n            rv = self.root\n        alogger.parent = rv\n\n    def _fixupChildren(self, ph, alogger):\n        \"\"\"\n        Ensure that children of the placeholder ph are connected to the\n        specified logger.\n        \"\"\"\n        name = alogger.name\n        namelen = len(name)\n        for c in ph.loggerMap.keys():\n            #The if means ... if not c.parent.name.startswith(nm)\n            if c.parent.name[:namelen] != name:\n                alogger.parent = c.parent\n                c.parent = alogger\n\n    def _clear_cache(self):\n        \"\"\"\n        Clear the cache for all loggers in loggerDict\n        Called when level changes are made\n        \"\"\"\n\n        _acquireLock()\n        for logger in self.loggerDict.values():\n            if isinstance(logger, Logger):\n                logger._cache.clear()\n        self.root._cache.clear()\n        _releaseLock()\n\n#---------------------------------------------------------------------------\n#   Logger classes and functions\n#---------------------------------------------------------------------------\n\nclass Logger(Filterer):\n    \"\"\"\n    Instances of the Logger class represent a single logging channel. A\n    \"logging channel\" indicates an area of an application. Exactly how an\n    \"area\" is defined is up to the application developer. Since an\n    application can have any number of areas, logging channels are identified\n    by a unique string. Application areas can be nested (e.g. an area\n    of \"input processing\" might include sub-areas \"read CSV files\", \"read\n    XLS files\" and \"read Gnumeric files\"). To cater for this natural nesting,\n    channel names are organized into a namespace hierarchy where levels are\n    separated by periods, much like the Java or Python package namespace. So\n    in the instance given above, channel names might be \"input\" for the upper\n    level, and \"input.csv\", \"input.xls\" and \"input.gnu\" for the sub-levels.\n    There is no arbitrary limit to the depth of nesting.\n    \"\"\"\n    def __init__(self, name, level=NOTSET):\n        \"\"\"\n        Initialize the logger with a name and an optional level.\n        \"\"\"\n        Filterer.__init__(self)\n        self.name = name\n        self.level = _checkLevel(level)\n        self.parent = None\n        self.propagate = True\n        self.handlers = []\n        self.disabled = False\n        self._cache = {}\n\n    def setLevel(self, level):\n        \"\"\"\n        Set the logging level of this logger.  level must be an int or a str.\n        \"\"\"\n        self.level = _checkLevel(level)\n        self.manager._clear_cache()\n\n    def debug(self, msg, *args, **kwargs):\n        \"\"\"\n        Log 'msg % args' with severity 'DEBUG'.\n\n        To pass exception information, use the keyword argument exc_info with\n        a true value, e.g.\n\n        logger.debug(\"Houston, we have a %s\", \"thorny problem\", exc_info=1)\n        \"\"\"\n        if self.isEnabledFor(DEBUG):\n            self._log(DEBUG, msg, args, **kwargs)\n\n    def info(self, msg, *args, **kwargs):\n        \"\"\"\n        Log 'msg % args' with severity 'INFO'.\n\n        To pass exception information, use the keyword argument exc_info with\n        a true value, e.g.\n\n        logger.info(\"Houston, we have a %s\", \"interesting problem\", exc_info=1)\n        \"\"\"\n        if self.isEnabledFor(INFO):\n            self._log(INFO, msg, args, **kwargs)\n\n    def warning(self, msg, *args, **kwargs):\n        \"\"\"\n        Log 'msg % args' with severity 'WARNING'.\n\n        To pass exception information, use the keyword argument exc_info with\n        a true value, e.g.\n\n        logger.warning(\"Houston, we have a %s\", \"bit of a problem\", exc_info=1)\n        \"\"\"\n        if self.isEnabledFor(WARNING):\n            self._log(WARNING, msg, args, **kwargs)\n\n    def warn(self, msg, *args, **kwargs):\n        warnings.warn(\"The 'warn' method is deprecated, \"\n            \"use 'warning' instead\", DeprecationWarning, 2)\n        self.warning(msg, *args, **kwargs)\n\n    def error(self, msg, *args, **kwargs):\n        \"\"\"\n        Log 'msg % args' with severity 'ERROR'.\n\n        To pass exception information, use the keyword argument exc_info with\n        a true value, e.g.\n\n        logger.error(\"Houston, we have a %s\", \"major problem\", exc_info=1)\n        \"\"\"\n        if self.isEnabledFor(ERROR):\n            self._log(ERROR, msg, args, **kwargs)\n\n    def exception(self, msg, *args, exc_info=True, **kwargs):\n        \"\"\"\n        Convenience method for logging an ERROR with exception information.\n        \"\"\"\n        self.error(msg, *args, exc_info=exc_info, **kwargs)\n\n    def critical(self, msg, *args, **kwargs):\n        \"\"\"\n        Log 'msg % args' with severity 'CRITICAL'.\n\n        To pass exception information, use the keyword argument exc_info with\n        a true value, e.g.\n\n        logger.critical(\"Houston, we have a %s\", \"major disaster\", exc_info=1)\n        \"\"\"\n        if self.isEnabledFor(CRITICAL):\n            self._log(CRITICAL, msg, args, **kwargs)\n\n    def fatal(self, msg, *args, **kwargs):\n        \"\"\"\n        Don't use this method, use critical() instead.\n        \"\"\"\n        self.critical(msg, *args, **kwargs)\n\n    def log(self, level, msg, *args, **kwargs):\n        \"\"\"\n        Log 'msg % args' with the integer severity 'level'.\n\n        To pass exception information, use the keyword argument exc_info with\n        a true value, e.g.\n\n        logger.log(level, \"We have a %s\", \"mysterious problem\", exc_info=1)\n        \"\"\"\n        if not isinstance(level, int):\n            if raiseExceptions:\n                raise TypeError(\"level must be an integer\")\n            else:\n                return\n        if self.isEnabledFor(level):\n            self._log(level, msg, args, **kwargs)\n\n    def findCaller(self, stack_info=False, stacklevel=1):\n        \"\"\"\n        Find the stack frame of the caller so that we can note the source\n        file name, line number and function name.\n        \"\"\"\n        f = currentframe()\n        #On some versions of IronPython, currentframe() returns None if\n        #IronPython isn't run with -X:Frames.\n        if f is None:\n            return \"(unknown file)\", 0, \"(unknown function)\", None\n        while stacklevel > 0:\n            next_f = f.f_back\n            if next_f is None:\n                ## We've got options here.\n                ## If we want to use the last (deepest) frame:\n                break\n                ## If we want to mimic the warnings module:\n                #return (\"sys\", 1, \"(unknown function)\", None)\n                ## If we want to be pedantic:\n                #raise ValueError(\"call stack is not deep enough\")\n            f = next_f\n            if not _is_internal_frame(f):\n                stacklevel -= 1\n        co = f.f_code\n        sinfo = None\n        if stack_info:\n            with io.StringIO() as sio:\n                sio.write(\"Stack (most recent call last):\\n\")\n                traceback.print_stack(f, file=sio)\n                sinfo = sio.getvalue()\n                if sinfo[-1] == '\\n':\n                    sinfo = sinfo[:-1]\n        return co.co_filename, f.f_lineno, co.co_name, sinfo\n\n    def makeRecord(self, name, level, fn, lno, msg, args, exc_info,\n                   func=None, extra=None, sinfo=None):\n        \"\"\"\n        A factory method which can be overridden in subclasses to create\n        specialized LogRecords.\n        \"\"\"\n        rv = _logRecordFactory(name, level, fn, lno, msg, args, exc_info, func,\n                             sinfo)\n        if extra is not None:\n            for key in extra:\n                if (key in [\"message\", \"asctime\"]) or (key in rv.__dict__):\n                    raise KeyError(\"Attempt to overwrite %r in LogRecord\" % key)\n                rv.__dict__[key] = extra[key]\n        return rv\n\n    def _log(self, level, msg, args, exc_info=None, extra=None, stack_info=False,\n             stacklevel=1):\n        \"\"\"\n        Low-level logging routine which creates a LogRecord and then calls\n        all the handlers of this logger to handle the record.\n        \"\"\"\n        sinfo = None\n        if _srcfile:\n            #IronPython doesn't track Python frames, so findCaller raises an\n            #exception on some versions of IronPython. We trap it here so that\n            #IronPython can use logging.\n            try:\n                fn, lno, func, sinfo = self.findCaller(stack_info, stacklevel)\n            except ValueError: # pragma: no cover\n                fn, lno, func = \"(unknown file)\", 0, \"(unknown function)\"\n        else: # pragma: no cover\n            fn, lno, func = \"(unknown file)\", 0, \"(unknown function)\"\n        if exc_info:\n            if isinstance(exc_info, BaseException):\n                exc_info = (type(exc_info), exc_info, exc_info.__traceback__)\n            elif not isinstance(exc_info, tuple):\n                exc_info = sys.exc_info()\n        record = self.makeRecord(self.name, level, fn, lno, msg, args,\n                                 exc_info, func, extra, sinfo)\n        self.handle(record)\n\n    def handle(self, record):\n        \"\"\"\n        Call the handlers for the specified record.\n\n        This method is used for unpickled records received from a socket, as\n        well as those created locally. Logger-level filtering is applied.\n        \"\"\"\n        if (not self.disabled) and self.filter(record):\n            self.callHandlers(record)\n\n    def addHandler(self, hdlr):\n        \"\"\"\n        Add the specified handler to this logger.\n        \"\"\"\n        _acquireLock()\n        try:\n            if not (hdlr in self.handlers):\n                self.handlers.append(hdlr)\n        finally:\n            _releaseLock()\n\n    def removeHandler(self, hdlr):\n        \"\"\"\n        Remove the specified handler from this logger.\n        \"\"\"\n        _acquireLock()\n        try:\n            if hdlr in self.handlers:\n                self.handlers.remove(hdlr)\n        finally:\n            _releaseLock()\n\n    def hasHandlers(self):\n        \"\"\"\n        See if this logger has any handlers configured.\n\n        Loop through all handlers for this logger and its parents in the\n        logger hierarchy. Return True if a handler was found, else False.\n        Stop searching up the hierarchy whenever a logger with the \"propagate\"\n        attribute set to zero is found - that will be the last logger which\n        is checked for the existence of handlers.\n        \"\"\"\n        c = self\n        rv = False\n        while c:\n            if c.handlers:\n                rv = True\n                break\n            if not c.propagate:\n                break\n            else:\n                c = c.parent\n        return rv\n\n    def callHandlers(self, record):\n        \"\"\"\n        Pass a record to all relevant handlers.\n\n        Loop through all handlers for this logger and its parents in the\n        logger hierarchy. If no handler was found, output a one-off error\n        message to sys.stderr. Stop searching up the hierarchy whenever a\n        logger with the \"propagate\" attribute set to zero is found - that\n        will be the last logger whose handlers are called.\n        \"\"\"\n        c = self\n        found = 0\n        while c:\n            for hdlr in c.handlers:\n                found = found + 1\n                if record.levelno >= hdlr.level:\n                    hdlr.handle(record)\n            if not c.propagate:\n                c = None    #break out\n            else:\n                c = c.parent\n        if (found == 0):\n            if lastResort:\n                if record.levelno >= lastResort.level:\n                    lastResort.handle(record)\n            elif raiseExceptions and not self.manager.emittedNoHandlerWarning:\n                sys.stderr.write(\"No handlers could be found for logger\"\n                                 \" \\\"%s\\\"\\n\" % self.name)\n                self.manager.emittedNoHandlerWarning = True\n\n    def getEffectiveLevel(self):\n        \"\"\"\n        Get the effective level for this logger.\n\n        Loop through this logger and its parents in the logger hierarchy,\n        looking for a non-zero logging level. Return the first one found.\n        \"\"\"\n        logger = self\n        while logger:\n            if logger.level:\n                return logger.level\n            logger = logger.parent\n        return NOTSET\n\n    def isEnabledFor(self, level):\n        \"\"\"\n        Is this logger enabled for level 'level'?\n        \"\"\"\n        if self.disabled:\n            return False\n\n        try:\n            return self._cache[level]\n        except KeyError:\n            _acquireLock()\n            try:\n                if self.manager.disable >= level:\n                    is_enabled = self._cache[level] = False\n                else:\n                    is_enabled = self._cache[level] = (\n                        level >= self.getEffectiveLevel()\n                    )\n            finally:\n                _releaseLock()\n            return is_enabled\n\n    def getChild(self, suffix):\n        \"\"\"\n        Get a logger which is a descendant to this one.\n\n        This is a convenience method, such that\n\n        logging.getLogger('abc').getChild('def.ghi')\n\n        is the same as\n\n        logging.getLogger('abc.def.ghi')\n\n        It's useful, for example, when the parent logger is named using\n        __name__ rather than a literal string.\n        \"\"\"\n        if self.root is not self:\n            suffix = '.'.join((self.name, suffix))\n        return self.manager.getLogger(suffix)\n\n    def __repr__(self):\n        level = getLevelName(self.getEffectiveLevel())\n        return '<%s %s (%s)>' % (self.__class__.__name__, self.name, level)\n\n    def __reduce__(self):\n        if getLogger(self.name) is not self:\n            import pickle\n            raise pickle.PicklingError('logger cannot be pickled')\n        return getLogger, (self.name,)\n\n\nclass RootLogger(Logger):\n    \"\"\"\n    A root logger is not that different to any other logger, except that\n    it must have a logging level and there is only one instance of it in\n    the hierarchy.\n    \"\"\"\n    def __init__(self, level):\n        \"\"\"\n        Initialize the logger with the name \"root\".\n        \"\"\"\n        Logger.__init__(self, \"root\", level)\n\n    def __reduce__(self):\n        return getLogger, ()\n\n_loggerClass = Logger\n\nclass LoggerAdapter(object):\n    \"\"\"\n    An adapter for loggers which makes it easier to specify contextual\n    information in logging output.\n    \"\"\"\n\n    def __init__(self, logger, extra=None):\n        \"\"\"\n        Initialize the adapter with a logger and a dict-like object which\n        provides contextual information. This constructor signature allows\n        easy stacking of LoggerAdapters, if so desired.\n\n        You can effectively pass keyword arguments as shown in the\n        following example:\n\n        adapter = LoggerAdapter(someLogger, dict(p1=v1, p2=\"v2\"))\n        \"\"\"\n        self.logger = logger\n        self.extra = extra\n\n    def process(self, msg, kwargs):\n        \"\"\"\n        Process the logging message and keyword arguments passed in to\n        a logging call to insert contextual information. You can either\n        manipulate the message itself, the keyword args or both. Return\n        the message and kwargs modified (or not) to suit your needs.\n\n        Normally, you'll only need to override this one method in a\n        LoggerAdapter subclass for your specific needs.\n        \"\"\"\n        kwargs[\"extra\"] = self.extra\n        return msg, kwargs\n\n    #\n    # Boilerplate convenience methods\n    #\n    def debug(self, msg, *args, **kwargs):\n        \"\"\"\n        Delegate a debug call to the underlying logger.\n        \"\"\"\n        self.log(DEBUG, msg, *args, **kwargs)\n\n    def info(self, msg, *args, **kwargs):\n        \"\"\"\n        Delegate an info call to the underlying logger.\n        \"\"\"\n        self.log(INFO, msg, *args, **kwargs)\n\n    def warning(self, msg, *args, **kwargs):\n        \"\"\"\n        Delegate a warning call to the underlying logger.\n        \"\"\"\n        self.log(WARNING, msg, *args, **kwargs)\n\n    def warn(self, msg, *args, **kwargs):\n        warnings.warn(\"The 'warn' method is deprecated, \"\n            \"use 'warning' instead\", DeprecationWarning, 2)\n        self.warning(msg, *args, **kwargs)\n\n    def error(self, msg, *args, **kwargs):\n        \"\"\"\n        Delegate an error call to the underlying logger.\n        \"\"\"\n        self.log(ERROR, msg, *args, **kwargs)\n\n    def exception(self, msg, *args, exc_info=True, **kwargs):\n        \"\"\"\n        Delegate an exception call to the underlying logger.\n        \"\"\"\n        self.log(ERROR, msg, *args, exc_info=exc_info, **kwargs)\n\n    def critical(self, msg, *args, **kwargs):\n        \"\"\"\n        Delegate a critical call to the underlying logger.\n        \"\"\"\n        self.log(CRITICAL, msg, *args, **kwargs)\n\n    def log(self, level, msg, *args, **kwargs):\n        \"\"\"\n        Delegate a log call to the underlying logger, after adding\n        contextual information from this adapter instance.\n        \"\"\"\n        if self.isEnabledFor(level):\n            msg, kwargs = self.process(msg, kwargs)\n            self.logger.log(level, msg, *args, **kwargs)\n\n    def isEnabledFor(self, level):\n        \"\"\"\n        Is this logger enabled for level 'level'?\n        \"\"\"\n        return self.logger.isEnabledFor(level)\n\n    def setLevel(self, level):\n        \"\"\"\n        Set the specified level on the underlying logger.\n        \"\"\"\n        self.logger.setLevel(level)\n\n    def getEffectiveLevel(self):\n        \"\"\"\n        Get the effective level for the underlying logger.\n        \"\"\"\n        return self.logger.getEffectiveLevel()\n\n    def hasHandlers(self):\n        \"\"\"\n        See if the underlying logger has any handlers.\n        \"\"\"\n        return self.logger.hasHandlers()\n\n    def _log(self, level, msg, args, exc_info=None, extra=None, stack_info=False):\n        \"\"\"\n        Low-level log implementation, proxied to allow nested logger adapters.\n        \"\"\"\n        return self.logger._log(\n            level,\n            msg,\n            args,\n            exc_info=exc_info,\n            extra=extra,\n            stack_info=stack_info,\n        )\n\n    @property\n    def manager(self):\n        return self.logger.manager\n\n    @manager.setter\n    def manager(self, value):\n        self.logger.manager = value\n\n    @property\n    def name(self):\n        return self.logger.name\n\n    def __repr__(self):\n        logger = self.logger\n        level = getLevelName(logger.getEffectiveLevel())\n        return '<%s %s (%s)>' % (self.__class__.__name__, logger.name, level)\n\n    __class_getitem__ = classmethod(GenericAlias)\n\nroot = RootLogger(WARNING)\nLogger.root = root\nLogger.manager = Manager(Logger.root)\n\n#---------------------------------------------------------------------------\n# Configuration classes and functions\n#---------------------------------------------------------------------------\n\ndef basicConfig(**kwargs):\n    \"\"\"\n    Do basic configuration for the logging system.\n\n    This function does nothing if the root logger already has handlers\n    configured, unless the keyword argument *force* is set to ``True``.\n    It is a convenience method intended for use by simple scripts\n    to do one-shot configuration of the logging package.\n\n    The default behaviour is to create a StreamHandler which writes to\n    sys.stderr, set a formatter using the BASIC_FORMAT format string, and\n    add the handler to the root logger.\n\n    A number of optional keyword arguments may be specified, which can alter\n    the default behaviour.\n\n    filename  Specifies that a FileHandler be created, using the specified\n              filename, rather than a StreamHandler.\n    filemode  Specifies the mode to open the file, if filename is specified\n              (if filemode is unspecified, it defaults to 'a').\n    format    Use the specified format string for the handler.\n    datefmt   Use the specified date/time format.\n    style     If a format string is specified, use this to specify the\n              type of format string (possible values '%', '{', '$', for\n              %-formatting, :meth:`str.format` and :class:`string.Template`\n              - defaults to '%').\n    level     Set the root logger level to the specified level.\n    stream    Use the specified stream to initialize the StreamHandler. Note\n              that this argument is incompatible with 'filename' - if both\n              are present, 'stream' is ignored.\n    handlers  If specified, this should be an iterable of already created\n              handlers, which will be added to the root handler. Any handler\n              in the list which does not have a formatter assigned will be\n              assigned the formatter created in this function.\n    force     If this keyword  is specified as true, any existing handlers\n              attached to the root logger are removed and closed, before\n              carrying out the configuration as specified by the other\n              arguments.\n    encoding  If specified together with a filename, this encoding is passed to\n              the created FileHandler, causing it to be used when the file is\n              opened.\n    errors    If specified together with a filename, this value is passed to the\n              created FileHandler, causing it to be used when the file is\n              opened in text mode. If not specified, the default value is\n              `backslashreplace`.\n\n    Note that you could specify a stream created using open(filename, mode)\n    rather than passing the filename and mode in. However, it should be\n    remembered that StreamHandler does not close its stream (since it may be\n    using sys.stdout or sys.stderr), whereas FileHandler closes its stream\n    when the handler is closed.\n\n    .. versionchanged:: 3.2\n       Added the ``style`` parameter.\n\n    .. versionchanged:: 3.3\n       Added the ``handlers`` parameter. A ``ValueError`` is now thrown for\n       incompatible arguments (e.g. ``handlers`` specified together with\n       ``filename``/``filemode``, or ``filename``/``filemode`` specified\n       together with ``stream``, or ``handlers`` specified together with\n       ``stream``.\n\n    .. versionchanged:: 3.8\n       Added the ``force`` parameter.\n\n    .. versionchanged:: 3.9\n       Added the ``encoding`` and ``errors`` parameters.\n    \"\"\"\n    # Add thread safety in case someone mistakenly calls\n    # basicConfig() from multiple threads\n    _acquireLock()\n    try:\n        force = kwargs.pop('force', False)\n        encoding = kwargs.pop('encoding', None)\n        errors = kwargs.pop('errors', 'backslashreplace')\n        if force:\n            for h in root.handlers[:]:\n                root.removeHandler(h)\n                h.close()\n        if len(root.handlers) == 0:\n            handlers = kwargs.pop(\"handlers\", None)\n            if handlers is None:\n                if \"stream\" in kwargs and \"filename\" in kwargs:\n                    raise ValueError(\"'stream' and 'filename' should not be \"\n                                     \"specified together\")\n            else:\n                if \"stream\" in kwargs or \"filename\" in kwargs:\n                    raise ValueError(\"'stream' or 'filename' should not be \"\n                                     \"specified together with 'handlers'\")\n            if handlers is None:\n                filename = kwargs.pop(\"filename\", None)\n                mode = kwargs.pop(\"filemode\", 'a')\n                if filename:\n                    if 'b' in mode:\n                        errors = None\n                    else:\n                        encoding = io.text_encoding(encoding)\n                    h = FileHandler(filename, mode,\n                                    encoding=encoding, errors=errors)\n                else:\n                    stream = kwargs.pop(\"stream\", None)\n                    h = StreamHandler(stream)\n                handlers = [h]\n            dfs = kwargs.pop(\"datefmt\", None)\n            style = kwargs.pop(\"style\", '%')\n            if style not in _STYLES:\n                raise ValueError('Style must be one of: %s' % ','.join(\n                                 _STYLES.keys()))\n            fs = kwargs.pop(\"format\", _STYLES[style][1])\n            fmt = Formatter(fs, dfs, style)\n            for h in handlers:\n                if h.formatter is None:\n                    h.setFormatter(fmt)\n                root.addHandler(h)\n            level = kwargs.pop(\"level\", None)\n            if level is not None:\n                root.setLevel(level)\n            if kwargs:\n                keys = ', '.join(kwargs.keys())\n                raise ValueError('Unrecognised argument(s): %s' % keys)\n    finally:\n        _releaseLock()\n\n#---------------------------------------------------------------------------\n# Utility functions at module level.\n# Basically delegate everything to the root logger.\n#---------------------------------------------------------------------------\n\ndef getLogger(name=None):\n    \"\"\"\n    Return a logger with the specified name, creating it if necessary.\n\n    If no name is specified, return the root logger.\n    \"\"\"\n    if not name or isinstance(name, str) and name == root.name:\n        return root\n    return Logger.manager.getLogger(name)\n\ndef critical(msg, *args, **kwargs):\n    \"\"\"\n    Log a message with severity 'CRITICAL' on the root logger. If the logger\n    has no handlers, call basicConfig() to add a console handler with a\n    pre-defined format.\n    \"\"\"\n    if len(root.handlers) == 0:\n        basicConfig()\n    root.critical(msg, *args, **kwargs)\n\ndef fatal(msg, *args, **kwargs):\n    \"\"\"\n    Don't use this function, use critical() instead.\n    \"\"\"\n    critical(msg, *args, **kwargs)\n\ndef error(msg, *args, **kwargs):\n    \"\"\"\n    Log a message with severity 'ERROR' on the root logger. If the logger has\n    no handlers, call basicConfig() to add a console handler with a pre-defined\n    format.\n    \"\"\"\n    if len(root.handlers) == 0:\n        basicConfig()\n    root.error(msg, *args, **kwargs)\n\ndef exception(msg, *args, exc_info=True, **kwargs):\n    \"\"\"\n    Log a message with severity 'ERROR' on the root logger, with exception\n    information. If the logger has no handlers, basicConfig() is called to add\n    a console handler with a pre-defined format.\n    \"\"\"\n    error(msg, *args, exc_info=exc_info, **kwargs)\n\ndef warning(msg, *args, **kwargs):\n    \"\"\"\n    Log a message with severity 'WARNING' on the root logger. If the logger has\n    no handlers, call basicConfig() to add a console handler with a pre-defined\n    format.\n    \"\"\"\n    if len(root.handlers) == 0:\n        basicConfig()\n    root.warning(msg, *args, **kwargs)\n\ndef warn(msg, *args, **kwargs):\n    warnings.warn(\"The 'warn' function is deprecated, \"\n        \"use 'warning' instead\", DeprecationWarning, 2)\n    warning(msg, *args, **kwargs)\n\ndef info(msg, *args, **kwargs):\n    \"\"\"\n    Log a message with severity 'INFO' on the root logger. If the logger has\n    no handlers, call basicConfig() to add a console handler with a pre-defined\n    format.\n    \"\"\"\n    if len(root.handlers) == 0:\n        basicConfig()\n    root.info(msg, *args, **kwargs)\n\ndef debug(msg, *args, **kwargs):\n    \"\"\"\n    Log a message with severity 'DEBUG' on the root logger. If the logger has\n    no handlers, call basicConfig() to add a console handler with a pre-defined\n    format.\n    \"\"\"\n    if len(root.handlers) == 0:\n        basicConfig()\n    root.debug(msg, *args, **kwargs)\n\ndef log(level, msg, *args, **kwargs):\n    \"\"\"\n    Log 'msg % args' with the integer severity 'level' on the root logger. If\n    the logger has no handlers, call basicConfig() to add a console handler\n    with a pre-defined format.\n    \"\"\"\n    if len(root.handlers) == 0:\n        basicConfig()\n    root.log(level, msg, *args, **kwargs)\n\ndef disable(level=CRITICAL):\n    \"\"\"\n    Disable all logging calls of severity 'level' and below.\n    \"\"\"\n    root.manager.disable = level\n    root.manager._clear_cache()\n\ndef shutdown(handlerList=_handlerList):\n    \"\"\"\n    Perform any cleanup actions in the logging system (e.g. flushing\n    buffers).\n\n    Should be called at application exit.\n    \"\"\"\n    for wr in reversed(handlerList[:]):\n        #errors might occur, for example, if files are locked\n        #we just ignore them if raiseExceptions is not set\n        try:\n            h = wr()\n            if h:\n                try:\n                    h.acquire()\n                    h.flush()\n                    h.close()\n                except (OSError, ValueError):\n                    # Ignore errors which might be caused\n                    # because handlers have been closed but\n                    # references to them are still around at\n                    # application exit.\n                    pass\n                finally:\n                    h.release()\n        except: # ignore everything, as we're shutting down\n            if raiseExceptions:\n                raise\n            #else, swallow\n\n#Let's try and shutdown automatically on application exit...\nimport atexit\natexit.register(shutdown)\n\n# Null handler\n\nclass NullHandler(Handler):\n    \"\"\"\n    This handler does nothing. It's intended to be used to avoid the\n    \"No handlers could be found for logger XXX\" one-off warning. This is\n    important for library code, which may contain code to log events. If a user\n    of the library does not configure logging, the one-off warning might be\n    produced; to avoid this, the library developer simply needs to instantiate\n    a NullHandler and add it to the top-level logger of the library module or\n    package.\n    \"\"\"\n    def handle(self, record):\n        \"\"\"Stub.\"\"\"\n\n    def emit(self, record):\n        \"\"\"Stub.\"\"\"\n\n    def createLock(self):\n        self.lock = None\n\n    def _at_fork_reinit(self):\n        pass\n\n# Warnings integration\n\n_warnings_showwarning = None\n\ndef _showwarning(message, category, filename, lineno, file=None, line=None):\n    \"\"\"\n    Implementation of showwarnings which redirects to logging, which will first\n    check to see if the file parameter is None. If a file is specified, it will\n    delegate to the original warnings implementation of showwarning. Otherwise,\n    it will call warnings.formatwarning and will log the resulting string to a\n    warnings logger named \"py.warnings\" with level logging.WARNING.\n    \"\"\"\n    if file is not None:\n        if _warnings_showwarning is not None:\n            _warnings_showwarning(message, category, filename, lineno, file, line)\n    else:\n        s = warnings.formatwarning(message, category, filename, lineno, line)\n        logger = getLogger(\"py.warnings\")\n        if not logger.handlers:\n            logger.addHandler(NullHandler())\n        # bpo-46557: Log str(s) as msg instead of logger.warning(\"%s\", s)\n        # since some log aggregation tools group logs by the msg arg\n        logger.warning(str(s))\n\ndef captureWarnings(capture):\n    \"\"\"\n    If capture is true, redirect all warnings to the logging package.\n    If capture is False, ensure that warnings are not redirected to logging\n    but to their original destinations.\n    \"\"\"\n    global _warnings_showwarning\n    if capture:\n        if _warnings_showwarning is None:\n            _warnings_showwarning = warnings.showwarning\n            warnings.showwarning = _showwarning\n    else:\n        if _warnings_showwarning is not None:\n            warnings.showwarning = _warnings_showwarning\n            _warnings_showwarning = None\n",2273],"/home/ma-user/anaconda3/envs/py311/lib/python3.11/multiprocessing/util.py":["#\n# Module providing various facilities to other parts of the package\n#\n# multiprocessing/util.py\n#\n# Copyright (c) 2006-2008, R Oudkerk\n# Licensed to PSF under a Contributor Agreement.\n#\n\nimport os\nimport itertools\nimport sys\nimport weakref\nimport atexit\nimport threading        # we want threading to install it's\n                        # cleanup function before multiprocessing does\nfrom subprocess import _args_from_interpreter_flags\n\nfrom . import process\n\n__all__ = [\n    'sub_debug', 'debug', 'info', 'sub_warning', 'get_logger',\n    'log_to_stderr', 'get_temp_dir', 'register_after_fork',\n    'is_exiting', 'Finalize', 'ForkAwareThreadLock', 'ForkAwareLocal',\n    'close_all_fds_except', 'SUBDEBUG', 'SUBWARNING',\n    ]\n\n#\n# Logging\n#\n\nNOTSET = 0\nSUBDEBUG = 5\nDEBUG = 10\nINFO = 20\nSUBWARNING = 25\n\nLOGGER_NAME = 'multiprocessing'\nDEFAULT_LOGGING_FORMAT = '[%(levelname)s/%(processName)s] %(message)s'\n\n_logger = None\n_log_to_stderr = False\n\ndef sub_debug(msg, *args):\n    if _logger:\n        _logger.log(SUBDEBUG, msg, *args)\n\ndef debug(msg, *args):\n    if _logger:\n        _logger.log(DEBUG, msg, *args)\n\ndef info(msg, *args):\n    if _logger:\n        _logger.log(INFO, msg, *args)\n\ndef sub_warning(msg, *args):\n    if _logger:\n        _logger.log(SUBWARNING, msg, *args)\n\ndef get_logger():\n    '''\n    Returns logger used by multiprocessing\n    '''\n    global _logger\n    import logging\n\n    logging._acquireLock()\n    try:\n        if not _logger:\n\n            _logger = logging.getLogger(LOGGER_NAME)\n            _logger.propagate = 0\n\n            # XXX multiprocessing should cleanup before logging\n            if hasattr(atexit, 'unregister'):\n                atexit.unregister(_exit_function)\n                atexit.register(_exit_function)\n            else:\n                atexit._exithandlers.remove((_exit_function, (), {}))\n                atexit._exithandlers.append((_exit_function, (), {}))\n\n    finally:\n        logging._releaseLock()\n\n    return _logger\n\ndef log_to_stderr(level=None):\n    '''\n    Turn on logging and add a handler which prints to stderr\n    '''\n    global _log_to_stderr\n    import logging\n\n    logger = get_logger()\n    formatter = logging.Formatter(DEFAULT_LOGGING_FORMAT)\n    handler = logging.StreamHandler()\n    handler.setFormatter(formatter)\n    logger.addHandler(handler)\n\n    if level:\n        logger.setLevel(level)\n    _log_to_stderr = True\n    return _logger\n\n\n# Abstract socket support\n\ndef _platform_supports_abstract_sockets():\n    if sys.platform == \"linux\":\n        return True\n    if hasattr(sys, 'getandroidapilevel'):\n        return True\n    return False\n\n\ndef is_abstract_socket_namespace(address):\n    if not address:\n        return False\n    if isinstance(address, bytes):\n        return address[0] == 0\n    elif isinstance(address, str):\n        return address[0] == \"\\0\"\n    raise TypeError(f'address type of {address!r} unrecognized')\n\n\nabstract_sockets_supported = _platform_supports_abstract_sockets()\n\n#\n# Function returning a temp directory which will be removed on exit\n#\n\ndef _remove_temp_dir(rmtree, tempdir):\n    rmtree(tempdir)\n\n    current_process = process.current_process()\n    # current_process() can be None if the finalizer is called\n    # late during Python finalization\n    if current_process is not None:\n        current_process._config['tempdir'] = None\n\ndef get_temp_dir():\n    # get name of a temp directory which will be automatically cleaned up\n    tempdir = process.current_process()._config.get('tempdir')\n    if tempdir is None:\n        import shutil, tempfile\n        tempdir = tempfile.mkdtemp(prefix='pymp-')\n        info('created temp directory %s', tempdir)\n        # keep a strong reference to shutil.rmtree(), since the finalizer\n        # can be called late during Python shutdown\n        Finalize(None, _remove_temp_dir, args=(shutil.rmtree, tempdir),\n                 exitpriority=-100)\n        process.current_process()._config['tempdir'] = tempdir\n    return tempdir\n\n#\n# Support for reinitialization of objects when bootstrapping a child process\n#\n\n_afterfork_registry = weakref.WeakValueDictionary()\n_afterfork_counter = itertools.count()\n\ndef _run_after_forkers():\n    items = list(_afterfork_registry.items())\n    items.sort()\n    for (index, ident, func), obj in items:\n        try:\n            func(obj)\n        except Exception as e:\n            info('after forker raised exception %s', e)\n\ndef register_after_fork(obj, func):\n    _afterfork_registry[(next(_afterfork_counter), id(obj), func)] = obj\n\n#\n# Finalization using weakrefs\n#\n\n_finalizer_registry = {}\n_finalizer_counter = itertools.count()\n\n\nclass Finalize(object):\n    '''\n    Class which supports object finalization using weakrefs\n    '''\n    def __init__(self, obj, callback, args=(), kwargs=None, exitpriority=None):\n        if (exitpriority is not None) and not isinstance(exitpriority,int):\n            raise TypeError(\n                \"Exitpriority ({0!r}) must be None or int, not {1!s}\".format(\n                    exitpriority, type(exitpriority)))\n\n        if obj is not None:\n            self._weakref = weakref.ref(obj, self)\n        elif exitpriority is None:\n            raise ValueError(\"Without object, exitpriority cannot be None\")\n\n        self._callback = callback\n        self._args = args\n        self._kwargs = kwargs or {}\n        self._key = (exitpriority, next(_finalizer_counter))\n        self._pid = os.getpid()\n\n        _finalizer_registry[self._key] = self\n\n    def __call__(self, wr=None,\n                 # Need to bind these locally because the globals can have\n                 # been cleared at shutdown\n                 _finalizer_registry=_finalizer_registry,\n                 sub_debug=sub_debug, getpid=os.getpid):\n        '''\n        Run the callback unless it has already been called or cancelled\n        '''\n        try:\n            del _finalizer_registry[self._key]\n        except KeyError:\n            sub_debug('finalizer no longer registered')\n        else:\n            if self._pid != getpid():\n                sub_debug('finalizer ignored because different process')\n                res = None\n            else:\n                sub_debug('finalizer calling %s with args %s and kwargs %s',\n                          self._callback, self._args, self._kwargs)\n                res = self._callback(*self._args, **self._kwargs)\n            self._weakref = self._callback = self._args = \\\n                            self._kwargs = self._key = None\n            return res\n\n    def cancel(self):\n        '''\n        Cancel finalization of the object\n        '''\n        try:\n            del _finalizer_registry[self._key]\n        except KeyError:\n            pass\n        else:\n            self._weakref = self._callback = self._args = \\\n                            self._kwargs = self._key = None\n\n    def still_active(self):\n        '''\n        Return whether this finalizer is still waiting to invoke callback\n        '''\n        return self._key in _finalizer_registry\n\n    def __repr__(self):\n        try:\n            obj = self._weakref()\n        except (AttributeError, TypeError):\n            obj = None\n\n        if obj is None:\n            return '<%s object, dead>' % self.__class__.__name__\n\n        x = '<%s object, callback=%s' % (\n                self.__class__.__name__,\n                getattr(self._callback, '__name__', self._callback))\n        if self._args:\n            x += ', args=' + str(self._args)\n        if self._kwargs:\n            x += ', kwargs=' + str(self._kwargs)\n        if self._key[0] is not None:\n            x += ', exitpriority=' + str(self._key[0])\n        return x + '>'\n\n\ndef _run_finalizers(minpriority=None):\n    '''\n    Run all finalizers whose exit priority is not None and at least minpriority\n\n    Finalizers with highest priority are called first; finalizers with\n    the same priority will be called in reverse order of creation.\n    '''\n    if _finalizer_registry is None:\n        # This function may be called after this module's globals are\n        # destroyed.  See the _exit_function function in this module for more\n        # notes.\n        return\n\n    if minpriority is None:\n        f = lambda p : p[0] is not None\n    else:\n        f = lambda p : p[0] is not None and p[0] >= minpriority\n\n    # Careful: _finalizer_registry may be mutated while this function\n    # is running (either by a GC run or by another thread).\n\n    # list(_finalizer_registry) should be atomic, while\n    # list(_finalizer_registry.items()) is not.\n    keys = [key for key in list(_finalizer_registry) if f(key)]\n    keys.sort(reverse=True)\n\n    for key in keys:\n        finalizer = _finalizer_registry.get(key)\n        # key may have been removed from the registry\n        if finalizer is not None:\n            sub_debug('calling %s', finalizer)\n            try:\n                finalizer()\n            except Exception:\n                import traceback\n                traceback.print_exc()\n\n    if minpriority is None:\n        _finalizer_registry.clear()\n\n#\n# Clean up on exit\n#\n\ndef is_exiting():\n    '''\n    Returns true if the process is shutting down\n    '''\n    return _exiting or _exiting is None\n\n_exiting = False\n\ndef _exit_function(info=info, debug=debug, _run_finalizers=_run_finalizers,\n                   active_children=process.active_children,\n                   current_process=process.current_process):\n    # We hold on to references to functions in the arglist due to the\n    # situation described below, where this function is called after this\n    # module's globals are destroyed.\n\n    global _exiting\n\n    if not _exiting:\n        _exiting = True\n\n        info('process shutting down')\n        debug('running all \"atexit\" finalizers with priority >= 0')\n        _run_finalizers(0)\n\n        if current_process() is not None:\n            # We check if the current process is None here because if\n            # it's None, any call to ``active_children()`` will raise\n            # an AttributeError (active_children winds up trying to\n            # get attributes from util._current_process).  One\n            # situation where this can happen is if someone has\n            # manipulated sys.modules, causing this module to be\n            # garbage collected.  The destructor for the module type\n            # then replaces all values in the module dict with None.\n            # For instance, after setuptools runs a test it replaces\n            # sys.modules with a copy created earlier.  See issues\n            # #9775 and #15881.  Also related: #4106, #9205, and\n            # #9207.\n\n            for p in active_children():\n                if p.daemon:\n                    info('calling terminate() for daemon %s', p.name)\n                    p._popen.terminate()\n\n            for p in active_children():\n                info('calling join() for process %s', p.name)\n                p.join()\n\n        debug('running the remaining \"atexit\" finalizers')\n        _run_finalizers()\n\natexit.register(_exit_function)\n\n#\n# Some fork aware types\n#\n\nclass ForkAwareThreadLock(object):\n    def __init__(self):\n        self._lock = threading.Lock()\n        self.acquire = self._lock.acquire\n        self.release = self._lock.release\n        register_after_fork(self, ForkAwareThreadLock._at_fork_reinit)\n\n    def _at_fork_reinit(self):\n        self._lock._at_fork_reinit()\n\n    def __enter__(self):\n        return self._lock.__enter__()\n\n    def __exit__(self, *args):\n        return self._lock.__exit__(*args)\n\n\nclass ForkAwareLocal(threading.local):\n    def __init__(self):\n        register_after_fork(self, lambda obj : obj.__dict__.clear())\n    def __reduce__(self):\n        return type(self), ()\n\n#\n# Close fds except those specified\n#\n\ntry:\n    MAXFD = os.sysconf(\"SC_OPEN_MAX\")\nexcept Exception:\n    MAXFD = 256\n\ndef close_all_fds_except(fds):\n    fds = list(fds) + [-1, MAXFD]\n    fds.sort()\n    assert fds[-1] == MAXFD, 'fd too large'\n    for i in range(len(fds) - 1):\n        os.closerange(fds[i]+1, fds[i+1])\n#\n# Close sys.stdin and replace stdin with os.devnull\n#\n\ndef _close_stdin():\n    if sys.stdin is None:\n        return\n\n    try:\n        sys.stdin.close()\n    except (OSError, ValueError):\n        pass\n\n    try:\n        fd = os.open(os.devnull, os.O_RDONLY)\n        try:\n            sys.stdin = open(fd, encoding=\"utf-8\", closefd=False)\n        except:\n            os.close(fd)\n            raise\n    except (OSError, ValueError):\n        pass\n\n#\n# Flush standard streams, if any\n#\n\ndef _flush_std_streams():\n    try:\n        sys.stdout.flush()\n    except (AttributeError, ValueError):\n        pass\n    try:\n        sys.stderr.flush()\n    except (AttributeError, ValueError):\n        pass\n\n#\n# Start a program with only specified fds kept open\n#\n\ndef spawnv_passfds(path, args, passfds):\n    import _posixsubprocess\n    import subprocess\n    passfds = tuple(sorted(map(int, passfds)))\n    errpipe_read, errpipe_write = os.pipe()\n    try:\n        return _posixsubprocess.fork_exec(\n            args, [path], True, passfds, None, None,\n            -1, -1, -1, -1, -1, -1, errpipe_read, errpipe_write,\n            False, False, -1, None, None, None, -1, None,\n            subprocess._USE_VFORK)\n    finally:\n        os.close(errpipe_read)\n        os.close(errpipe_write)\n\n\ndef close_fds(*fds):\n    \"\"\"Close each file descriptor given as an argument\"\"\"\n    for fd in fds:\n        os.close(fd)\n\n\ndef _cleanup_tests():\n    \"\"\"Cleanup multiprocessing resources when multiprocessing tests\n    completed.\"\"\"\n\n    from test import support\n\n    # cleanup multiprocessing\n    process._cleanup()\n\n    # Stop the ForkServer process if it's running\n    from multiprocessing import forkserver\n    forkserver._forkserver._stop()\n\n    # Stop the ResourceTracker process if it's running\n    from multiprocessing import resource_tracker\n    resource_tracker._resource_tracker._stop()\n\n    # bpo-37421: Explicitly call _run_finalizers() to remove immediately\n    # temporary directories created by multiprocessing.util.get_temp_dir().\n    _run_finalizers()\n    support.gc_collect()\n\n    support.reap_children()\n",491],"/home/ma-user/anaconda3/envs/py311/lib/python3.11/multiprocessing/process.py":["#\n# Module providing the `Process` class which emulates `threading.Thread`\n#\n# multiprocessing/process.py\n#\n# Copyright (c) 2006-2008, R Oudkerk\n# Licensed to PSF under a Contributor Agreement.\n#\n\n__all__ = ['BaseProcess', 'current_process', 'active_children',\n           'parent_process']\n\n#\n# Imports\n#\n\nimport os\nimport sys\nimport signal\nimport itertools\nimport threading\nfrom _weakrefset import WeakSet\n\n#\n#\n#\n\ntry:\n    ORIGINAL_DIR = os.path.abspath(os.getcwd())\nexcept OSError:\n    ORIGINAL_DIR = None\n\n#\n# Public functions\n#\n\ndef current_process():\n    '''\n    Return process object representing the current process\n    '''\n    return _current_process\n\ndef active_children():\n    '''\n    Return list of process objects corresponding to live child processes\n    '''\n    _cleanup()\n    return list(_children)\n\n\ndef parent_process():\n    '''\n    Return process object representing the parent process\n    '''\n    return _parent_process\n\n#\n#\n#\n\ndef _cleanup():\n    # check for processes which have finished\n    for p in list(_children):\n        if p._popen.poll() is not None:\n            _children.discard(p)\n\n#\n# The `Process` class\n#\n\nclass BaseProcess(object):\n    '''\n    Process objects represent activity that is run in a separate process\n\n    The class is analogous to `threading.Thread`\n    '''\n    def _Popen(self):\n        raise NotImplementedError\n\n    def __init__(self, group=None, target=None, name=None, args=(), kwargs={},\n                 *, daemon=None):\n        assert group is None, 'group argument must be None for now'\n        count = next(_process_counter)\n        self._identity = _current_process._identity + (count,)\n        self._config = _current_process._config.copy()\n        self._parent_pid = os.getpid()\n        self._parent_name = _current_process.name\n        self._popen = None\n        self._closed = False\n        self._target = target\n        self._args = tuple(args)\n        self._kwargs = dict(kwargs)\n        self._name = name or type(self).__name__ + '-' + \\\n                     ':'.join(str(i) for i in self._identity)\n        if daemon is not None:\n            self.daemon = daemon\n        _dangling.add(self)\n\n    def _check_closed(self):\n        if self._closed:\n            raise ValueError(\"process object is closed\")\n\n    def run(self):\n        '''\n        Method to be run in sub-process; can be overridden in sub-class\n        '''\n        if self._target:\n            self._target(*self._args, **self._kwargs)\n\n    def start(self):\n        '''\n        Start child process\n        '''\n        self._check_closed()\n        assert self._popen is None, 'cannot start a process twice'\n        assert self._parent_pid == os.getpid(), \\\n               'can only start a process object created by current process'\n        assert not _current_process._config.get('daemon'), \\\n               'daemonic processes are not allowed to have children'\n        _cleanup()\n        self._popen = self._Popen(self)\n        self._sentinel = self._popen.sentinel\n        # Avoid a refcycle if the target function holds an indirect\n        # reference to the process object (see bpo-30775)\n        del self._target, self._args, self._kwargs\n        _children.add(self)\n\n    def terminate(self):\n        '''\n        Terminate process; sends SIGTERM signal or uses TerminateProcess()\n        '''\n        self._check_closed()\n        self._popen.terminate()\n\n    def kill(self):\n        '''\n        Terminate process; sends SIGKILL signal or uses TerminateProcess()\n        '''\n        self._check_closed()\n        self._popen.kill()\n\n    def join(self, timeout=None):\n        '''\n        Wait until child process terminates\n        '''\n        self._check_closed()\n        assert self._parent_pid == os.getpid(), 'can only join a child process'\n        assert self._popen is not None, 'can only join a started process'\n        res = self._popen.wait(timeout)\n        if res is not None:\n            _children.discard(self)\n\n    def is_alive(self):\n        '''\n        Return whether process is alive\n        '''\n        self._check_closed()\n        if self is _current_process:\n            return True\n        assert self._parent_pid == os.getpid(), 'can only test a child process'\n\n        if self._popen is None:\n            return False\n\n        returncode = self._popen.poll()\n        if returncode is None:\n            return True\n        else:\n            _children.discard(self)\n            return False\n\n    def close(self):\n        '''\n        Close the Process object.\n\n        This method releases resources held by the Process object.  It is\n        an error to call this method if the child process is still running.\n        '''\n        if self._popen is not None:\n            if self._popen.poll() is None:\n                raise ValueError(\"Cannot close a process while it is still running. \"\n                                 \"You should first call join() or terminate().\")\n            self._popen.close()\n            self._popen = None\n            del self._sentinel\n            _children.discard(self)\n        self._closed = True\n\n    @property\n    def name(self):\n        return self._name\n\n    @name.setter\n    def name(self, name):\n        assert isinstance(name, str), 'name must be a string'\n        self._name = name\n\n    @property\n    def daemon(self):\n        '''\n        Return whether process is a daemon\n        '''\n        return self._config.get('daemon', False)\n\n    @daemon.setter\n    def daemon(self, daemonic):\n        '''\n        Set whether process is a daemon\n        '''\n        assert self._popen is None, 'process has already started'\n        self._config['daemon'] = daemonic\n\n    @property\n    def authkey(self):\n        return self._config['authkey']\n\n    @authkey.setter\n    def authkey(self, authkey):\n        '''\n        Set authorization key of process\n        '''\n        self._config['authkey'] = AuthenticationString(authkey)\n\n    @property\n    def exitcode(self):\n        '''\n        Return exit code of process or `None` if it has yet to stop\n        '''\n        self._check_closed()\n        if self._popen is None:\n            return self._popen\n        return self._popen.poll()\n\n    @property\n    def ident(self):\n        '''\n        Return identifier (PID) of process or `None` if it has yet to start\n        '''\n        self._check_closed()\n        if self is _current_process:\n            return os.getpid()\n        else:\n            return self._popen and self._popen.pid\n\n    pid = ident\n\n    @property\n    def sentinel(self):\n        '''\n        Return a file descriptor (Unix) or handle (Windows) suitable for\n        waiting for process termination.\n        '''\n        self._check_closed()\n        try:\n            return self._sentinel\n        except AttributeError:\n            raise ValueError(\"process not started\") from None\n\n    def __repr__(self):\n        exitcode = None\n        if self is _current_process:\n            status = 'started'\n        elif self._closed:\n            status = 'closed'\n        elif self._parent_pid != os.getpid():\n            status = 'unknown'\n        elif self._popen is None:\n            status = 'initial'\n        else:\n            exitcode = self._popen.poll()\n            if exitcode is not None:\n                status = 'stopped'\n            else:\n                status = 'started'\n\n        info = [type(self).__name__, 'name=%r' % self._name]\n        if self._popen is not None:\n            info.append('pid=%s' % self._popen.pid)\n        info.append('parent=%s' % self._parent_pid)\n        info.append(status)\n        if exitcode is not None:\n            exitcode = _exitcode_to_name.get(exitcode, exitcode)\n            info.append('exitcode=%s' % exitcode)\n        if self.daemon:\n            info.append('daemon')\n        return '<%s>' % ' '.join(info)\n\n    ##\n\n    def _bootstrap(self, parent_sentinel=None):\n        from . import util, context\n        global _current_process, _parent_process, _process_counter, _children\n\n        try:\n            if self._start_method is not None:\n                context._force_start_method(self._start_method)\n            _process_counter = itertools.count(1)\n            _children = set()\n            util._close_stdin()\n            old_process = _current_process\n            _current_process = self\n            _parent_process = _ParentProcess(\n                self._parent_name, self._parent_pid, parent_sentinel)\n            if threading._HAVE_THREAD_NATIVE_ID:\n                threading.main_thread()._set_native_id()\n            try:\n                self._after_fork()\n            finally:\n                # delay finalization of the old process object until after\n                # _run_after_forkers() is executed\n                del old_process\n            util.info('child process calling self.run()')\n            try:\n                self.run()\n                exitcode = 0\n            finally:\n                util._exit_function()\n        except SystemExit as e:\n            if e.code is None:\n                exitcode = 0\n            elif isinstance(e.code, int):\n                exitcode = e.code\n            else:\n                sys.stderr.write(str(e.code) + '\\n')\n                exitcode = 1\n        except:\n            exitcode = 1\n            import traceback\n            sys.stderr.write('Process %s:\\n' % self.name)\n            traceback.print_exc()\n        finally:\n            threading._shutdown()\n            util.info('process exiting with exitcode %d' % exitcode)\n            util._flush_std_streams()\n\n        return exitcode\n\n    @staticmethod\n    def _after_fork():\n        from . import util\n        util._finalizer_registry.clear()\n        util._run_after_forkers()\n\n\n#\n# We subclass bytes to avoid accidental transmission of auth keys over network\n#\n\nclass AuthenticationString(bytes):\n    def __reduce__(self):\n        from .context import get_spawning_popen\n        if get_spawning_popen() is None:\n            raise TypeError(\n                'Pickling an AuthenticationString object is '\n                'disallowed for security reasons'\n                )\n        return AuthenticationString, (bytes(self),)\n\n\n#\n# Create object representing the parent process\n#\n\nclass _ParentProcess(BaseProcess):\n\n    def __init__(self, name, pid, sentinel):\n        self._identity = ()\n        self._name = name\n        self._pid = pid\n        self._parent_pid = None\n        self._popen = None\n        self._closed = False\n        self._sentinel = sentinel\n        self._config = {}\n\n    def is_alive(self):\n        from multiprocessing.connection import wait\n        return not wait([self._sentinel], timeout=0)\n\n    @property\n    def ident(self):\n        return self._pid\n\n    def join(self, timeout=None):\n        '''\n        Wait until parent process terminates\n        '''\n        from multiprocessing.connection import wait\n        wait([self._sentinel], timeout=timeout)\n\n    pid = ident\n\n#\n# Create object representing the main process\n#\n\nclass _MainProcess(BaseProcess):\n\n    def __init__(self):\n        self._identity = ()\n        self._name = 'MainProcess'\n        self._parent_pid = None\n        self._popen = None\n        self._closed = False\n        self._config = {'authkey': AuthenticationString(os.urandom(32)),\n                        'semprefix': '/mp'}\n        # Note that some versions of FreeBSD only allow named\n        # semaphores to have names of up to 14 characters.  Therefore\n        # we choose a short prefix.\n        #\n        # On MacOSX in a sandbox it may be necessary to use a\n        # different prefix -- see #19478.\n        #\n        # Everything in self._config will be inherited by descendant\n        # processes.\n\n    def close(self):\n        pass\n\n\n_parent_process = None\n_current_process = _MainProcess()\n_process_counter = itertools.count(1)\n_children = set()\ndel _MainProcess\n\n#\n# Give names to some return codes\n#\n\n_exitcode_to_name = {}\n\nfor name, signum in list(signal.__dict__.items()):\n    if name[:3]=='SIG' and '_' not in name:\n        _exitcode_to_name[-signum] = f'-{name}'\ndel name, signum\n\n# For debug and leak testing\n_dangling = WeakSet()\n",439],"/home/ma-user/anaconda3/envs/py311/bin/vllm":["#!/home/ma-user/anaconda3/envs/py311/bin/python3.1\n# -*- coding: utf-8 -*-\nimport re\nimport sys\nfrom vllm.entrypoints.cli.main import main\nif __name__ == '__main__':\n    sys.argv[0] = re.sub(r'(-script\\.pyw|\\.exe)?$', '', sys.argv[0])\n    sys.exit(main())\n",8]},"functions":{"get_terminal_size (/home/ma-user/anaconda3/envs/py311/lib/python3.11/shutil.py:1386)":["/home/ma-user/anaconda3/envs/py311/lib/python3.11/shutil.py",1386],"ProcessManager (/home/lc/omni_infer/tools/scripts/start_api_servers.py:53)":["/home/lc/omni_infer/tools/scripts/start_api_servers.py",53],"_ActionsContainer.register (/home/ma-user/anaconda3/envs/py311/lib/python3.11/argparse.py:1383)":["/home/ma-user/anaconda3/envs/py311/lib/python3.11/argparse.py",1383],"_ActionsContainer._get_handler (/home/ma-user/anaconda3/envs/py311/lib/python3.11/argparse.py:1591)":["/home/ma-user/anaconda3/envs/py311/lib/python3.11/argparse.py",1591],"_compile (/home/ma-user/anaconda3/envs/py311/lib/python3.11/re/__init__.py:272)":["/home/ma-user/anaconda3/envs/py311/lib/python3.11/re/__init__.py",272],"compile (/home/ma-user/anaconda3/envs/py311/lib/python3.11/re/__init__.py:225)":["/home/ma-user/anaconda3/envs/py311/lib/python3.11/re/__init__.py",225],"_ActionsContainer.__init__ (/home/ma-user/anaconda3/envs/py311/lib/python3.11/argparse.py:1330)":["/home/ma-user/anaconda3/envs/py311/lib/python3.11/argparse.py",1330],"normalize_encoding (/home/ma-user/anaconda3/envs/py311/lib/python3.11/encodings/__init__.py:43)":["/home/ma-user/anaconda3/envs/py311/lib/python3.11/encodings/__init__.py",43],"_replace_encoding (/home/ma-user/anaconda3/envs/py311/lib/python3.11/locale.py:362)":["/home/ma-user/anaconda3/envs/py311/lib/python3.11/locale.py",362],"normalize (/home/ma-user/anaconda3/envs/py311/lib/python3.11/locale.py:396)":["/home/ma-user/anaconda3/envs/py311/lib/python3.11/locale.py",396],"_expand_lang (/home/ma-user/anaconda3/envs/py311/lib/python3.11/gettext.py:216)":["/home/ma-user/anaconda3/envs/py311/lib/python3.11/gettext.py",216],"find (/home/ma-user/anaconda3/envs/py311/lib/python3.11/gettext.py:467)":["/home/ma-user/anaconda3/envs/py311/lib/python3.11/gettext.py",467],"translation (/home/ma-user/anaconda3/envs/py311/lib/python3.11/gettext.py:507)":["/home/ma-user/anaconda3/envs/py311/lib/python3.11/gettext.py",507],"dgettext (/home/ma-user/anaconda3/envs/py311/lib/python3.11/gettext.py:566)":["/home/ma-user/anaconda3/envs/py311/lib/python3.11/gettext.py",566],"gettext (/home/ma-user/anaconda3/envs/py311/lib/python3.11/gettext.py:604)":["/home/ma-user/anaconda3/envs/py311/lib/python3.11/gettext.py",604],"_ArgumentGroup.__init__ (/home/ma-user/anaconda3/envs/py311/lib/python3.11/argparse.py:1640)":["/home/ma-user/anaconda3/envs/py311/lib/python3.11/argparse.py",1640],"_ActionsContainer.add_argument_group (/home/ma-user/anaconda3/envs/py311/lib/python3.11/argparse.py:1463)":["/home/ma-user/anaconda3/envs/py311/lib/python3.11/argparse.py",1463],"_ActionsContainer._get_optional_kwargs (/home/ma-user/anaconda3/envs/py311/lib/python3.11/argparse.py:1553)":["/home/ma-user/anaconda3/envs/py311/lib/python3.11/argparse.py",1553],"_ActionsContainer._registry_get (/home/ma-user/anaconda3/envs/py311/lib/python3.11/argparse.py:1387)":["/home/ma-user/anaconda3/envs/py311/lib/python3.11/argparse.py",1387],"_ActionsContainer._pop_action_class (/home/ma-user/anaconda3/envs/py311/lib/python3.11/argparse.py:1587)":["/home/ma-user/anaconda3/envs/py311/lib/python3.11/argparse.py",1587],"Action.__init__ (/home/ma-user/anaconda3/envs/py311/lib/python3.11/argparse.py:834)":["/home/ma-user/anaconda3/envs/py311/lib/python3.11/argparse.py",834],"_HelpAction.__init__ (/home/ma-user/anaconda3/envs/py311/lib/python3.11/argparse.py:1099)":["/home/ma-user/anaconda3/envs/py311/lib/python3.11/argparse.py",1099],"HelpFormatter._Section.__init__ (/home/ma-user/anaconda3/envs/py311/lib/python3.11/argparse.py:206)":["/home/ma-user/anaconda3/envs/py311/lib/python3.11/argparse.py",206],"Enum.value (/home/ma-user/anaconda3/envs/py311/lib/python3.11/enum.py:1226)":["/home/ma-user/anaconda3/envs/py311/lib/python3.11/enum.py",1226],"property.__get__ (/home/ma-user/anaconda3/envs/py311/lib/python3.11/enum.py:188)":["/home/ma-user/anaconda3/envs/py311/lib/python3.11/enum.py",188],"HelpFormatter.__init__ (/home/ma-user/anaconda3/envs/py311/lib/python3.11/argparse.py:164)":["/home/ma-user/anaconda3/envs/py311/lib/python3.11/argparse.py",164],"ArgumentParser._get_formatter (/home/ma-user/anaconda3/envs/py311/lib/python3.11/argparse.py:2576)":["/home/ma-user/anaconda3/envs/py311/lib/python3.11/argparse.py",2576],"HelpFormatter._metavar_formatter (/home/ma-user/anaconda3/envs/py311/lib/python3.11/argparse.py:578)":["/home/ma-user/anaconda3/envs/py311/lib/python3.11/argparse.py",578],"HelpFormatter._format_args.<locals>.<listcomp> (/home/ma-user/anaconda3/envs/py311/lib/python3.11/argparse.py:616)":["/home/ma-user/anaconda3/envs/py311/lib/python3.11/argparse.py",616],"HelpFormatter._metavar_formatter.<locals>.format (/home/ma-user/anaconda3/envs/py311/lib/python3.11/argparse.py:587)":["/home/ma-user/anaconda3/envs/py311/lib/python3.11/argparse.py",587],"HelpFormatter._format_args (/home/ma-user/anaconda3/envs/py311/lib/python3.11/argparse.py:594)":["/home/ma-user/anaconda3/envs/py311/lib/python3.11/argparse.py",594],"_ActionsContainer._check_conflict (/home/ma-user/anaconda3/envs/py311/lib/python3.11/argparse.py:1600)":["/home/ma-user/anaconda3/envs/py311/lib/python3.11/argparse.py",1600],"_ActionsContainer._add_action (/home/ma-user/anaconda3/envs/py311/lib/python3.11/argparse.py:1473)":["/home/ma-user/anaconda3/envs/py311/lib/python3.11/argparse.py",1473],"_ArgumentGroup._add_action (/home/ma-user/anaconda3/envs/py311/lib/python3.11/argparse.py:1662)":["/home/ma-user/anaconda3/envs/py311/lib/python3.11/argparse.py",1662],"ArgumentParser._add_action (/home/ma-user/anaconda3/envs/py311/lib/python3.11/argparse.py:1841)":["/home/ma-user/anaconda3/envs/py311/lib/python3.11/argparse.py",1841],"_ActionsContainer.add_argument (/home/ma-user/anaconda3/envs/py311/lib/python3.11/argparse.py:1412)":["/home/ma-user/anaconda3/envs/py311/lib/python3.11/argparse.py",1412],"ArgumentParser.__init__ (/home/ma-user/anaconda3/envs/py311/lib/python3.11/argparse.py:1730)":["/home/ma-user/anaconda3/envs/py311/lib/python3.11/argparse.py",1730],"_StoreAction.__init__ (/home/ma-user/anaconda3/envs/py311/lib/python3.11/argparse.py:919)":["/home/ma-user/anaconda3/envs/py311/lib/python3.11/argparse.py",919],"Namespace.__init__ (/home/ma-user/anaconda3/envs/py311/lib/python3.11/argparse.py:1315)":["/home/ma-user/anaconda3/envs/py311/lib/python3.11/argparse.py",1315],"ArgumentParser._parse_optional (/home/ma-user/anaconda3/envs/py311/lib/python3.11/argparse.py:2218)":["/home/ma-user/anaconda3/envs/py311/lib/python3.11/argparse.py",2218],"ArgumentParser._get_positional_actions.<locals>.<listcomp> (/home/ma-user/anaconda3/envs/py311/lib/python3.11/argparse.py:1854)":["/home/ma-user/anaconda3/envs/py311/lib/python3.11/argparse.py",1854],"ArgumentParser._get_positional_actions (/home/ma-user/anaconda3/envs/py311/lib/python3.11/argparse.py:1853)":["/home/ma-user/anaconda3/envs/py311/lib/python3.11/argparse.py",1853],"ArgumentParser._parse_known_args.<locals>.<listcomp> (/home/ma-user/anaconda3/envs/py311/lib/python3.11/argparse.py:2080)":["/home/ma-user/anaconda3/envs/py311/lib/python3.11/argparse.py",2080],"ArgumentParser._get_nargs_pattern (/home/ma-user/anaconda3/envs/py311/lib/python3.11/argparse.py:2321)":["/home/ma-user/anaconda3/envs/py311/lib/python3.11/argparse.py",2321],"isstring (/home/ma-user/anaconda3/envs/py311/lib/python3.11/re/_compiler.py:568)":["/home/ma-user/anaconda3/envs/py311/lib/python3.11/re/_compiler.py",568],"Enum.__new__ (/home/ma-user/anaconda3/envs/py311/lib/python3.11/enum.py:1074)":["/home/ma-user/anaconda3/envs/py311/lib/python3.11/enum.py",1074],"EnumType.__call__ (/home/ma-user/anaconda3/envs/py311/lib/python3.11/enum.py:669)":["/home/ma-user/anaconda3/envs/py311/lib/python3.11/enum.py",669],"Flag.__and__ (/home/ma-user/anaconda3/envs/py311/lib/python3.11/enum.py:1483)":["/home/ma-user/anaconda3/envs/py311/lib/python3.11/enum.py",1483],"Tokenizer.__next (/home/ma-user/anaconda3/envs/py311/lib/python3.11/re/_parser.py:231)":["/home/ma-user/anaconda3/envs/py311/lib/python3.11/re/_parser.py",231],"Tokenizer.__init__ (/home/ma-user/anaconda3/envs/py311/lib/python3.11/re/_parser.py:222)":["/home/ma-user/anaconda3/envs/py311/lib/python3.11/re/_parser.py",222],"State.__init__ (/home/ma-user/anaconda3/envs/py311/lib/python3.11/re/_parser.py:73)":["/home/ma-user/anaconda3/envs/py311/lib/python3.11/re/_parser.py",73],"Tokenizer.tell (/home/ma-user/anaconda3/envs/py311/lib/python3.11/re/_parser.py:284)":["/home/ma-user/anaconda3/envs/py311/lib/python3.11/re/_parser.py",284],"SubPattern.__init__ (/home/ma-user/anaconda3/envs/py311/lib/python3.11/re/_parser.py:109)":["/home/ma-user/anaconda3/envs/py311/lib/python3.11/re/_parser.py",109],"Tokenizer.get (/home/ma-user/anaconda3/envs/py311/lib/python3.11/re/_parser.py:252)":["/home/ma-user/anaconda3/envs/py311/lib/python3.11/re/_parser.py",252],"Tokenizer.match (/home/ma-user/anaconda3/envs/py311/lib/python3.11/re/_parser.py:247)":["/home/ma-user/anaconda3/envs/py311/lib/python3.11/re/_parser.py",247],"State.groups (/home/ma-user/anaconda3/envs/py311/lib/python3.11/re/_parser.py:79)":["/home/ma-user/anaconda3/envs/py311/lib/python3.11/re/_parser.py",79],"State.opengroup (/home/ma-user/anaconda3/envs/py311/lib/python3.11/re/_parser.py:82)":["/home/ma-user/anaconda3/envs/py311/lib/python3.11/re/_parser.py",82],"SubPattern.append (/home/ma-user/anaconda3/envs/py311/lib/python3.11/re/_parser.py:170)":["/home/ma-user/anaconda3/envs/py311/lib/python3.11/re/_parser.py",170],"SubPattern.__len__ (/home/ma-user/anaconda3/envs/py311/lib/python3.11/re/_parser.py:158)":["/home/ma-user/anaconda3/envs/py311/lib/python3.11/re/_parser.py",158],"SubPattern.__getitem__ (/home/ma-user/anaconda3/envs/py311/lib/python3.11/re/_parser.py:162)":["/home/ma-user/anaconda3/envs/py311/lib/python3.11/re/_parser.py",162],"_parse (/home/ma-user/anaconda3/envs/py311/lib/python3.11/re/_parser.py:507)":["/home/ma-user/anaconda3/envs/py311/lib/python3.11/re/_parser.py",507],"_parse_sub (/home/ma-user/anaconda3/envs/py311/lib/python3.11/re/_parser.py:447)":["/home/ma-user/anaconda3/envs/py311/lib/python3.11/re/_parser.py",447],"SubPattern.getwidth (/home/ma-user/anaconda3/envs/py311/lib/python3.11/re/_parser.py:172)":["/home/ma-user/anaconda3/envs/py311/lib/python3.11/re/_parser.py",172],"State.closegroup (/home/ma-user/anaconda3/envs/py311/lib/python3.11/re/_parser.py:94)":["/home/ma-user/anaconda3/envs/py311/lib/python3.11/re/_parser.py",94],"fix_flags (/home/ma-user/anaconda3/envs/py311/lib/python3.11/re/_parser.py:954)":["/home/ma-user/anaconda3/envs/py311/lib/python3.11/re/_parser.py",954],"parse (/home/ma-user/anaconda3/envs/py311/lib/python3.11/re/_parser.py:970)":["/home/ma-user/anaconda3/envs/py311/lib/python3.11/re/_parser.py",970],"_get_iscased (/home/ma-user/anaconda3/envs/py311/lib/python3.11/re/_compiler.py:426)":["/home/ma-user/anaconda3/envs/py311/lib/python3.11/re/_compiler.py",426],"_combine_flags (/home/ma-user/anaconda3/envs/py311/lib/python3.11/re/_compiler.py:31)":["/home/ma-user/anaconda3/envs/py311/lib/python3.11/re/_compiler.py",31],"_get_literal_prefix (/home/ma-user/anaconda3/envs/py311/lib/python3.11/re/_compiler.py:434)":["/home/ma-user/anaconda3/envs/py311/lib/python3.11/re/_compiler.py",434],"_generate_overlap_table (/home/ma-user/anaconda3/envs/py311/lib/python3.11/re/_compiler.py:405)":["/home/ma-user/anaconda3/envs/py311/lib/python3.11/re/_compiler.py",405],"_compile_info (/home/ma-user/anaconda3/envs/py311/lib/python3.11/re/_compiler.py:509)":["/home/ma-user/anaconda3/envs/py311/lib/python3.11/re/_compiler.py",509],"_compile (/home/ma-user/anaconda3/envs/py311/lib/python3.11/re/_compiler.py:37)":["/home/ma-user/anaconda3/envs/py311/lib/python3.11/re/_compiler.py",37],"_code (/home/ma-user/anaconda3/envs/py311/lib/python3.11/re/_compiler.py:571)":["/home/ma-user/anaconda3/envs/py311/lib/python3.11/re/_compiler.py",571],"compile (/home/ma-user/anaconda3/envs/py311/lib/python3.11/re/_compiler.py:738)":["/home/ma-user/anaconda3/envs/py311/lib/python3.11/re/_compiler.py",738],"match (/home/ma-user/anaconda3/envs/py311/lib/python3.11/re/__init__.py:163)":["/home/ma-user/anaconda3/envs/py311/lib/python3.11/re/__init__.py",163],"ArgumentParser._match_argument (/home/ma-user/anaconda3/envs/py311/lib/python3.11/argparse.py:2180)":["/home/ma-user/anaconda3/envs/py311/lib/python3.11/argparse.py",2180],"ArgumentParser._get_value (/home/ma-user/anaconda3/envs/py311/lib/python3.11/argparse.py:2510)":["/home/ma-user/anaconda3/envs/py311/lib/python3.11/argparse.py",2510],"ArgumentParser._check_value (/home/ma-user/anaconda3/envs/py311/lib/python3.11/argparse.py:2536)":["/home/ma-user/anaconda3/envs/py311/lib/python3.11/argparse.py",2536],"ArgumentParser._get_values (/home/ma-user/anaconda3/envs/py311/lib/python3.11/argparse.py:2454)":["/home/ma-user/anaconda3/envs/py311/lib/python3.11/argparse.py",2454],"_StoreAction.__call__ (/home/ma-user/anaconda3/envs/py311/lib/python3.11/argparse.py:948)":["/home/ma-user/anaconda3/envs/py311/lib/python3.11/argparse.py",948],"ArgumentParser._parse_known_args.<locals>.take_action (/home/ma-user/anaconda3/envs/py311/lib/python3.11/argparse.py:1953)":["/home/ma-user/anaconda3/envs/py311/lib/python3.11/argparse.py",1953],"ArgumentParser._parse_known_args.<locals>.consume_optional (/home/ma-user/anaconda3/envs/py311/lib/python3.11/argparse.py:1974)":["/home/ma-user/anaconda3/envs/py311/lib/python3.11/argparse.py",1974],"ArgumentParser._match_arguments_partial (/home/ma-user/anaconda3/envs/py311/lib/python3.11/argparse.py:2202)":["/home/ma-user/anaconda3/envs/py311/lib/python3.11/argparse.py",2202],"ArgumentParser._parse_known_args.<locals>.consume_positionals (/home/ma-user/anaconda3/envs/py311/lib/python3.11/argparse.py:2051)":["/home/ma-user/anaconda3/envs/py311/lib/python3.11/argparse.py",2051],"ArgumentParser._parse_known_args (/home/ma-user/anaconda3/envs/py311/lib/python3.11/argparse.py:1906)":["/home/ma-user/anaconda3/envs/py311/lib/python3.11/argparse.py",1906],"ArgumentParser.parse_known_args (/home/ma-user/anaconda3/envs/py311/lib/python3.11/argparse.py:1868)":["/home/ma-user/anaconda3/envs/py311/lib/python3.11/argparse.py",1868],"ArgumentParser.parse_args (/home/ma-user/anaconda3/envs/py311/lib/python3.11/argparse.py:1861)":["/home/ma-user/anaconda3/envs/py311/lib/python3.11/argparse.py",1861],"socket.__init__ (/home/ma-user/anaconda3/envs/py311/lib/python3.11/socket.py:220)":["/home/ma-user/anaconda3/envs/py311/lib/python3.11/socket.py",220],"socket.__enter__ (/home/ma-user/anaconda3/envs/py311/lib/python3.11/socket.py:236)":["/home/ma-user/anaconda3/envs/py311/lib/python3.11/socket.py",236],"socket._real_close (/home/ma-user/anaconda3/envs/py311/lib/python3.11/socket.py:494)":["/home/ma-user/anaconda3/envs/py311/lib/python3.11/socket.py",494],"socket.close (/home/ma-user/anaconda3/envs/py311/lib/python3.11/socket.py:498)":["/home/ma-user/anaconda3/envs/py311/lib/python3.11/socket.py",498],"socket.__exit__ (/home/ma-user/anaconda3/envs/py311/lib/python3.11/socket.py:239)":["/home/ma-user/anaconda3/envs/py311/lib/python3.11/socket.py",239],"is_port_available (/home/lc/omni_infer/tools/scripts/start_api_servers.py:34)":["/home/lc/omni_infer/tools/scripts/start_api_servers.py",34],"find_available_port (/home/lc/omni_infer/tools/scripts/start_api_servers.py:44)":["/home/lc/omni_infer/tools/scripts/start_api_servers.py",44],"ProcessManager.__init__ (/home/lc/omni_infer/tools/scripts/start_api_servers.py:55)":["/home/lc/omni_infer/tools/scripts/start_api_servers.py",55],"finalize.__init__ (/home/ma-user/anaconda3/envs/py311/lib/python3.11/weakref.py:568)":["/home/ma-user/anaconda3/envs/py311/lib/python3.11/weakref.py",568],"start_single_node_api_servers (/home/lc/omni_infer/tools/scripts/start_api_servers.py:59)":["/home/lc/omni_infer/tools/scripts/start_api_servers.py",59],"_enum_to_int (/home/ma-user/anaconda3/envs/py311/lib/python3.11/signal.py:34)":["/home/ma-user/anaconda3/envs/py311/lib/python3.11/signal.py",34],"Enum._missing_ (/home/ma-user/anaconda3/envs/py311/lib/python3.11/enum.py:1163)":["/home/ma-user/anaconda3/envs/py311/lib/python3.11/enum.py",1163],"_int_to_enum (/home/ma-user/anaconda3/envs/py311/lib/python3.11/signal.py:24)":["/home/ma-user/anaconda3/envs/py311/lib/python3.11/signal.py",24],"signal (/home/ma-user/anaconda3/envs/py311/lib/python3.11/signal.py:54)":["/home/ma-user/anaconda3/envs/py311/lib/python3.11/signal.py",54],"Popen._internal_poll (/home/ma-user/anaconda3/envs/py311/lib/python3.11/subprocess.py:1915)":["/home/ma-user/anaconda3/envs/py311/lib/python3.11/subprocess.py",1915],"Popen.poll (/home/ma-user/anaconda3/envs/py311/lib/python3.11/subprocess.py:1229)":["/home/ma-user/anaconda3/envs/py311/lib/python3.11/subprocess.py",1229],"Popen._handle_exitstatus (/home/ma-user/anaconda3/envs/py311/lib/python3.11/subprocess.py:1903)":["/home/ma-user/anaconda3/envs/py311/lib/python3.11/subprocess.py",1903],"signal_handler (/home/lc/omni_infer/tools/scripts/start_api_servers.py:177)":["/home/lc/omni_infer/tools/scripts/start_api_servers.py",177],"<module> (/home/lc/omni_infer/tools/scripts/start_api_servers.py:1)":["/home/lc/omni_infer/tools/scripts/start_api_servers.py",1],"finalize._select_for_exit.<locals>.<listcomp> (/home/ma-user/anaconda3/envs/py311/lib/python3.11/weakref.py:637)":["/home/ma-user/anaconda3/envs/py311/lib/python3.11/weakref.py",637],"finalize._select_for_exit.<locals>.<lambda> (/home/ma-user/anaconda3/envs/py311/lib/python3.11/weakref.py:638)":["/home/ma-user/anaconda3/envs/py311/lib/python3.11/weakref.py",638],"finalize._select_for_exit.<locals>.<listcomp> (/home/ma-user/anaconda3/envs/py311/lib/python3.11/weakref.py:639)":["/home/ma-user/anaconda3/envs/py311/lib/python3.11/weakref.py",639],"finalize._select_for_exit (/home/ma-user/anaconda3/envs/py311/lib/python3.11/weakref.py:634)":["/home/ma-user/anaconda3/envs/py311/lib/python3.11/weakref.py",634],"start_single_node_api_servers.<locals>.cleanup_processes (/home/lc/omni_infer/tools/scripts/start_api_servers.py:154)":["/home/lc/omni_infer/tools/scripts/start_api_servers.py",154],"finalize.__call__ (/home/ma-user/anaconda3/envs/py311/lib/python3.11/weakref.py:585)":["/home/ma-user/anaconda3/envs/py311/lib/python3.11/weakref.py",585],"finalize._exitfunc (/home/ma-user/anaconda3/envs/py311/lib/python3.11/weakref.py:641)":["/home/ma-user/anaconda3/envs/py311/lib/python3.11/weakref.py",641],"Handler.acquire (/home/ma-user/anaconda3/envs/py311/lib/python3.11/logging/__init__.py:922)":["/home/ma-user/anaconda3/envs/py311/lib/python3.11/logging/__init__.py",922],"_StderrHandler.stream (/home/ma-user/anaconda3/envs/py311/lib/python3.11/logging/__init__.py:1249)":["/home/ma-user/anaconda3/envs/py311/lib/python3.11/logging/__init__.py",1249],"Handler.release (/home/ma-user/anaconda3/envs/py311/lib/python3.11/logging/__init__.py:929)":["/home/ma-user/anaconda3/envs/py311/lib/python3.11/logging/__init__.py",929],"StreamHandler.flush (/home/ma-user/anaconda3/envs/py311/lib/python3.11/logging/__init__.py:1087)":["/home/ma-user/anaconda3/envs/py311/lib/python3.11/logging/__init__.py",1087],"_acquireLock (/home/ma-user/anaconda3/envs/py311/lib/python3.11/logging/__init__.py:228)":["/home/ma-user/anaconda3/envs/py311/lib/python3.11/logging/__init__.py",228],"_releaseLock (/home/ma-user/anaconda3/envs/py311/lib/python3.11/logging/__init__.py:237)":["/home/ma-user/anaconda3/envs/py311/lib/python3.11/logging/__init__.py",237],"Handler.close (/home/ma-user/anaconda3/envs/py311/lib/python3.11/logging/__init__.py:998)":["/home/ma-user/anaconda3/envs/py311/lib/python3.11/logging/__init__.py",998],"shutdown (/home/ma-user/anaconda3/envs/py311/lib/python3.11/logging/__init__.py:2177)":["/home/ma-user/anaconda3/envs/py311/lib/python3.11/logging/__init__.py",2177],"info (/home/ma-user/anaconda3/envs/py311/lib/python3.11/multiprocessing/util.py:52)":["/home/ma-user/anaconda3/envs/py311/lib/python3.11/multiprocessing/util.py",52],"debug (/home/ma-user/anaconda3/envs/py311/lib/python3.11/multiprocessing/util.py:48)":["/home/ma-user/anaconda3/envs/py311/lib/python3.11/multiprocessing/util.py",48],"_run_finalizers.<locals>.<lambda> (/home/ma-user/anaconda3/envs/py311/lib/python3.11/multiprocessing/util.py:284)":["/home/ma-user/anaconda3/envs/py311/lib/python3.11/multiprocessing/util.py",284],"_run_finalizers.<locals>.<listcomp> (/home/ma-user/anaconda3/envs/py311/lib/python3.11/multiprocessing/util.py:291)":["/home/ma-user/anaconda3/envs/py311/lib/python3.11/multiprocessing/util.py",291],"_run_finalizers (/home/ma-user/anaconda3/envs/py311/lib/python3.11/multiprocessing/util.py:268)":["/home/ma-user/anaconda3/envs/py311/lib/python3.11/multiprocessing/util.py",268],"current_process (/home/ma-user/anaconda3/envs/py311/lib/python3.11/multiprocessing/process.py:37)":["/home/ma-user/anaconda3/envs/py311/lib/python3.11/multiprocessing/process.py",37],"_cleanup (/home/ma-user/anaconda3/envs/py311/lib/python3.11/multiprocessing/process.py:61)":["/home/ma-user/anaconda3/envs/py311/lib/python3.11/multiprocessing/process.py",61],"active_children (/home/ma-user/anaconda3/envs/py311/lib/python3.11/multiprocessing/process.py:43)":["/home/ma-user/anaconda3/envs/py311/lib/python3.11/multiprocessing/process.py",43],"_run_finalizers.<locals>.<lambda> (/home/ma-user/anaconda3/envs/py311/lib/python3.11/multiprocessing/util.py:282)":["/home/ma-user/anaconda3/envs/py311/lib/python3.11/multiprocessing/util.py",282],"sub_debug (/home/ma-user/anaconda3/envs/py311/lib/python3.11/multiprocessing/util.py:44)":["/home/ma-user/anaconda3/envs/py311/lib/python3.11/multiprocessing/util.py",44],"Finalize.__call__ (/home/ma-user/anaconda3/envs/py311/lib/python3.11/multiprocessing/util.py:205)":["/home/ma-user/anaconda3/envs/py311/lib/python3.11/multiprocessing/util.py",205],"_exit_function (/home/ma-user/anaconda3/envs/py311/lib/python3.11/multiprocessing/util.py:320)":["/home/ma-user/anaconda3/envs/py311/lib/python3.11/multiprocessing/util.py",320],"<module> (/home/ma-user/anaconda3/envs/py311/bin/vllm:1)":["/home/ma-user/anaconda3/envs/py311/bin/vllm",1]}}}